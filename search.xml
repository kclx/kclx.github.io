<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>方差分析</title>
      <link href="/2023/12/29/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
      <url>/2023/12/29/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h1><p>方差分析（Analysis of Variance，ANOVA）是一种统计方法，用于比较多个组之间的平均值是否存在显著差异。方差分析的基本思想是通过比较组内变异性与组间变异性的大小来判断组间平均值是否有显著差异。</p><p>在方差分析中，数据被分成若干组，然后分别计算每组的平均值。方差分析的目标是比较这些组的平均值是否存在显著差异，而不只是简单地比较它们的平均值。</p><p>方差分析通常分为一元方差分析（One-Way ANOVA）和双因素方差分析（Two-Way ANOVA）两种主要类型。</p><ol><li><p><strong>一元方差分析（One-Way ANOVA）：</strong> 适用于有一个因素（自变量）的情况，该因素有三个或更多水平（组）。例如，你可能想要比较不同教育水平的学生在考试成绩上是否存在显著差异。</p></li><li><p><strong>双因素方差分析（Two-Way ANOVA）：</strong> 适用于有两个因素（自变量）的情况，这两个因素可能相互影响。例如，你可能想要了解不同药物和不同剂量对疾病治疗效果的影响。</p></li></ol><p>方差分析的假设包括对数据的正态性和方差齐性的假设。如果数据符合这些假设，方差分析的结果可以用来判断组间平均值是否有显著差异。</p><p>进行方差分析时，通常会计算F统计量，然后与临界值进行比较以判断差异是否显著。如果F统计量大于临界值，就可以拒绝原假设，认为组间存在显著差异。</p><p>方差分析是一种强大的统计工具，常用于实验设计和数据分析中，以确定组别之间的差异性。</p><h2 id="方差的统计量"><a href="#方差的统计量" class="headerlink" title="方差的统计量"></a>方差的统计量</h2><h3 id="水平的均值"><a href="#水平的均值" class="headerlink" title="水平的均值"></a>水平的均值</h3><p>$$ \bar x_i &#x3D; \frac{\sum_{j&#x3D;1}^{n_i} x_{ij}}{n_i} $$</p><ul><li>$n_i$为第$i$个总体的样本观察值个数</li><li>$x_{ij}$为第$i$个总体的第$j$个观察值</li></ul><h3 id="全部观察值的总均值"><a href="#全部观察值的总均值" class="headerlink" title="全部观察值的总均值"></a>全部观察值的总均值</h3><p>$$ \bar{\bar{x}} &#x3D; \frac{\sum_{i&#x3D;1}^{k}\sum_{j&#x3D;1}^{n_i} x_{ij}}{N} $$</p><ul><li>$k$ 是总体的个数，</li><li>$n_i$ 是第 $i$ 个总体的样本观察值个数，</li><li>$x_{ij}$ 是第 $i$ 个总体的第 $j$ 个观察值，</li><li>$N$ 是所有观察值的总个数，即 $N &#x3D; \sum_{i&#x3D;1}^{k} n_i$。</li></ul><h3 id="总误差平方和SST"><a href="#总误差平方和SST" class="headerlink" title="总误差平方和SST"></a>总误差平方和SST</h3><p>总误差平方和（Total Sum of Squares，SST）是在方差分析中的一个重要概念，它用于衡量所有观察值与总体均值之间的总变异性。</p><p>SST的计算公式为：</p><p>$$ SST &#x3D; \sum_{i&#x3D;1}^{k}\sum_{j&#x3D;1}^{n_i} (x_{ij} - \bar{\bar{x}})^2 $$</p><p>其中：</p><ul><li>$k$ 是总体的个数，</li><li>$n_i$ 是第 $i$ 个总体的样本观察值个数，</li><li>$x_{ij}$ 是第 $i$ 个总体的第 $j$ 个观察值，</li><li>$\bar{\bar{x}}$ 是全部观察值的总均值，即 $\bar{\bar{x}} &#x3D; \frac{\sum_{i&#x3D;1}^{k}\sum_{j&#x3D;1}^{n_i} x_{ij}}{N}$ ，其中 $N$ 是所有观察值的总个数。</li></ul><h3 id="水平项平方和SSA"><a href="#水平项平方和SSA" class="headerlink" title="水平项平方和SSA"></a>水平项平方和SSA</h3><p>水平项平方和（Sum of Squares for Treatments，SSA），也称为组间平方和（Between-Groups Sum of Squares），是在方差分析中的一个关键概念。它用于衡量各个水平（组别）均值与整体均值之间的总变异性。</p><p>SSA的计算公式为：</p><p>$$ SSA &#x3D; \sum_{i&#x3D;1}^{k} n_i (\bar{x}_i - \bar{\bar{x}})^2 $$</p><p>其中：</p><ul><li>$k$ 是总体的个数，</li><li>$n_i$ 是第 $i$ 个总体的样本观察值个数，</li><li>$\bar{x}_i$ 是第 $i$ 个总体的样本均值，</li><li>$\bar{\bar{x}}$ 是全部观察值的总均值，即 $\bar{\bar{x}} &#x3D; \frac{\sum_{i&#x3D;1}^{k}\sum_{j&#x3D;1}^{n_i} x_{ij}}{N}$ ，其中 $N$ 是所有观察值的总个数。</li></ul><h3 id="误差项平方和SSE"><a href="#误差项平方和SSE" class="headerlink" title="误差项平方和SSE"></a>误差项平方和SSE</h3><p>误差项平方和（Sum of Squares for Error，SSE），也称为组内平方和（Within-Groups Sum of Squares），是方差分析中的另一个关键概念。它用于衡量每个组内观察值与组均值之间的总变异性。</p><p>SSE的计算公式为：</p><p>$$ SSE &#x3D; \sum_{i&#x3D;1}^{k}\sum_{j&#x3D;1}^{n_i} (x_{ij} - \bar{x}_i)^2 $$</p><p>其中：</p><ul><li>$k$ 是总体的个数，</li><li>$n_i$ 是第 $i$ 个总体的样本观察值个数，</li><li>$x_{ij}$ 是第 $i$ 个总体的第 $j$ 个观察值，</li><li>$\bar{x}_i$ 是第 $i$ 个总体的样本均值。</li></ul><h3 id="平方和之间的联系"><a href="#平方和之间的联系" class="headerlink" title="平方和之间的联系"></a>平方和之间的联系</h3><p>在方差分析中，SST（总误差平方和）、SSA（组间平方和）和SSE（组内平方和）之间有着特定的关系。它们之间的关系可以总结如下：</p><ol><li><p><strong>关系：</strong></p><ul><li>$\text{SST} &#x3D; \text{SSA} + \text{SSE}$</li><li>总误差平方和（SST）等于组间平方和（SSA）和组内平方和（SSE）的总和。</li></ul></li><li><p><strong>自由度：</strong></p><ul><li>总自由度 $df_{\text{total}} &#x3D; N - 1$，其中 $N$ 是所有观察值的总数。</li><li>组间自由度 $df_{\text{between}} &#x3D; k - 1$，其中 $k$ 是总体的个数（组别数）。</li><li>组内自由度 $df_{\text{within}} &#x3D; N - k$。</li></ul></li></ol><p>这些自由度的计算方式和关系如下：</p><ul><li>总自由度是所有数据点的个数减去1，因为在计算总均值时使用了一个自由度。</li><li>组间自由度是组别数减去1，因为我们在比较组别均值时有一个约束（总体均值）。</li><li>组内自由度是总自由度减去组间自由度，表示不同组内的自由度之和。</li></ul><h3 id="均方MS"><a href="#均方MS" class="headerlink" title="均方MS"></a>均方MS</h3><p>在方差分析中，均方（Mean Square，MS）是平方和（Sum of Squares，SS）除以相应的自由度（degrees of freedom，df）得到的值。均方用于衡量数据的变异性，并在F检验中用于计算F统计量。有组间均方（MSA，Mean Square for Among-groups）、组内均方（MSE，Mean Square for Error）等不同类型的均方。</p><p>具体地，组间均方（MSA）和组内均方（MSE）的计算方式如下：</p><ol><li><p><strong>组间均方（MSA）：</strong><br>$$ MSA &#x3D; \frac{SSA}{df_{\text{between}}} $$<br>其中，SSA是组间平方和，$df_{\text{between}}$ 是组间自由度。</p></li><li><p><strong>组内均方（MSE）：</strong><br>$$ MSE &#x3D; \frac{SSE}{df_{\text{within}}} $$<br>其中，SSE是组内平方和，$df_{\text{within}}$ 是组内自由度。</p></li></ol><h3 id="F统计量"><a href="#F统计量" class="headerlink" title="F统计量"></a>F统计量</h3><p>F统计量是方差分析中用于判断组别均值是否存在显著差异的一种统计量。它基于组间均方（MSA，Mean Square for Among-groups）和组内均方（MSE，Mean Square for Error）的比值计算而得。F统计量的计算公式为：</p><p>$$ F &#x3D; \frac{MSA}{MSE} \sim F({k-1},{n-k}) $$</p><p>其中：</p><ul><li><p><strong>MSA（组间均方）</strong> 是组间平方和（SSA）除以组间自由度（$df_{\text{between}}$）得到的均方：<br>$$ MSA &#x3D; \frac{SSA}{df_{\text{between}}} $$</p></li><li><p><strong>MSE（组内均方）</strong> 是组内平方和（SSE）除以组内自由度（$df_{\text{within}}$）得到的均方：<br>$$ MSE &#x3D; \frac{SSE}{df_{\text{within}}} $$</p></li></ul><p>F统计量的大致含义是组间均方相对于组内均方是否显著大。如果F统计量较大，说明组间的变异性相对于组内的变异性较大，从而支持组别均值存在显著差异的假设。</p><p>在F检验中，我们将计算得到的F值与临界值进行比较。如果F值大于临界值，就可以拒绝零假设，认为组别之间存在显著差异。</p><h2 id="方差分析表"><a href="#方差分析表" class="headerlink" title="方差分析表"></a>方差分析表</h2><p>方差分析表（Analysis of Variance table，ANOVA table）是用于总结方差分析结果的一种表格形式。该表格包含了关键的统计信息，帮助解释组间差异和整体变异性。</p><p>方差分析表通常包括以下主要部分：</p><ol><li><p><strong>来源（Source）：</strong> 列出了分析中的各个来源，包括组间（Between-Groups）和组内（Within-Groups）。</p></li><li><p><strong>自由度（Degrees of Freedom，df）：</strong> 指明了每个来源的自由度，分别是组间自由度（$df_{\text{between}}$）和组内自由度（$df_{\text{within}}$）。</p></li><li><p><strong>均方（Mean Square，MS）：</strong> 对应于每个来源的均方，包括组间均方（MSA，Mean Square for Among-groups）和组内均方（MSE，Mean Square for Error）。</p></li><li><p><strong>F统计量：</strong> 包括计算得到的F值，用于判断组别之间的均值是否存在显著差异。</p></li><li><p><strong>p值：</strong> 表示F统计量的显著性水平。如果p值小于设定的显著性水平（通常为0.05），就拒绝零假设，认为组别之间存在显著差异。</p></li></ol><p>一个简化的方差分析表可能如下所示：</p><table><thead><tr><th>来源</th><th>离差平方和</th><th>自由度</th><th>均方</th><th>F值</th><th>p值</th></tr></thead><tbody><tr><td>组间</td><td>SSA</td><td>$df_{\text{between}}$</td><td>MSA</td><td>F统计量</td><td>p值</td></tr><tr><td>组内</td><td>SSE</td><td>$df_{\text{within}}$</td><td>MSE</td><td>-</td><td>-</td></tr><tr><td>总计</td><td>SST</td><td>$df_{\text{total}}$</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="方差分析中的多重比较"><a href="#方差分析中的多重比较" class="headerlink" title="方差分析中的多重比较"></a>方差分析中的多重比较</h2><h3 id="LSD"><a href="#LSD" class="headerlink" title="LSD"></a>LSD</h3><p>$$ t &#x3D; \frac{ \bar X_i - \bar X_j}{\sqrt{SM_w \left( \frac{1}{n_i} + \frac{1}{n_j} \right) }} \sim t \left( {df_w} \right) $$</p><p>如果$ \lvert \bar X_i - \bar X_j \lvert \gt t_{\frac{a}{2}} \sqrt{SM_w \left( \frac{1}{n_i} + \frac{1}{n_j} \right) } $则认为$ \mu_1 $与$ \mu_2 $有显著差异，否则认为它们之间没有显著差异。</p><h3 id="多因素方差分析"><a href="#多因素方差分析" class="headerlink" title="多因素方差分析"></a>多因素方差分析</h3><p>多因素方差分析是一种用于分析两个或更多自变量（因素）对因变量的影响的统计方法。这种分析考虑了多个因素同时对因变量产生的影响，包括它们的主效应和可能的交互效应。</p><ul><li>无交互效应的多因素方差分析<br>在无交互效应的多因素方差分析中，各因素对因变量的影响是独立的，没有因素之间的相互作用。这意味着每个因素的影响都是独立的，没有因素之间的影响效应。</li><li>有交互效应的多因素方差分析<br>有交互效应的多因素方差分析考虑了不同因素之间的相互作用对因变量的影响。交互效应表示两个或多个因素组合在一起对因变量产生的效应，这可能导致因素之间的影响并非简单地叠加。</li></ul><h4 id="主效应与交互效应"><a href="#主效应与交互效应" class="headerlink" title="主效应与交互效应"></a>主效应与交互效应</h4><ol><li><p><strong>主效应：</strong> 表示每个因素对因变量的独立影响，即每个因素的平均效应。</p></li><li><p><strong>交互效应：</strong> 表示两个或多个因素组合在一起对因变量产生的影响，表现为因素之间的非独立影响。</p></li></ol><h4 id="双因素方差分析的类型"><a href="#双因素方差分析的类型" class="headerlink" title="双因素方差分析的类型"></a>双因素方差分析的类型</h4><p>在双因素方差分析中，可以有以下几种类型：</p><ul><li><p><strong>两因素无交互效应方差分析：</strong> 考虑两个因素的独立影响，没有因素之间的相互作用。</p></li><li><p><strong>两因素有交互效应方差分析：</strong> 考虑两个因素的独立影响以及它们之间的相互作用。</p></li><li><p><strong>重复测量方差分析：</strong> 考虑两个因素，其中一个或两个因素可能是重复测量的因素，即相同个体在不同条件下的观测。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> variance analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX公式大全</title>
      <link href="/2023/12/28/LaTeX%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
      <url>/2023/12/28/LaTeX%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>大写</th><th>LaTeX</th><th>小写</th><th>LaTeX</th></tr></thead><tbody><tr><td>$$ A $$</td><td>A</td><td>$$ \alpha $$</td><td>\alpha</td></tr><tr><td>$$ B $$</td><td>B</td><td>$$ \beta $$</td><td>\beta</td></tr><tr><td>$$ \Gamma $$</td><td>\Gamma</td><td>$$ \gamma $$</td><td>\gamma</td></tr><tr><td>$$ E $$</td><td>E</td><td>$$ \epsilon $$</td><td>\epsilon</td></tr><tr><td></td><td></td><td>$$ \varepsilon $$</td><td>\varepsilon</td></tr><tr><td>$$ Z $$</td><td>Z</td><td>$$ \zeta $$</td><td>\zeta</td></tr><tr><td>$$ H $$</td><td>H</td><td>$$ \eta $$</td><td>\eta</td></tr><tr><td>$$ \Theta $$</td><td>\Theta</td><td>$$ \theta $$</td><td>\theta</td></tr><tr><td>$$ I $$</td><td>I</td><td>$$ \iota $$</td><td>\iota</td></tr><tr><td>$$ K $$</td><td>K</td><td>$$ \kappa $$</td><td>\kappa</td></tr><tr><td>$$ \Lambda $$</td><td>\Lambda</td><td>$$ \lambda $$</td><td>\lambda</td></tr><tr><td>$$ M $$</td><td>M</td><td>$$ \mu $$</td><td>\mu</td></tr><tr><td>$$ N $$</td><td>N</td><td>$$ \nu $$</td><td>\nu</td></tr><tr><td>$$ \Xi $$</td><td>\Xi</td><td>$$ \xi $$</td><td>\xi</td></tr><tr><td>$$ O $$</td><td>O</td><td>$$ \omicron $$</td><td>\omicron</td></tr><tr><td>$$ \Pi $$</td><td>\Pi</td><td>$$ \pi $$</td><td>\pi</td></tr><tr><td>$$ P $$</td><td>P</td><td>$$ \rho $$</td><td>\rho</td></tr><tr><td>$$ \Sigma $$</td><td>\Sigma</td><td>$$ \sigma $$</td><td>\sigma</td></tr><tr><td>$$ T $$</td><td>T</td><td>$$ \tau $$</td><td>\tau</td></tr><tr><td>$$ \Upsilon $$</td><td>\Upsilon</td><td>$$ \upsilon $$</td><td>\upsilon</td></tr><tr><td>$$ \Phi $$</td><td>\Phi</td><td>$$ \phi $$</td><td>\phi</td></tr><tr><td></td><td></td><td>$$ \varphi $$</td><td>\varphi</td></tr><tr><td>$$ X $$</td><td>X</td><td>$$ \chi $$</td><td>\chi</td></tr><tr><td>$$ \Psi $$</td><td>\Psi</td><td>$$ \psi $$</td><td>\psi</td></tr><tr><td>$$ \Omega $$</td><td>\omega</td><td>$$ \omega $$</td><td>\omega</td></tr></tbody></table><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><table><thead><tr><th>算式</th><th>LaTeX</th></tr></thead><tbody><tr><td>$$ \ln{x} $$</td><td>\ln{x}</td></tr><tr><td>$$ \log_{x}{y} $$</td><td>\log_{x}{y}</td></tr><tr><td>$$ \lg{x} $$</td><td>\lg{x}</td></tr></tbody></table><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th>函数</th><th>LaTeX</th><th>名称</th></tr></thead><tbody><tr><td>$$ \sin{x} $$</td><td>\sin{x}</td><td>正弦函数（Sine）</td></tr><tr><td>$$ \cos{x} $$</td><td>\cos{x}</td><td>余弦函数（Cosine）</td></tr><tr><td>$$ \tan{x} $$</td><td>\tan{x}</td><td>正切函数（Tangent）</td></tr><tr><td>$$ \cot{x} $$</td><td>\cot{x}</td><td>余切函数（Cotangent）</td></tr><tr><td>$$ \arccos{x} $$</td><td>\arccos{x}</td><td>反余弦函数（Inverse Cosine）</td></tr><tr><td>$$ \arcsin{x} $$</td><td>\arcsin{x}</td><td>反正弦函数（Inverse Sine）</td></tr><tr><td>$$ \arctan{x} $$</td><td>\arctan{x}</td><td>反正切函数（Inverse Tangent）</td></tr><tr><td>$$ \sec{x} $$</td><td>\sec{x}</td><td>正割函数（Secant）</td></tr><tr><td>$$ \csc{x} $$</td><td>\csc{x}</td><td>余割函数（Cosecant）</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>交</td><td>$$ \cap $$</td><td>\cap</td></tr><tr><td>并</td><td>$$ \cup $$</td><td>\cup</td></tr><tr><td>空</td><td>$$ \emptyset $$</td><td>\emptyset or \empty</td></tr><tr><td>乘法</td><td>$$ \circ $$</td><td>\circ</td></tr><tr><td>向左箭头</td><td>$$ \leftarrow $$</td><td>\larr or \leftarrow</td></tr><tr><td>向右箭头</td><td>$$ \to $$</td><td>\rarr or \to</td></tr><tr><td>属于</td><td>$$ \in $$</td><td>\in</td></tr><tr><td>不属于</td><td>$$ \notin \not\in $$</td><td>\notin or \not\in</td></tr><tr><td>右子集</td><td>$$ \subset $$</td><td>\subset or \sub</td></tr><tr><td>实数集</td><td>$$ \mathbb {R} $$</td><td>\mathbb {R} or \R</td></tr><tr><td>自然数集</td><td>$$ \mathbb {N} $$</td><td>\mathbb {N} or \N</td></tr><tr><td>整数集</td><td>$$ \mathbb {Z} $$</td><td>\mathbb {Z} or \Z</td></tr><tr><td>有理数集</td><td>$$ \mathbb {Q} $$</td><td>\mathbb {Q} or \Q</td></tr><tr><td>复数集</td><td>$$ \mathbb {C} $$</td><td>\mathbb {C} or \C</td></tr><tr><td>补集</td><td>$$ A’ \quad A^c $$</td><td>A’ or A^c</td></tr><tr><td>差集</td><td>$$ \setminus $$</td><td>\setminus</td></tr><tr><td>右真子集</td><td>$$ \subseteq $$</td><td>\subseteq</td></tr><tr><td>右非真子集</td><td>$$ \subsetneq $$</td><td>\subsetneq</td></tr><tr><td>左子集</td><td>$$ \supset $$</td><td>\supset</td></tr><tr><td>左真子集</td><td>$$ \supseteq $$</td><td>\supseteq</td></tr><tr><td>右非真子集</td><td>$$ \supsetneq $$</td><td>\supsetneq</td></tr><tr><td>同或</td><td>$$ \odot $$</td><td>\odot</td></tr><tr><td>同与</td><td>$$ \otimes $$</td><td>\otimes</td></tr><tr><td>左非子集</td><td>$$ \not\supset $$</td><td>\not\supset</td></tr><tr><td>右非子集</td><td>$$ \not\subset $$</td><td>\not\sub or \not\subset</td></tr><tr><td>真子集（Proper Subset）</td><td>$$ \varsubsetneq $$</td><td>\varsubsetneq</td></tr><tr><td>真超集（Proper Superset）</td><td>$$ \varsupsetneq $$</td><td>\varsupsetneq</td></tr><tr><td>不是子集（Not a Subset）</td><td>$$ \nsubseteq $$</td><td>\nsubseteq</td></tr><tr><td>不是超集（Not a Superset）</td><td>$$ \nsupseteq $$</td><td>\nsupseteq</td></tr><tr><td>真子集而不全等于（Proper Subset But Not Equivalent To）</td><td>$$ \subsetneqq $$</td><td>\subsetneqq</td></tr><tr><td>真超集而不全等于（Proper Superset But Not Equivalent To）</td><td>$$ \supsetneqq $$</td><td>\supsetneqq</td></tr><tr><td>超集而不全等于（Superset But Not Equivalent To）</td><td>$$ \supseteqq $$</td><td>\supseteqq</td></tr><tr><td>子集而不全等于（Subset But Not Equivalent To）</td><td>$$ \subseteqq $$</td><td>\subseteqq</td></tr><tr><td>真子集而不完全等于（Proper Subset But Not Equivalent To）</td><td>$$ \varsubsetneqq $$</td><td>\varsubsetneqq</td></tr><tr><td>真超集而不完全等于（Proper Superset But Not Equivalent To）</td><td>$$ \varsupsetneqq $$</td><td>\varsupsetneqq</td></tr><tr><td>不是子集而不完全等于（Not a Subset But Not Equivalent To）</td><td>$$ \nsubseteqq $$</td><td>\nsubseteqq</td></tr><tr><td>不是超集而不完全等于（Not a Superset But Not Equivalent To）</td><td>$$ \nsupseteqq $$</td><td>\nsupseteqq</td></tr></tbody></table><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>合取</td><td>$$ \wedge \quad \land $$</td><td>\wedge or \land</td></tr><tr><td>折取</td><td>$$ \vee \quad \lor $$</td><td>\vee or \lor</td></tr><tr><td>否</td><td>$$ \neg $$</td><td>\neg</td></tr><tr><td>不等于</td><td>$$ \neq \quad \not&#x3D; $$</td><td>\neq or \not&#x3D;</td></tr><tr><td>约等于</td><td>$$ \approx $$</td><td>\approx</td></tr><tr><td>等于</td><td>$$ &#x3D; $$</td><td>&#x3D;</td></tr><tr><td>大于</td><td>$$ &gt; $$</td><td>&gt;</td></tr><tr><td>小于</td><td>$$ &lt; $$</td><td>&lt;</td></tr><tr><td>大于等于</td><td>$$ \geq $$</td><td>\geq</td></tr><tr><td>小于等于</td><td>$$ \leq $$</td><td>\leq</td></tr><tr><td>不大于等于</td><td>$$ \ngeq \quad \not\geq $$</td><td>\ngeq or \not\geq</td></tr><tr><td>不小于等于</td><td>$$ \nleq \quad \not\leq $$</td><td>\nleq or \not\leq</td></tr><tr><td>恒定等于</td><td>$$ \equiv $$</td><td>\equiv</td></tr><tr><td>不小于</td><td>$$ \not&lt; \quad \nless $$</td><td>\not&lt; or \nless</td></tr><tr><td>不大于</td><td>$$ \not&gt; \quad \ngtr $$</td><td>\not&gt; or \ngtr</td></tr><tr><td>小于而不等于（Less Than But Not Equal To）</td><td>$$ \lneq $$</td><td>\lneq</td></tr><tr><td>大于而不等于（Greater Than But Not Equal To）</td><td>$$ \gneq $$</td><td>\gneq</td></tr><tr><td>不小于等于（Not Less Than or Equal To）</td><td>$$ \nleqslant $$</td><td>\nleqslant</td></tr><tr><td>不大于等于（Not Greater Than or Equal To）</td><td>$$ \ngeqslant $$</td><td>\ngeqslant</td></tr><tr><td>小于而不全等于（Less Than But Not Equivalent To）</td><td>$$ \lneqq $$</td><td>\lneqq</td></tr><tr><td>大于而不全等于（Greater Than But Not Equivalent To）</td><td>$$ \gneqq $$</td><td>\gneqq</td></tr><tr><td>小于而不等于（Vertical Bar Not Equal To）</td><td>$$ \lvertneqq $$</td><td>\lvertneqq</td></tr><tr><td>大于而不等于（Vertical Bar Greater Than Not Equal To）</td><td>$$ \gvertneqq $$</td><td>\gvertneqq</td></tr><tr><td>不小于而不全等于（Not Less Than But Not Equivalent To）</td><td>$$ \nleqq $$</td><td>\nleqq</td></tr><tr><td>不大于而不全等于（Not Greater Than But Not Equivalent To）</td><td>$$ \ngeqq $$</td><td>\ngeqq</td></tr><tr><td>小于而不相似于（Less Not Similar）</td><td>$$ \lnsim $$</td><td>\lnsim</td></tr><tr><td>大于而不相似于（Greater Not Similar）</td><td>$$ \gnsim $$</td><td>\gnsim</td></tr><tr><td>小于而不近似于（Less Not Approximately）</td><td>$$ \lnapprox $$</td><td>\lnapprox</td></tr><tr><td>大于而不近似于（Greater Not Approximately）</td><td>$$ \gnapprox $$</td><td>\gnapprox</td></tr><tr><td>不被前驱（Not Precedes）</td><td>$$ \nprec $$</td><td>\nprec</td></tr><tr><td>不被后继（Not Succeeds）</td><td>$$ \nsucc $$</td><td>\nsucc</td></tr><tr><td>不被前驱等于（Not Precedes or Equal To）</td><td>$$ \npreceq $$</td><td>\npreceq</td></tr><tr><td>不被后继等于（Not Succeeds or Equal To）</td><td>$$ \nsucceq $$</td><td>\nsucceq</td></tr><tr><td>前驱不全等于（Precedes But Not Equivalent To）</td><td>$$ \precneqq $$</td><td>\precneqq</td></tr><tr><td>后继不全等于（Succeeds But Not Equivalent To）</td><td>$$ \succneqq $$</td><td>\succneqq</td></tr><tr><td>前驱不相似于（Precedes Not Similar）</td><td>$$ \precnsim $$</td><td>\precnsim</td></tr><tr><td>后继不相似于（Succeeds Not Similar）</td><td>$$ \succnsim $$</td><td>\succnsim</td></tr><tr><td>前驱不近似于（Precedes Not Approximately）</td><td>$$ \precnapprox $$</td><td>\precnapprox</td></tr><tr><td>后继不近似于（Succeeds Not Approximately）</td><td>$$ \succnapprox $$</td><td>\succnapprox</td></tr><tr><td>不相似于（Not Similar To）</td><td>$$ \nsim $$</td><td>\nsim</td></tr><tr><td>不全等于（Not Congruent）</td><td>$$ \ncong $$</td><td>\ncong</td></tr><tr><td>不垂直推导（Not Right Tack）</td><td>$$ \nvdash $$</td><td>\nvdash</td></tr><tr><td>不垂直双推导（Not Right Double Tack）</td><td>$$ \nvDash $$</td><td>\nvDash</td></tr><tr><td>不垂直三推导（Not Right Tack Above）</td><td>$$ \nVdash $$</td><td>\nVdash</td></tr><tr><td>不垂直三双推导（Not Right Double Tack Above）</td><td>$$ \nVDash $$</td><td>\nVDash</td></tr><tr><td>双小于号</td><td>$$ \ll $$</td><td>\ll</td></tr><tr><td>双大于号</td><td>$$ \gg $$</td><td>\gg</td></tr><tr><td>点等号</td><td>$$ \doteq $$</td><td>\doteq</td></tr><tr><td>小于号</td><td>$$ \prec $$</td><td>\prec</td></tr><tr><td>大于号</td><td>$$ \succ $$</td><td>\succ</td></tr><tr><td>小于等于号</td><td>$$ \preceq $$</td><td>\preceq</td></tr><tr><td>大于等于号</td><td>$$ \succeq $$</td><td>\succeq</td></tr><tr><td>相似或等于号</td><td>$$ \simeq $$</td><td>\simeq</td></tr><tr><td>同余</td><td>$$ \cong $$</td><td>\cong</td></tr><tr><td>方框内小于号</td><td>$$ \sqsubset $$</td><td>\sqsubset</td></tr><tr><td>方框内大于号</td><td>$$ \sqsupset $$</td><td>\sqsupset</td></tr><tr><td>Join 或 Bowtie</td><td>$$ \Join \quad \bowtie $$</td><td>\Join or \bowtie</td></tr><tr><td>方框内小于等于号</td><td>$$ \sqsubseteq $$</td><td>\sqsubseteq</td></tr><tr><td>方框内大于等于号</td><td>$$ \sqsupseteq $$</td><td>\sqsupseteq</td></tr><tr><td>包含于</td><td>$$ \ni $$</td><td>\ni</td></tr><tr><td>正比于</td><td>$$ \propto $$</td><td>\propto</td></tr><tr><td>垂直推导</td><td>$$ \vdash $$</td><td>\vdash</td></tr><tr><td>推导垂直</td><td>$$ \dashv $$</td><td>\dashv</td></tr><tr><td>模型关系</td><td>$$ \models $$</td><td>\models</td></tr><tr><td>近似于</td><td>$$ \asymp $$</td><td>\asymp</td></tr></tbody></table><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>平均数</td><td>$$ \overline{xyz} $$</td><td>\overline{xyz}</td></tr><tr><td>开方</td><td>$$ \sqrt{x} $$</td><td>\sqrt{x}</td></tr><tr><td>高阶开方</td><td>$$ \sqrt[x]{y} $$</td><td>\sqrt[x]{y}</td></tr><tr><td>极限</td><td>$$ \lim $$</td><td>\lim</td></tr><tr><td>求和</td><td>$$ \sum $$</td><td>\sum</td></tr><tr><td>积分</td><td>$$ \int $$</td><td>\int</td></tr><tr><td>微分</td><td>$$ \partial $$</td><td>\partial</td></tr><tr><td>求积</td><td>$$ \prod $$</td><td>\prod</td></tr><tr><td>二重积分</td><td>$$ \iint $$</td><td>\iint</td></tr><tr><td>多重积分</td><td>$$ \idotsint $$</td><td>\idotsint</td></tr><tr><td>曲线积分</td><td>$$ \oint $$</td><td>\oint</td></tr></tbody></table><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>加</td><td>$$ + $$</td><td>+</td></tr><tr><td>减</td><td>$$ - $$</td><td>-</td></tr><tr><td>加减</td><td>$$ \pm $$</td><td>\pm</td></tr><tr><td>减加</td><td>$$ \mp $$</td><td>\mp</td></tr><tr><td>乘法</td><td>$$ \times $$</td><td>\times</td></tr><tr><td>点乘</td><td>$$ \cdot $$</td><td>\cdot</td></tr><tr><td>星乘</td><td>$$ \ast $$</td><td>\ast</td></tr><tr><td>除法</td><td>$$ \div $$</td><td>\div</td></tr><tr><td>斜法</td><td>$$ &#x2F; $$</td><td>&#x2F;</td></tr><tr><td>分式</td><td>$$ \frac{x}{y} $$</td><td>\frac{x}{y}</td></tr><tr><td>分式</td><td>$$ {x}\over{y} $$</td><td>{x}\over{y}</td></tr><tr><td>绝对值</td><td>$$ \lvert x \lvert \quad | x | $$</td><td>\lvert x \lvert or |x|</td></tr><tr><td>不是整除（Not Divides）</td><td>$$ \nmid $$</td><td>\nmid</td></tr><tr><td>不是短整除</td><td>$$ \nshortmid $$</td><td>\nshortmid</td></tr></tbody></table><h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>非左半封装（Unrestricted Left Half Bracket）</td><td>$$ \unlhd $$</td><td>\unlhd</td></tr><tr><td>非右半封装（Unrestricted Right Half Bracket）</td><td>$$ \unrhd $$</td><td>\unrhd</td></tr><tr><td>方块并集（Square Cup）</td><td>$$ \sqcup $$</td><td>\sqcup</td></tr><tr><td>方块交集（Square Cap）</td><td>$$ \sqcap $$</td><td>\sqcap</td></tr><tr><td>直和（Direct Sum）</td><td>$$ \oplus $$</td><td>\oplus</td></tr><tr><td>直差（Direct Minus）</td><td>$$ \ominus $$</td><td>\ominus</td></tr><tr><td>多重并集（Multiset Union）</td><td>$$ \uplus $$</td><td>\uplus</td></tr><tr><td>混合（Amalgamation）</td><td>$$ \amalg $$</td><td>\amalg</td></tr><tr><td>左半封装（Left Half Bracket）</td><td>$$ \lhd $$</td><td>\lhd</td></tr><tr><td>右半封装（Right Half Bracket）</td><td>$$ \rhd $$</td><td>\rhd</td></tr><tr><td>点加号</td><td>$$ \dotplus $$</td><td>\dotplus</td></tr><tr><td>中点</td><td>$$ \centerdot $$</td><td>\centerdot</td></tr><tr><td>左乘号</td><td>$$ \ltimes $$</td><td>\ltimes</td></tr><tr><td>右乘号</td><td>$$ \rtimes $$</td><td>\rtimes</td></tr><tr><td>小集合差</td><td>$$ \smallsetminus $$</td><td>\smallsetminus</td></tr><tr><td>双并集</td><td>$$ \doublecup $$</td><td>\doublecup</td></tr><tr><td>双交集</td><td>$$ \doublecap $$</td><td>\doublecap</td></tr><tr><td>右三次乘号</td><td>$$ \rightthreetimes $$</td><td>\rightthreetimes</td></tr><tr><td>左三次乘号</td><td>$$ \leftthreetimes $$</td><td>\leftthreetimes</td></tr></tbody></table><h2 id="巨运算符"><a href="#巨运算符" class="headerlink" title="巨运算符"></a>巨运算符</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>并集（Union）</td><td>$$ \bigcup $$</td><td>\bigcup</td></tr><tr><td>交集（Intersection）</td><td>$$ \bigcap $$</td><td>\bigcap</td></tr><tr><td>逻辑或（Logical Or）</td><td>$$ \bigvee $$</td><td>\bigvee</td></tr><tr><td>逻辑与（Logical And）</td><td>$$ \bigwedge $$</td><td>\bigwedge</td></tr><tr><td>方块并集（Square Cup）</td><td>$$ \bigsqcup $$</td><td>\bigsqcup</td></tr><tr><td>多重并集（Multiset Union）</td><td>$$ \biguplus $$</td><td>\biguplus</td></tr><tr><td>圆点运算（Circle Dot）</td><td>$$ \bigodot $$</td><td>\bigodot</td></tr><tr><td>直和（Direct Sum）</td><td>$$ \bigoplus $$</td><td>\bigoplus</td></tr><tr><td>张量积（Tensor Product）</td><td>$$ \bigotimes $$</td><td>\bigotimes</td></tr></tbody></table><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>短左箭头（Short Left Arrow）</td><td>$$ \dashleftarrow $$</td><td>\dashleftarrow</td></tr><tr><td>短右箭头（Short Right Arrow）</td><td>$$ \dashrightarrow $$</td><td>\dashrightarrow</td></tr><tr><td>左左箭头（Leftwards Double Arrow Over Rightwards Double Arrow）</td><td>$$ \leftleftarrows $$</td><td>\leftleftarrows</td></tr><tr><td>右右箭头（Rightwards Double Arrow Over Leftwards Double Arrow）</td><td>$$ \rightrightarrows $$</td><td>\rightrightarrows</td></tr><tr><td>左左箭头（Leftwards Triple Arrow）</td><td>$$ \Lleftarrow $$</td><td>\Lleftarrow</td></tr><tr><td>右右箭头（Rightwards Triple Arrow）</td><td>$$ \Rrightarrow $$</td><td>\Rrightarrow</td></tr><tr><td>双头左箭头（Leftwards Double Arrow With Double Vertical Stroke）</td><td>$$ \twoheadleftarrow $$</td><td>\twoheadleftarrow</td></tr><tr><td>双头右箭头（Rightwards Double Arrow With Double Vertical Stroke）</td><td>$$ \twoheadrightarrow $$</td><td>\twoheadrightarrow</td></tr><tr><td>尾部左箭头（Leftwards Arrow With Tail）</td><td>$$ \leftarrowtail $$</td><td>\leftarrowtail</td></tr><tr><td>尾部右箭头（Rightwards Arrow With Tail）</td><td>$$ \rightarrowtail $$</td><td>\rightarrowtail</td></tr><tr><td>左斜箭头（Upwards Arrow With Tip Leftwards）</td><td>$$ \Lsh $$</td><td>\Lsh</td></tr><tr><td>右斜箭头（Upwards Arrow With Tip Rightwards）</td><td>$$ \Rsh $$</td><td>\Rsh</td></tr><tr><td>左循环箭头（Leftwards Open-Headed Arrow With Circled Tail）</td><td>$$ \looparrowleft $$</td><td>\looparrowleft</td></tr><tr><td>右循环箭头（Rightwards Open-Headed Arrow With Circled Tail）</td><td>$$ \looparrowright $$</td><td>\looparrowright</td></tr><tr><td>左弯曲箭头（Leftwards Arrow With Curved Tail）</td><td>$$ \curvearrowleft $$</td><td>\curvearrowleft</td></tr><tr><td>右弯曲箭头（Rightwards Arrow With Curved Tail）</td><td>$$ \curvearrowright $$</td><td>\curvearrowright</td></tr><tr><td>左圆形箭头（Anticlockwise Open Circle Arrow）</td><td>$$ \circlearrowleft $$</td><td>\circlearrowleft</td></tr><tr><td>右圆形箭头（Clockwise Open Circle Arrow）</td><td>$$ \circlearrowright $$</td><td>\circlearrowright</td></tr><tr><td>多重映射（Multimap）</td><td>$$ \multimap $$</td><td>\multimap</td></tr><tr><td>上上箭头（Upwards Paired Arrows）</td><td>$$ \upuparrows $$</td><td>\upuparrows</td></tr><tr><td>下下箭头（Downwards Paired Arrows）</td><td>$$ \downdownarrows $$</td><td>\downdownarrows</td></tr><tr><td>左上弯钩箭头（Upwards Harpoon With Barb Leftwards）</td><td>$$ \upharpoonleft $$</td><td>\upharpoonleft</td></tr><tr><td>右上弯钩箭头（Upwards Harpoon With Barb Rightwards）</td><td>$$ \upharpoonright $$</td><td>\upharpoonright</td></tr><tr><td>右下弯钩箭头（Downwards Harpoon With Barb</td><td>$$ \downharpoonright $$</td><td>\downharpoonright</td></tr><tr><td>左下弯钩箭头（Downwards Harpoon With Barb Leftwards）</td><td>$$ \downharpoonleft $$</td><td>\downharpoonleft</td></tr><tr><td>右波浪箭头（Rightwards Squiggle Arrow）</td><td>$$ \rightsquigarrow \quad \leadsto $$</td><td>\rightsquigarrow or \leadsto</td></tr><tr><td>左右波浪箭头（Left Right Squiggle Arrow）</td><td>$$ \leftrightsquigarrow $$</td><td>\leftrightsquigarrow</td></tr><tr><td>向上箭头（Upwards Arrow）</td><td>$$ \uparrow $$</td><td>\uparrow</td></tr><tr><td>向下箭头（Downwards Arrow）</td><td>$$ \downarrow $$</td><td>\downarrow</td></tr><tr><td>向上双箭头（Upwards Double Arrow）</td><td>$$ \Uparrow $$</td><td>\Uparrow</td></tr><tr><td>向下双箭头（Downwards Double Arrow）</td><td>$$ \Downarrow $$</td><td>\Downarrow</td></tr><tr><td>上下箭头（Up Down Arrow）</td><td>$$ \updownarrow $$</td><td>\updownarrow</td></tr><tr><td>上下双箭头（Up Down Double Arrow）</td><td>$$ \Updownarrow $$</td><td>\Updownarrow</td></tr><tr><td>不是左箭头（Not Left Arrow）</td><td>$$ \nleftarrow $$</td><td>\nleftarrow</td></tr><tr><td>不是右箭头（Not Right Arrow）</td><td>$$ \nrightarrow $$</td><td>\nrightarrow</td></tr><tr><td>不是左双箭头（Not Left Double Arrow）</td><td>$$ \nLeftarrow $$</td><td>\nLeftarrow</td></tr><tr><td>不是右双箭头（Not Right Double Arrow）</td><td>$$ \nRightarrow $$</td><td>\nRightarrow</td></tr><tr><td>不是左右双箭头（Not Left Right Double Arrow）</td><td>$$ \nLeftrightarrow $$</td><td>\nLeftrightarrow</td></tr><tr><td>不是双向箭头（Not Left Right Arrow）</td><td>$$ \nleftrightarrow $$</td><td>\nleftrightarrow</td></tr><tr><td>左右双向箭头（Left Right Double Arrow）</td><td>$$ \Leftrightarrow $$</td><td>\Leftrightarrow</td></tr><tr><td>左右双向箭头，简写形式（Left Right Arrow）</td><td>$$ \leftrightarrow $$</td><td>\leftrightarrow</td></tr><tr><td>映射</td><td>$$ \mapsto $$</td><td>\mapsto</td></tr><tr><td>长映射</td><td>$$ \longmapsto $$</td><td>\longmapsto</td></tr><tr><td>左钩头箭头</td><td>$$ \hookleftarrow $$</td><td>\hookleftarrow</td></tr><tr><td>右钩头箭头</td><td>$$ \hookrightarrow $$</td><td>\hookrightarrow</td></tr><tr><td>左上弯箭头</td><td>$$ \leftharpoonup $$</td><td>\leftharpoonup</td></tr><tr><td>右上弯箭头</td><td>$$ \rightharpoonup $$</td><td>\rightharpoonup</td></tr><tr><td>左下弯箭头</td><td>$$ \leftharpoondown $$</td><td>\leftharpoondown</td></tr><tr><td>右下弯箭头</td><td>$$ \rightharpoondown $$</td><td>\rightharpoondown</td></tr><tr><td>右左双箭头</td><td>$$ \rightleftharpoons $$</td><td>\rightleftharpoons</td></tr><tr><td>如果且仅如果</td><td>$$ \iff $$</td><td>\iff</td></tr><tr><td>向右上角箭头</td><td>$$ \nearrow $$</td><td>\nearrow</td></tr><tr><td>向右下角箭头</td><td>$$ \searrow $$</td><td>\searrow</td></tr><tr><td>向左下角箭头</td><td>$$ \swarrow $$</td><td>\swarrow</td></tr><tr><td>向左上角箭头</td><td>$$ \nwarrow $$</td><td>\nwarrow</td></tr></tbody></table><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>左括号（Left Parenthesis）</td><td>$$ ( $$</td><td>(</td></tr><tr><td>右括号（Right Parenthesis）</td><td>$$ ) $$</td><td>)</td></tr><tr><td>自适应大小的括号（Adaptive-sized Parentheses）</td><td>$$ \left( \right) $$</td><td>\left( \right)</td></tr><tr><td>左方括号（Left Square Bracket）</td><td>$$ [ \quad \lbrack $$</td><td>[ or \lbrack</td></tr><tr><td>右方括号（Right Square Bracket）</td><td>$$ ] \quad \rbrack $$</td><td>] or \rbrack</td></tr><tr><td>自适应大小的方括号（Adaptive-sized Square Brackets）</td><td>$$ \left[ \right] $$</td><td>\left[ \right]</td></tr><tr><td>左花括号（Left Curly Brace）</td><td>$$ \{ \quad \lbrace $$</td><td>\\{ or \lbrace</td></tr><tr><td>右花括号（Right Curly Brace）</td><td>$$ \} \quad \rbrace $$</td><td>\\} or \rbrace</td></tr><tr><td>左尖括号（Left Angle Bracket）</td><td>$$ \langle $$</td><td>\lang or \langle</td></tr><tr><td>右尖括号（Right Angle Bracket）</td><td>$$ \rangle $$</td><td>\rang or \rangle</td></tr><tr><td>斜杠（Forward Slash）</td><td>$$ &#x2F; $$</td><td>&#x2F;</td></tr><tr><td>反斜杠（Backslash）</td><td>$$ \backslash $$</td><td>\backslash</td></tr><tr><td>左上角括号（Left Ceiling Bracket）</td><td>$$ \lceil $$</td><td>\lceil</td></tr><tr><td>右上角括号（Right Ceiling Bracket）</td><td>$$ \rceil $$</td><td>\rceil</td></tr><tr><td>左下角括号（Left Floor Bracket）</td><td>$$ \lfloor $$</td><td>\lfloor</td></tr><tr><td>右下角括号（Right Floor Bracket）</td><td>$$ \rfloor $$</td><td>\rfloor</td></tr><tr><td>左大括号（Left Large Parenthesis）</td><td>$$ \lgroup $$</td><td>\lgroup</td></tr><tr><td>右大括号（Right Large Parenthesis）</td><td>$$ \rgroup $$</td><td>\rgroup</td></tr><tr><td>左大括号（Left Moustache）</td><td>$$ \lmoustache $$</td><td>\lmoustache</td></tr><tr><td>右大括号（Right Moustache）</td><td>$$ \rmoustache $$</td><td>\rmoustache</td></tr><tr><td>单竖线（Vertical Line）</td><td>$$ \arrowvert $$</td><td>\arrowvert</td></tr><tr><td>双竖线（Double Vertical Line）</td><td>$$ \Arrowvert $$</td><td>\Arrowvert</td></tr><tr><td>大括号竖线（Brace Vertical Line）</td><td>$$ \bracevert $$</td><td>\bracevert</td></tr><tr><td>左上角括号（Upper Left Corner）</td><td>$$ \ulcorner $$</td><td>\ulcorner</td></tr><tr><td>右上角括号（Upper Right Corner）</td><td>$$ \urcorner $$</td><td>\urcorner</td></tr><tr><td>左下角括号（Lower Left Corner）</td><td>$$ \llcorner $$</td><td>\llcorner</td></tr><tr><td>右下角括号（Lower Right Corner）</td><td>$$ \lrcorner $$</td><td>\lrcorner</td></tr></tbody></table><h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>不平行</td><td>$$ \nparallel $$</td><td>\nparallel</td></tr><tr><td>不是短平行（Not Short Parallel）</td><td>$$ \nshortparallel $$</td><td>\nshortparallel</td></tr></tbody></table><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>方括号包围的矩阵</td><td>$$ \begin{bmatrix} 0 &amp; -1 \\ 1 &amp; 0 \end{bmatrix} $$</td><td><code>\begin&#123;bmatrix&#125; 0 &amp; -1 \\ 1 &amp; 0 \end&#123;bmatrix&#125;</code></td></tr><tr><td>无括号包围的矩阵</td><td>$$ \begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix} $$</td><td><code>\begin&#123;matrix&#125; 0 &amp; 1 \\ 1 &amp; 0 \end&#123;matrix&#125;</code></td></tr><tr><td>圆括号包围的矩阵</td><td>$$ \begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix} $$</td><td><code>\begin&#123;pmatrix&#125; 0 &amp; -i \\ i &amp; 0 \end&#123;pmatrix&#125;</code></td></tr><tr><td>大括号包围的矩阵</td><td>$$ \begin{Bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{Bmatrix} $$</td><td><code>\begin&#123;Bmatrix&#125; 1 &amp; 0 \\ 0 &amp; -1 \end&#123;Bmatrix&#125;</code></td></tr><tr><td>单竖线的行列式</td><td>$$ \begin{vmatrix} a &amp; b \\ c &amp; d \end{vmatrix} $$</td><td><code>\begin&#123;vmatrix&#125; a &amp; b \\ c &amp; d \end&#123;vmatrix&#125;</code></td></tr><tr><td>双竖线的行列式</td><td>$$ \begin{Vmatrix} i &amp; 0 \\ 0 &amp; -i \end{Vmatrix} $$</td><td><code>\begin&#123;Vmatrix&#125; i &amp; 0 \\ 0 &amp; -i \end&#123;Vmatrix&#125;</code></td></tr></tbody></table><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>每个</td><td>$$ \forall $$</td><td>\forall</td></tr><tr><td>无穷</td><td>$$ \infty $$</td><td>\infty</td></tr><tr><td>存在</td><td>$$ \exists $$</td><td>\exists</td></tr><tr><td>梯度</td><td>$$ \nabla $$</td><td>\nabla</td></tr><tr><td>垂直</td><td>$$ \bot \quad \perp $$</td><td>\bot or \perp</td></tr><tr><td>角</td><td>$$ \angle $$</td><td>\angle</td></tr><tr><td>因为</td><td>$$ \because $$</td><td>\because</td></tr><tr><td>所以</td><td>$$ \therefore $$</td><td>\therefore</td></tr><tr><td>空格</td><td>$$ \quad $$</td><td>\quad</td></tr><tr><td>上划线</td><td>$$ \bar{x} $$</td><td>\bar{x}</td></tr><tr><td>波浪线</td><td>$$ \sim $$</td><td>\sim</td></tr><tr><td>横向省略号</td><td>$$ \dots $$</td><td>\dots</td></tr><tr><td>横向的居中省略号</td><td>$$ \cdots $$</td><td>\cdots</td></tr><tr><td>竖向省略号</td><td>$$ \vdots $$</td><td>\vdots</td></tr><tr><td>对角线省略号</td><td>$$ \ddots $$</td><td>\ddots</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>名称</th><th>符号</th><th>LaTeX</th></tr></thead><tbody><tr><td>左三角（Left Triangle）</td><td>$$ \triangleleft $$</td><td>\triangleleft</td></tr><tr><td>右三角（Right Triangle）</td><td>$$ \triangleright $$</td><td>\triangleright</td></tr><tr><td>星号（Star）</td><td>$$ \star $$</td><td>\star</td></tr><tr><td>波浪符号（Wreath Product）</td><td>$$ \wr $$</td><td>\wr</td></tr><tr><td>双宝剑（Double Dagger）</td><td>$$ \ddagger $$</td><td>\ddagger</td></tr><tr><td>宝剑（Dagger）</td><td>$$ \dagger $$</td><td>\dagger</td></tr><tr><td>圆点（Bullet）</td><td>$$ \bullet $$</td><td>\bullet</td></tr><tr><td>菱形（Diamond）</td><td>$$ \diamond $$</td><td>\diamond</td></tr><tr><td>斜线圆圈（Slashed Circle）</td><td>$$ \oslash $$</td><td>\oslash</td></tr><tr><td>约化普朗克常数（Reduced Planck Constant）</td><td>$$ \hbar $$</td><td>\hbar</td></tr><tr><td>约化普朗克常数（Alternative form of Reduced Planck Constant）</td><td>$$ \hslash $$</td><td>\hslash</td></tr><tr><td>域（Blackboard Bold k）</td><td>$$ \Bbbk $$</td><td>\Bbbk</td></tr><tr><td>方块（Open Box）</td><td>$$ \square $$</td><td>\square</td></tr><tr><td>实心方块（Filled Box）</td><td>$$ \blacksquare $$</td><td>\blacksquare</td></tr><tr><td>导数算子</td><td>$$ \circledS $$</td><td>\circledS</td></tr><tr><td>小三角形（Open Up Pointing Triangle）</td><td>$$ \vartriangle $$</td><td>\vartriangle</td></tr><tr><td>实心小三角形（Filled Up Pointing Triangle）</td><td>$$ \blacktriangle $$</td><td>\blacktriangle</td></tr><tr><td>补集符号（Complement）</td><td>$$ \complement $$</td><td>\complement</td></tr><tr><td>小倒三角形（Open Down Pointing Triangle）</td><td>$$ \triangledown $$</td><td>\triangledown</td></tr><tr><td>实心小倒三角形（Filled Down Pointing Triangle）</td><td>$$ \blacktriangledown $$</td><td>\blacktriangledown</td></tr><tr><td>四叶草符号（Game）</td><td>$$ \Game $$</td><td>\Game</td></tr><tr><td>菱形（Lozenge</td><td>$$ \lozenge $$</td><td>\lozenge</td></tr><tr><td>实心菱形（Filled Lozenge）</td><td>$$ \blacklozenge $$</td><td>\blacklozenge</td></tr><tr><td>大星号（Big Star）</td><td>$$ \bigstar $$</td><td>\bigstar</td></tr><tr><td>脚长小写字母 L</td><td>$$ \ell $$</td><td>\ell</td></tr><tr><td>斜向下箭头（Down Right Diagonal Ellipsis）</td><td>$$ \diagdown $$</td><td>\diagdown</td></tr><tr><td>测量角度符号（Measured Angle）</td><td>$$ \measuredangle $$</td><td>\measuredangle</td></tr><tr><td>斜向上箭头（Up Right Diagonal Ellipsis）</td><td>$$ \diagup $$</td><td>\diagup</td></tr><tr><td>带反撇号的撇号（Backwards Prime）</td><td>$$ \backprime $$</td><td>\backprime</td></tr><tr><td>不存在符号（There Does Not Exist）</td><td>$$ \nexists $$</td><td>\nexists</td></tr><tr><td>反转大写 F（Inverted Capital F）</td><td>$$ \Finv $$</td><td>\Finv</td></tr><tr><td>空集符号（Empty Set）</td><td>$$ \varnothing $$</td><td>\varnothing</td></tr><tr><td>埃塞特字符，表示一种语音学符号（Eth）</td><td>$$ \eth $$</td><td>\eth</td></tr><tr><td>球面角符号（Spherical Angle）</td><td>$$ \sphericalangle $$</td><td>\sphericalangle</td></tr><tr><td>电导率的单位（Mho, Inverted Ohm）</td><td>$$ \mho $$</td><td>\mho</td></tr><tr><td>虚数单位 “i”</td><td>$$ \imath $$</td><td>\imath</td></tr><tr><td>虚数单位 “j”</td><td>$$ \jmath $$</td><td>\jmath</td></tr><tr><td>实数集（\Re）</td><td>$$ \Re $$</td><td>\Re</td></tr><tr><td>虚数集（\Im）</td><td>$$ \Im $$</td><td>\Im</td></tr><tr><td></td><td>$$ \aleph $$</td><td>\aleph</td></tr><tr><td></td><td>$$ \wp $$</td><td>\wp</td></tr><tr><td></td><td>$$ \top $$</td><td>\top</td></tr><tr><td>平方根</td><td>$$ \surd $$</td><td>\surd</td></tr><tr><td>红心</td><td>$$ \heartsuit $$</td><td>\heartsuit</td></tr><tr><td>梅花</td><td>$$ \clubsuit $$</td><td>\clubsuit</td></tr><tr><td>黑桃</td><td>$$ \spadesuit $$</td><td>\spadesuit</td></tr><tr><td>降调</td><td>$$ \flat $$</td><td>\flat</td></tr><tr><td>还原到自然音</td><td>$$ \natural $$</td><td>\natural</td></tr><tr><td>升调</td><td>$$ \sharp $$</td><td>\sharp</td></tr><tr><td>方片</td><td>$$ \diamondsuit $$</td><td>\diamondsuit</td></tr><tr><td>节（section）</td><td>$$ \S $$</td><td>\S</td></tr><tr><td>百分号</td><td>$$ \% $$</td><td>%</td></tr><tr><td>音调</td><td>$$ \\P $$</td><td>\P</td></tr><tr><td>笑脸</td><td>$$ \smile $$</td><td>\smile</td></tr><tr><td>皱眉</td><td>$$ \frown $$</td><td>\frown</td></tr><tr><td>卷曲的 V 形</td><td>$$ \curlyvee $$</td><td>\curlyvee</td></tr><tr><td>卷曲的 W 形</td><td>$$ \curlywedge $$</td><td>\curlywedge</td></tr><tr><td>或条</td><td>$$ \veebar $$</td><td>\veebar</td></tr><tr><td>杠楔形</td><td>$$ \barwedge $$</td><td>\barwedge</td></tr><tr><td>双杠楔形</td><td>$$ \doublebarwedge $$</td><td>\doublebarwedge</td></tr><tr><td>方框加号</td><td>$$ \boxplus $$</td><td>\boxplus</td></tr><tr><td>方框减号</td><td>$$ \boxminus $$</td><td>\boxminus</td></tr><tr><td>带圆减号</td><td>$$ \circleddash $$</td><td>\circleddash</td></tr><tr><td>方框乘号</td><td>$$ \boxtimes $$</td><td>\boxtimes</td></tr><tr><td>方框点号</td><td>$$ \boxdot $$</td><td>\boxdot</td></tr><tr><td>带圈的圆圈</td><td>$$ \circledcirc $$</td><td>\circledcirc</td></tr><tr><td>插入符号</td><td>$$ \intercal $$</td><td>\intercal</td></tr><tr><td>带圆星号</td><td>$$ \circledast $$</td><td>\circledast</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Regression算法简析</title>
      <link href="/2023/08/03/Regression%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/08/03/Regression%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Regression算法简析"><a href="#Regression算法简析" class="headerlink" title="Regression算法简析"></a>Regression算法简析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>回归（Regression）是机器学习中的一种重要算法和任务，其主要目标是预测连续数值型的输出（或称为目标变量）在输入特征（或称为自变量）的基础上。回归可以被认为是一种建模技术，它用于分析变量之间的关系并预测未来的趋势。</p><p>在回归中，我们假设输入特征和输出之间存在某种函数关系，回归算法的目标就是找到这个函数，以便能够在新的输入数据上进行预测。这个函数通常被称为回归模型，它可以用来预测连续的输出值。</p><p>回归问题可以分为以下几种类型：</p><ol><li><p><strong>线性回归（Linear Regression）：</strong> 这是最简单的回归方法之一。它假设输入特征和输出之间存在线性关系。线性回归试图找到最佳拟合的直线（或超平面），使得输入特征和输出的拟合误差最小。</p></li><li><p><strong>多项式回归（Polynomial Regression）：</strong> 在某些情况下，线性模型无法准确地捕捉输入和输出之间的复杂关系。多项式回归通过引入多项式项来扩展线性模型，从而更好地拟合数据。</p></li><li><p><strong>岭回归（Ridge Regression）和Lasso回归（Lasso Regression）：</strong> 这些是正则化的回归方法，用于控制模型的复杂度，防止过拟合。它们通过添加正则化项来限制模型参数的大小，从而在拟合数据时更加稳定。</p></li><li><p><strong>支持向量回归（Support Vector Regression，SVR）：</strong> 类似于支持向量机（SVM），SVR通过在输入空间中找到一个“边界带”来预测输出。它着重于在允许一定误差的情况下拟合数据。</p></li><li><p><strong>决策树回归（Decision Tree Regression）：</strong> 这种方法使用决策树来建立输入特征和输出之间的映射关系。它将输入空间划分成不同的区域，每个区域对应一个输出值。</p></li><li><p><strong>随机森林回归（Random Forest Regression）：</strong> 随机森林是基于决策树的集成方法，它通过组合多个决策树来改善预测性能，并减少过拟合风险。</p></li><li><p><strong>神经网络回归（Neural Network Regression）：</strong> 借助深度神经网络，神经网络回归能够建模复杂的非线性关系。它适用于更大规模和更复杂的数据集。</p></li></ol><p>回归问题的评估通常使用各种性能指标，如均方误差（Mean Squared Error）、平均绝对误差（Mean Absolute Error）、决定系数（Coefficient of Determination，R-squared）等来衡量模型的预测性能。</p><div class="note info"><p>逻辑回归虽然名字中包含“回归”，但实际上它是一种分类算法，而不是回归算法。逻辑回归用于解决二分类问题，即将输入特征映射到一个概率值，表示属于某个类别的可能性，然后根据阈值来进行分类决策。</p></div><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>回归在许多不同领域都有广泛的应用，它主要用于预测和建模连续数值型的输出变量。</p><ol><li><p><strong>经济学和金融：</strong> 回归可用于预测股票价格、商品价格、通货膨胀率等经济和金融指标，帮助投资决策和风险管理。</p></li><li><p><strong>房地产：</strong> 用于预测房价，考虑到各种房屋特征（如面积、地理位置、楼层等）对价格的影响。</p></li><li><p><strong>医学：</strong> 回归可以应用于疾病风险预测、药物剂量选择以及医疗成本预测等领域。</p></li><li><p><strong>自然科学：</strong> 在物理、化学、地理等领域，回归可用于分析实验数据、模拟物理过程，并帮助理解自然现象。</p></li><li><p><strong>社会科学：</strong> 用于预测人口统计数据、社会行为趋势、选民投票倾向等。</p></li><li><p><strong>工程和技术：</strong> 回归可用于预测产品寿命、材料强度、工程参数等，有助于设计和制造过程的优化。</p></li><li><p><strong>市场营销：</strong> 回归在市场营销中用于预测销售量、市场份额，以及了解广告投放和促销策略对销售的影响。</p></li><li><p><strong>环境科学：</strong> 回归可用于分析环境数据，例如预测气温变化、大气污染水平等。</p></li><li><p><strong>农业：</strong> 用于预测农作物产量、土壤质量，以及农业实践对收成的影响。</p></li><li><p><strong>教育：</strong> 在教育领域，回归可以用于预测学生的学术成绩，以及了解不同因素对学生表现的影响。</p></li><li><p><strong>运输与物流：</strong> 用于预测货运量、交通拥堵情况，以及运输成本的变化。</p></li></ol><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ol><li><p>矩阵求逆</p><p>矩阵求逆是一个在线性代数中非常重要的操作，它用于解决一系列问题，例如线性方程组的求解、线性变换的逆变换等。对于一个方阵（即行数和列数相等的矩阵），如果它是可逆的（也称为非奇异的），则可以求出它的逆矩阵。</p><p>设A是一个n阶方阵，如果存在一个n阶矩阵B，使得AB &#x3D; BA &#x3D; I（其中I是n阶单位矩阵），则称B是A的逆矩阵，记作A⁻¹。</p><p>然而，并不是所有矩阵都是可逆的。一个矩阵A可逆的条件是其行列式不为零，即det(A) ≠ 0。</p><p>对于一个可逆矩阵A，它的逆矩阵A⁻¹可以通过以下方式求解：</p><p>如果A是一个2x2矩阵：$$A &#x3D; \begin{bmatrix} a &amp; b \ c &amp; d \end{bmatrix}$$<br>则A的逆矩阵为：$$A^{-1} &#x3D; \frac{1}{ad - bc} \begin{bmatrix} d &amp; -b \ -c &amp; a \end{bmatrix}$$</p><p>对于更高维的矩阵，可以使用高斯-约旦消元法、LU分解等方法来求逆矩阵。另外，许多数值计算库和软件提供了求逆矩阵的函数，如Python的NumPy库中的<code>numpy.linalg.inv()</code>函数。</p><p>需要注意的是，矩阵求逆可能会涉及到数值稳定性的问题，特别是在计算机中使用有限的浮点数表示。对于大型或病态（ill-conditioned）的矩阵，求逆可能会导致数值不稳定，需要谨慎处理。</p><div class="note warning"><p>这里矩阵的mathjax格式不兼容，bc位置应该是换行显示的！</p></div></li><li><p>最小二乘法</p><p>最小二乘法（Least Squares Method）是一种用于拟合数据和估计模型参数的统计技术。它的主要思想是通过最小化实际观测值与模型预测值之间的误差的平方和，来找到最佳的模型参数。最小二乘法在回归分析、曲线拟合等问题中得到广泛应用。</p><p>在回归分析中，最小二乘法用于拟合一个线性模型，使模型的预测值与观测值之间的误差最小化。具体来说，对于一个包含 $m$ 个样本的数据集，每个样本包含一个或多个输入特征 $x$ 和一个输出 $y$。我们希望找到一个线性模型 $y &#x3D; f(x)$，其中 $f(x)$ 表示输入特征 $x$ 对应的模型预测值。然后，通过最小二乘法，我们寻找最佳的模型参数（回归系数）使得观测值与预测值之间的误差平方和最小。</p><p>数学上，对于一个线性模型 $y &#x3D; w_0 + w_1x_1 + w_2x_2 + \ldots + w_nx_n$，最小二乘法的目标是找到最佳的回归系数 $w_0, w_1, w_2, \ldots, w_n$，使得误差平方和最小，即最小化以下的损失函数：</p><p>$$\text{Loss} &#x3D; \sum_{i&#x3D;1}^{m} (y_i - \hat{y}_i)^2$$</p><p>其中，$y_i$ 是第 $i$ 个样本的实际输出，$\hat{y}_i$ 是模型预测的输出。</p><p>最小二乘法的求解过程通常涉及对损失函数进行求导，然后将导数设置为零，从而得到模型参数的解析解。这个解析解可以用于求解最佳的回归系数。</p><p>假设有以下变量：</p><ul><li>$x_{\text{test}}$: 待预测的样本点的特征向量</li><li>$x_{\text{arr}}$: 所有样本的特征数据矩阵，每一行是一个样本的特征向量</li><li>$y_{\text{arr}}$: 所有样本的目标变量向量</li><li>$\tau$: 带宽参数，控制权重的衰减速率</li><li>$w^{(i)}$: 样本点的权重矩阵，表示样本点与待预测点的距离所计算的权重</li><li>$\mathbf{x}_{\text{mat}}$: 样本特征数据矩阵</li><li>$\mathbf{y}_{\text{mat}}$: 样本目标变量矩阵</li><li>$\mathbf{x}_ {\text{tx}}$: 矩阵 $\mathbf{x}_{\text{mat}}$ 的转置与自身的乘积</li><li>$\mathbf{w}_{\text{mat}}$: 权重矩阵 $\mathbf{w}$，对角矩阵，由 $w^{(i)}$ 组成</li><li>$\mathbf{y}_{\text{hat}}$: 预测点估计值矩阵</li></ul><p>最小二乘法计算回归系数的数学公式为：<br>$$ \mathbf{w}_{\text{mat}} &#x3D; \text{diag}(w^{(1)}, w^{(2)}, \ldots, w^{(m)}) \quad \text{(对角矩阵)} $$</p><p>$$ \mathbf{x} _ {\text{tx}} &#x3D; \mathbf{x} _ {\text{mat}}^T \cdot \mathbf{x} _ {\text{mat}} $$</p><p>$$ \hat{\beta} &#x3D; (\mathbf{x}_ {\text{tx}} \cdot \mathbf{w}_ {\text{mat}} \cdot \mathbf{x}_ {\text{mat}})^{-1} \cdot \mathbf{x}_ {\text{mat}}^T \cdot \mathbf{w}_ {\text{mat}} \cdot \mathbf{y}_ {\text{mat}} $$</p><p>$$ \mathbf{y}_ {\text{hat}} &#x3D; \mathbf{x}_ {\text{test}} \cdot \hat{\beta} $$</p></li></ol><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>线性回归是一种常见且简单的回归算法，用于建立输入特征和输出之间的线性关系。其原理可以概括为以下几个步骤：</p><ol><li><p><strong>假设线性关系：</strong> 首先，线性回归假设输入特征和输出之间存在线性关系，即可以用线性方程来表示。这个线性方程的形式可以表示为：$$y &#x3D; w_0 + w_1x_1 + w_2x_2 + \ldots + w_nx_n$$其中，$y$是预测的输出，$x_1, x_2, \ldots, x_n$是输入特征，$w_0, w_1, w_2, \ldots, w_n$是回归系数（权重）。</p></li><li><p><strong>最小化误差：</strong> 线性回归的目标是找到最佳的回归系数，使得预测值与真实输出之间的误差最小化。通常使用均方误差（Mean Squared Error，MSE）作为衡量误差的指标。MSE的定义为：$$MSE &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (y_i - \hat{y}_i)^2$$其中，$m$是样本数量，$y_i$是第$i$个样本的真实输出，$\hat{y}_i$是线性模型预测的输出。</p></li><li><p><strong>求解回归系数：</strong> 最小化MSE的过程可以使用不同的优化算法，常见的方法是最小二乘法（Ordinary Least Squares，OLS）。最小二乘法的目标是找到能够最小化误差平方和的回归系数，从而得到最佳拟合的直线（或超平面）。</p></li><li><p><strong>特征处理：</strong> 在进行线性回归之前，通常需要对输入特征进行预处理，包括特征缩放、特征选择、特征变换等。这有助于提高模型的性能和稳定性。</p></li><li><p><strong>预测和评估：</strong> 在训练完成后，使用训练得到的回归系数来进行预测。对于新的输入特征，通过线性方程计算预测值。模型的性能可以通过各种指标（如R-squared、均方误差等）来进行评估。</p></li></ol><h2 id="局部加权线性回归"><a href="#局部加权线性回归" class="headerlink" title="局部加权线性回归"></a>局部加权线性回归</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>局部加权线性回归（Locally Weighted Linear Regression，LWLR）是一种非参数回归方法，用于在回归分析中拟合数据并预测目标变量。与传统的线性回归方法不同，LWLR 在预测时考虑了样本点附近的权重，从而能够更好地捕捉数据中的局部非线性关系。</p><p>LWLR 的主要思想是，对于待预测的数据点，通过对训练数据中的每个点赋予不同的权重，来进行加权线性回归。在预测时，距离待预测点近的训练样本会被赋予较高的权重，而距离较远的训练样本则会被赋予较低的权重。这样可以使得模型在局部区域内更关注于邻近样本，从而更好地适应局部的数据分布。</p><p>具体来说，对于待预测点 $(x_{\text{test}}, y_{\text{test}})$，LWLR 的回归模型为：</p><p>$$y_{\text{test}} &#x3D; x_{\text{test}}^T \cdot \hat{\beta}$$</p><p>其中，$\hat{\beta}$ 是通过加权最小二乘法计算得到的回归系数，权重 $w^{(i)}$ 由核函数计算得出：</p><p>$$w^{(i)} &#x3D; \exp\left(-\frac{(x^{(i)} - x_{\text{test}})^T \cdot (x^{(i)} - x_{\text{test}})}{2\tau^2}\right)$$</p><p>其中，$x^{(i)}$ 是训练样本的特征向量，$\tau$ 是一个用户指定的参数，控制权重的衰减速度。核函数通常使用高斯核函数（Gaussian Kernel），但也可以选择其他类型的核函数。</p><p>需要注意的是，LWLR 是一种非参数方法，因为它不对模型形式做出明确的假设，而是在每个预测点处都进行加权线性回归。虽然 LWLR 在局部能够更好地拟合数据，但也存在计算复杂度高和参数选择的问题。</p><p>LWLR 在处理数据中存在局部非线性关系时具有优势，但在全局趋势较为明显的情况下，可能会导致过拟合。</p><h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>岭回归（Ridge Regression）是一种用于处理多重共线性问题的线性回归技术，它在最小二乘法的基础上引入了正则化项，有助于提高模型的稳定性和泛化能力。岭回归的主要思想是通过对回归系数的大小进行限制，来减小模型的复杂度，从而降低过拟合的风险。</p><p>在普通的最小二乘线性回归中，我们试图最小化损失函数 $J(\beta) &#x3D; \sum_{i&#x3D;1}^{m}(y^{(i)} - \mathbf{x}^{(i)T}\beta)^2$，其中 $\beta$ 是回归系数，$y^{(i)}$ 是目标变量，$\mathbf{x}^{(i)}$ 是特征向量。而岭回归则在这个基础上引入了一个正则化项，使得最小化的目标变为：</p><p>$$J_{\text{ridge}}(\beta) &#x3D; \sum_{i&#x3D;1}^{m}(y^{(i)} - \mathbf{x}^{(i)T}\beta)^2 + \lambda \sum_{j&#x3D;1}^{n}\beta_j^2$$</p><p>其中 $\lambda$ 是一个用户指定的正则化参数，$n$ 是特征的数量。第二项 $\lambda \sum_{j&#x3D;1}^{n}\beta_j^2$ 被称为岭惩罚项（Ridge Penalty），它惩罚了回归系数的大小。当 $\lambda$ 较大时，回归系数会被强烈惩罚，趋向于接近于零，从而减小模型的复杂度。</p><p>岭回归的求解过程可以使用类似最小二乘法的方法，通过求解下面的最优化问题来得到回归系数 $\beta$：</p><p>$$ \hat{\beta}_ {\text{ridge}} &#x3D; \arg\min_{\beta} \left( \sum_{i&#x3D;1}^{m} \left(y^{(i)} - \mathbf{x}^{(i)T}\beta\right)^2 + \lambda \sum_{j&#x3D;1}^{n} \beta_j^2 \right) $$</p><p>岭回归的一个重要特点是，它可以处理多重共线性问题，即特征之间存在强相关性的情况。在普通的线性回归中，当特征之间存在共线性时，回归系数的估计可能会变得不稳定，而岭回归通过引入正则化项可以在一定程度上缓解这个问题。</p><p>选择合适的正则化参数 $\lambda$ 对岭回归的性能具有重要影响。较小的 $\lambda$ 可能会导致模型过拟合，而较大的 $\lambda$ 可能会导致模型欠拟合。通常可以通过交叉验证等方法来选择最优的 $\lambda$ 值。</p><h2 id="前向逐步回归"><a href="#前向逐步回归" class="headerlink" title="前向逐步回归"></a>前向逐步回归</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>前向逐步回归是一个基于贪婪算法的特征选择方法。它从一个包含无特征的模型开始，并逐步添加或减少特征，直到达到某个终止条件（例如，达到预定的特征数量或误差不再显著减少）。</p><p>原理：</p><ol><li>开始时，模型不包含任何特征，即所有回归系数都设为0。</li><li>每一步，考虑添加一个特征或减去一个特征，或者增加&#x2F;减少一个特征的系数。</li><li>选择那些能够使误差最小化的特征或系数更新。</li></ol><p>公式如下：</p><ol><li><p>计算当前模型的误差 $E_0$（例如，均方误差）:</p><p>$$ E_0 &#x3D; \sum_{i&#x3D;1}^N (y_i - \mathbf{x}_i^T \mathbf{w})^2 $$</p><p>其中，$y_i$ 是第 $i$ 个观测值的响应变量，$\mathbf{x}_i$ 是第 $i$ 个观测值的特征向量，$\mathbf{w}$ 是回归系数向量。</p></li><li><p>对于每一个特征 $j$，计算增加或减少这个特征（或改变它的系数）时的新误差 $E_j$:</p><p>$$ E_j &#x3D; \sum_{i&#x3D;1}^N (y_i - \mathbf{x}_i^T \mathbf{w} + \Delta w_j \mathbf{x} _{ij})^2 $$</p><p>其中，$\Delta w_j$ 是对第 $j$ 个系数的改变量，$\mathbf{x}_{ij}$ 是第 $i$ 个观测值的第 $j$ 个特征。</p></li><li><p>选择那个使 $E_j - E_0$ 最小的特征进行更新。</p></li><li><p>重复上述步骤，直到满足终止条件。</p><p>在每一步，前向逐步回归会尝试增加、减少或不改变每一个特征的系数，然后选择那个使误差最小化的更新。这是一个迭代的、基于贪婪策略的过程，旨在逐步构建一个误差最小的模型。</p></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="abalone.txt" href="/citation/Regression/abalone.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">abalone.txt</p><p class="url">/citation/Regression/abalone.txt</p></div></a></div><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="data.txt" href="/citation/Regression/data.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">data.txt</p><p class="url">/citation/Regression/data.txt</p></div></a></div></div><h3 id="线性回归-1"><a href="#线性回归-1" class="headerlink" title="线性回归"></a>线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">fileName</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    解析以 tab 键分隔的文件中的浮点数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dataMat :   feature 对应的数据集</span></span><br><span class="line"><span class="string">        labelMat :  feature 对应的分类标签，即类别标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numFeat = <span class="built_in">len</span>(<span class="built_in">open</span>(fileName).readline().split(<span class="string">&#x27;\t&#x27;</span>)) - <span class="number">1</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    labelMat = []</span><br><span class="line">    fr = <span class="built_in">open</span>(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = []</span><br><span class="line">        curLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeat):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(<span class="built_in">float</span>(curLine[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">standRegres</span>(<span class="params">xArr, yArr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    线性回归</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        xArr : 输入的样本数据，包含每个样本数据的 feature</span></span><br><span class="line"><span class="string">        yArr : 对应于输入数据的类别标签，也就是每个样本对应的目标变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        ws: 回归系数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    xTx = xMat.T * xMat</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xTx) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This matrix is singular, cannot do inverse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ws = xTx.I * (xMat.T * yMat)</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regression1</span>():</span><br><span class="line">    xArr, yArr = loadDataSet(<span class="string">&quot;8.Regression/data.txt&quot;</span>)</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr)</span><br><span class="line">    ws = standRegres(xArr, yArr)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xMat[:, <span class="number">1</span>].flatten(), yMat.T[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>])</span><br><span class="line">    xCopy = xMat.copy()</span><br><span class="line">    xCopy.sort(<span class="number">0</span>)</span><br><span class="line">    yHat = xCopy * ws</span><br><span class="line">    ax.plot(xCopy[:, <span class="number">1</span>], yHat)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    regression1()</span><br></pre></td></tr></table></figure><h3 id="局部加权线性回归-1"><a href="#局部加权线性回归-1" class="headerlink" title="局部加权线性回归"></a>局部加权线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">fileName</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    解析以 tab 键分隔的文件中的浮点数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dataMat :   feature 对应的数据集</span></span><br><span class="line"><span class="string">        labelMat :  feature 对应的分类标签，即类别标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numFeat = <span class="built_in">len</span>(<span class="built_in">open</span>(fileName).readline().split(<span class="string">&#x27;\t&#x27;</span>)) - <span class="number">1</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    labelMat = []</span><br><span class="line">    fr = <span class="built_in">open</span>(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = []</span><br><span class="line">        curLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeat):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(<span class="built_in">float</span>(curLine[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lwlr</span>(<span class="params">testPoint, xArr, yArr, k=<span class="number">1.0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    局部加权线性回归，在待预测点附近的每个点赋予一定的权重，在子集上基于最小均方差来进行普通的回归。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        testPoint: 样本点</span></span><br><span class="line"><span class="string">        xArr: 样本的特征数据，即 feature</span></span><br><span class="line"><span class="string">        yArr: 每个样本对应的类别标签，即目标变量</span></span><br><span class="line"><span class="string">        k: 关于赋予权重矩阵的核的一个参数，与权重的衰减速率有关</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        testPoint * ws: 数据点与具有权重的系数相乘得到的预测点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    m = shape(xMat)[<span class="number">0</span>]</span><br><span class="line">    weights = mat(eye((m)))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        diffMat = testPoint - xMat[j, :]</span><br><span class="line">        weights[j, j] = exp(diffMat * diffMat.T / (-<span class="number">2.0</span> * k ** <span class="number">2</span>))</span><br><span class="line">    xTx = xMat.T * (weights * xMat)</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xTx) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This matrix is singular, cannot do inverse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ws = xTx.I * (xMat.T * (weights * yMat))</span><br><span class="line">    <span class="keyword">return</span> testPoint * ws</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lwlrTest</span>(<span class="params">testArr, xArr, yArr, k=<span class="number">1.0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试局部加权线性回归，对数据集中每个点调用 lwlr() 函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        testArr: 测试所用的所有样本点</span></span><br><span class="line"><span class="string">        xArr: 样本的特征数据，即 feature</span></span><br><span class="line"><span class="string">        yArr: 每个样本对应的类别标签，即目标变量</span></span><br><span class="line"><span class="string">        k: 控制核函数的衰减速率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        yHat: 预测点的估计值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m = shape(testArr)[<span class="number">0</span>]</span><br><span class="line">    yHat = zeros(m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        yHat[i] = lwlr(testArr[i], xArr, yArr, k)</span><br><span class="line">    <span class="keyword">return</span> yHat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lwlrTestPlot</span>(<span class="params">xArr, yArr, k=<span class="number">1.0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    首先将 X 排序，其余的都与 lwlrTest 相同，这样更容易绘图</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        xArr: 样本的特征数据，即 feature</span></span><br><span class="line"><span class="string">        yArr: 每个样本对应的类别标签，即目标变量，实际值</span></span><br><span class="line"><span class="string">        k: 控制核函数的衰减速率的有关参数，这里设定的是常量值 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        yHat: 样本点的估计值</span></span><br><span class="line"><span class="string">        xCopy: xArr 的复制</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    yHat = zeros(shape(yArr))</span><br><span class="line">    xCopy = mat(xArr)</span><br><span class="line">    xCopy.sort(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(shape(xArr)[<span class="number">0</span>]):</span><br><span class="line">        yHat[i] = lwlr(xCopy[i], xArr, yArr, k)</span><br><span class="line">    <span class="keyword">return</span> yHat, xCopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regression2</span>():</span><br><span class="line">    xArr, yArr = loadDataSet(<span class="string">&quot;8.Regression/data.txt&quot;</span>)</span><br><span class="line">    yHat = lwlrTest(xArr, xArr, yArr, <span class="number">0.01</span>)</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    srtInd = xMat[:, <span class="number">1</span>].argsort(<span class="number">0</span>)</span><br><span class="line">    xSort = xMat[srtInd][:, <span class="number">0</span>, :]</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.plot(xSort[:, <span class="number">1</span>], yHat[srtInd])</span><br><span class="line">    ax.scatter(xMat[:, <span class="number">1</span>].flatten().A[<span class="number">0</span>], mat(yArr).T.flatten().A[<span class="number">0</span>], s=<span class="number">2</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    regression2()</span><br></pre></td></tr></table></figure><h3 id="岭回归-1"><a href="#岭回归-1" class="headerlink" title="岭回归"></a>岭回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">fileName</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    解析以tab键分隔的文件中的浮点数</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        fileName: 文件名</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        dataMat : 特征数据集</span></span><br><span class="line"><span class="string">        labelMat : 类别标签</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    numFeat = <span class="built_in">len</span>(<span class="built_in">open</span>(fileName).readline().split(<span class="string">&#x27;\t&#x27;</span>)) - <span class="number">1</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    labelMat = []</span><br><span class="line">    fr = <span class="built_in">open</span>(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = []</span><br><span class="line">        curLine = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeat):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(<span class="built_in">float</span>(curLine[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ridgeRegres</span>(<span class="params">xMat, yMat, lam=<span class="number">0.2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    进行岭回归求解</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        xMat: 特征数据</span></span><br><span class="line"><span class="string">        yMat: 类别标签，实际值</span></span><br><span class="line"><span class="string">        lam: λ值，用于使矩阵非奇异</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        回归系数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    xTx = xMat.T * xMat</span><br><span class="line">    denom = xTx + eye(shape(xMat)[<span class="number">1</span>]) * lam</span><br><span class="line">    <span class="keyword">if</span> linalg.det(denom) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This matrix is singular, cannot do inverse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ws = denom.I * (xMat.T * yMat)</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ridgeTest</span>(<span class="params">xArr, yArr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在一组 λ 上测试岭回归结果</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        xArr: 特征数据</span></span><br><span class="line"><span class="string">        yArr: 类别标签，真实数据</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        所有回归系数输出到矩阵并返回</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    yMean = mean(yMat, <span class="number">0</span>)</span><br><span class="line">    yMat = yMat - yMean</span><br><span class="line">    xMeans = mean(xMat, <span class="number">0</span>)</span><br><span class="line">    xVar = var(xMat, <span class="number">0</span>)</span><br><span class="line">    xMat = (xMat - xMeans) / xVar</span><br><span class="line">    numTestPts = <span class="number">30</span></span><br><span class="line">    wMat = zeros((numTestPts, shape(xMat)[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTestPts):</span><br><span class="line">        ws = ridgeRegres(xMat, yMat, exp(i - <span class="number">10</span>))</span><br><span class="line">        wMat[i, :] = ws.T</span><br><span class="line">    <span class="keyword">return</span> wMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regression3</span>():</span><br><span class="line">    abX, abY = loadDataSet(<span class="string">&quot;8.Regression/abalone.txt&quot;</span>)</span><br><span class="line">    ridgeWeights = ridgeTest(abX, abY)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.plot(ridgeWeights)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    regression3()</span><br></pre></td></tr></table></figure><h3 id="前向逐步回归-1"><a href="#前向逐步回归-1" class="headerlink" title="前向逐步回归"></a>前向逐步回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stageWise</span>(<span class="params">xArr, yArr, eps=<span class="number">0.01</span>, numIt=<span class="number">100</span></span>):</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    yMean = mean(yMat, <span class="number">0</span>)</span><br><span class="line">    yMat = yMat - yMean  <span class="comment"># 也可以规则化ys但会得到更小的coef</span></span><br><span class="line">    xMat = regularize(xMat)</span><br><span class="line">    m, n = shape(xMat)</span><br><span class="line">    returnMat = zeros((numIt, n))  <span class="comment"># 测试代码删除</span></span><br><span class="line">    ws = zeros((n, <span class="number">1</span>))</span><br><span class="line">    wsTest = ws.copy()</span><br><span class="line">    wsMax = ws.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIt):</span><br><span class="line">        <span class="built_in">print</span>(ws.T)</span><br><span class="line">        lowestError = inf</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> sign <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">                wsTest = ws.copy()</span><br><span class="line">                wsTest[j] += eps * sign</span><br><span class="line">                yTest = xMat * wsTest</span><br><span class="line">                rssE = rssError(yMat.A, yTest.A)</span><br><span class="line">                <span class="keyword">if</span> rssE &lt; lowestError:</span><br><span class="line">                    lowestError = rssE</span><br><span class="line">                    wsMax = wsTest</span><br><span class="line">        ws = wsMax.copy()</span><br><span class="line">        returnMat[i, :] = ws.T</span><br><span class="line">    <span class="keyword">return</span> returnMat</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regularize</span>(<span class="params">xMat</span>):  <span class="comment"># 按列进行规范化</span></span><br><span class="line">    inMat = xMat.copy()</span><br><span class="line">    inMeans = mean(inMat, <span class="number">0</span>)  <span class="comment"># 计算平均值然后减去它</span></span><br><span class="line">    inVar = var(inMat, <span class="number">0</span>)  <span class="comment"># 计算除以Xi的方差</span></span><br><span class="line">    inMat = (inMat - inMeans) / inVar</span><br><span class="line">    <span class="keyword">return</span> inMat</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rssError</span>(<span class="params">yArr, yHatArr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Desc:</span></span><br><span class="line"><span class="string">            计算分析预测误差的大小</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            yArr: 真实的目标变量</span></span><br><span class="line"><span class="string">            yHatArr: 预测得到的估计值</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            计算真实值和估计值得到的值的平方和作为最后的返回值</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ((yArr - yHatArr) ** <span class="number">2</span>).<span class="built_in">sum</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">standRegres</span>(<span class="params">xArr, yArr</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Description: </span></span><br><span class="line"><span class="string">        线性回归</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        xArr : 输入的样本数据，包含每个样本数据的 feature</span></span><br><span class="line"><span class="string">        yArr : 对应于输入数据的类别标签，也就是每个样本对应的目标变量</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        ws: 回归系数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># mat()函数将xArr，yArr转换为矩阵 mat().T 代表的是对矩阵进行转置操作</span></span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    <span class="comment"># 矩阵乘法的条件是左矩阵的列数等于右矩阵的行数</span></span><br><span class="line">    xTx = xMat.T * xMat</span><br><span class="line">    <span class="comment"># 因为要用到xTx的逆矩阵，所以事先需要确定计算得到的xTx是否可逆，条件是矩阵的行列式不为0</span></span><br><span class="line">    <span class="comment"># linalg.det() 函数是用来求得矩阵的行列式的，如果矩阵的行列式为0，则这个矩阵是不可逆的，就无法进行接下来的运算</span></span><br><span class="line">    <span class="keyword">if</span> linalg.det(xTx) == <span class="number">0.0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This matrix is singular, cannot do inverse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 最小二乘法</span></span><br><span class="line">    <span class="comment"># http://cwiki.apachecn.org/pages/viewpage.action?pageId=5505133</span></span><br><span class="line">    <span class="comment"># 书中的公式，求得w的最优解</span></span><br><span class="line">    ws = xTx.I * (xMat.T * yMat)</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stageWise</span>(<span class="params">xArr,yArr,eps=<span class="number">0.01</span>,numIt=<span class="number">100</span></span>):</span><br><span class="line">    xMat = mat(xArr); yMat=mat(yArr).T</span><br><span class="line">    yMean = mean(yMat,<span class="number">0</span>)</span><br><span class="line">    yMat = yMat - yMean     <span class="comment"># 也可以规则化ys但会得到更小的coef</span></span><br><span class="line">    xMat = regularize(xMat)</span><br><span class="line">    m,n=shape(xMat)</span><br><span class="line">    <span class="comment">#returnMat = zeros((numIt,n)) # 测试代码删除</span></span><br><span class="line">    ws = zeros((n,<span class="number">1</span>)); wsTest = ws.copy(); wsMax = ws.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numIt):</span><br><span class="line">        <span class="built_in">print</span> (ws.T)</span><br><span class="line">        lowestError = inf; </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> sign <span class="keyword">in</span> [-<span class="number">1</span>,<span class="number">1</span>]:</span><br><span class="line">                wsTest = ws.copy()</span><br><span class="line">                wsTest[j] += eps*sign</span><br><span class="line">                yTest = xMat*wsTest</span><br><span class="line">                rssE = rssError(yMat.A,yTest.A)</span><br><span class="line">                <span class="keyword">if</span> rssE &lt; lowestError:</span><br><span class="line">                    lowestError = rssE</span><br><span class="line">                    wsMax = wsTest</span><br><span class="line">        ws = wsMax.copy()</span><br><span class="line">        returnMat[i,:]=ws.T</span><br><span class="line">    <span class="keyword">return</span> returnMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regression4</span>():</span><br><span class="line">    xArr, yArr = loadDataSet(<span class="string">&quot;8.Regression/abalone.txt&quot;</span>)</span><br><span class="line">    stageWise(xArr, yArr, <span class="number">0.01</span>, <span class="number">200</span>)</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    xMat = regularize(xMat)</span><br><span class="line">    yM = mean(yMat, <span class="number">0</span>)</span><br><span class="line">    yMat = yMat - yM</span><br><span class="line">    weights = standRegres(xMat, yMat.T)</span><br><span class="line">    <span class="built_in">print</span>(weights.T)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    regression4()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日乘子法简述</title>
      <link href="/2023/08/02/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%AE%80%E8%BF%B0/"/>
      <url>/2023/08/02/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>拉格朗日乘子法（Lagrange Multiplier Method）是一种数学工具，用于在约束条件下优化多元函数。它由意大利数学家约瑟夫·路易·拉格朗日（Joseph Louis Lagrange）在18世纪提出，用于解决具有约束条件的极值问题。该方法在经济学、工程学、物理学等领域中有广泛的应用。</p><p>拉格朗日乘子法主要用于求解这样一个问题：在一个多元函数的定义域内，寻找函数取得最大值或最小值的点，同时满足一组约束条件。一般情况下，这个问题可以表示为如下的优化问题：</p><p>最大化（或最小化）函数 $f(x1, x2, …, xn)$<br>在约束条件下：$g1(x1, x2, …, xn) &#x3D; 0, g2(x1, x2, …, xn) &#x3D; 0, …, gm(x1, x2, …, xn) &#x3D; 0$</p><p>其中，$f$是目标函数，$g1, g2, …, gm$是约束条件函数。</p><p>拉格朗日乘子法的基本思想是，为了在满足约束条件的情况下优化目标函数，引入一组称为拉格朗日乘子（Lagrange multipliers）的变量，构造一个新的函数，称为拉格朗日函数（Lagrange function），通过对这个函数进行求导，可以得到一组关于原函数和约束条件的方程，通过求解这些方程，可以找到满足约束条件的极值点。</p><p>需要注意的是，拉格朗日乘子法仅适用于满足一定条件的情况，如可微分性和约束条件的线性独立性。在某些情况下，可能存在局部最优解或无解的情况。</p><p>总之，拉格朗日乘子法是一种强大的工具，用于处理带有约束条件的优化问题，它通过引入拉格朗日乘子，将约束条件与目标函数结合起来，使得求解复杂的优化问题变得更加可行。</p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><ol><li><p><strong>建立拉格朗日函数：</strong> 首先，构建拉格朗日函数$$L(x_1, … , x_n, \lambda_1, … , \lambda_m) &#x3D; f(x_1, … , x_n) + \lambda_1 g_1(x_1, … , x_n) + … + \lambda_m g_m(x_1, … , x_n)$$，其中，$f$是目标函数，$g_1, g_2, \ldots, g_m$是约束条件函数，$\lambda_1, \lambda_2, \ldots, \lambda_m$是拉格朗日乘子。</p></li><li><p><strong>对拉格朗日函数求偏导数：</strong> 对拉格朗日函数分别对变量 $x_i$ 和 $\lambda_j$ 进行求偏导数，得到一组方程：</p><p>$\frac{\partial L}{\partial x_i} &#x3D; 0$，其中 $i &#x3D; 1, 2, \ldots, n$<br>$\frac{\partial L}{\partial \lambda_j} &#x3D; 0$，其中 $j &#x3D; 1, 2, \ldots, m$</p><p>这些方程的解代表了在满足约束条件的情况下，目标函数的极值点以及对应的拉格朗日乘子值。</p></li><li><p><strong>解方程组：</strong> 解上述方程组，得到变量 $x_i$ 和 $\lambda_j$ 的值。这些值可以用来确定原问题的极值点，以及满足约束条件的最优解。</p></li><li><p><strong>检验结果：</strong> 将求得的极值点代入原目标函数和约束条件中，验证是否满足约束条件并找到了目标函数的最优解。</p></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>找到函数 $f(x, y) &#x3D; x^2 + y^2$ 在约束条件 $g(x, y) &#x3D; x + y - 1 &#x3D; 0$ 下的最大值。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol><li><p><strong>建立拉格朗日函数：</strong> 构建拉格朗日函数 $L(x, y, \lambda) &#x3D; f(x, y) + \lambda g(x, y) &#x3D; x^2 + y^2 + \lambda(x + y - 1)$，其中 $\lambda$ 是拉格朗日乘子。</p></li><li><p><strong>对拉格朗日函数求偏导数：</strong> 对拉格朗日函数 $L$ 分别对 $x, y$ 和 $\lambda$ 求偏导数并令其为零：</p><p>$\frac{\partial L}{\partial x} &#x3D; 2x + \lambda &#x3D; 0$<br>$\frac{\partial L}{\partial y} &#x3D; 2y + \lambda &#x3D; 0$<br>$\frac{\partial L}{\partial \lambda} &#x3D; x + y - 1 &#x3D; 0$</p><p>从第一和第二个方程可得出 $x &#x3D; -\lambda&#x2F;2$ 和 $y &#x3D; -\lambda&#x2F;2$。将这些值代入第三个方程可以解出 $\lambda &#x3D; -2$。</p></li><li><p><strong>解方程组：</strong> 将 $\lambda &#x3D; -2$ 代入 $x &#x3D; -\lambda&#x2F;2$ 和 $y &#x3D; -\lambda&#x2F;2$ 中，得到 $x &#x3D; 1$ 和 $y &#x3D; 1$。</p></li><li><p><strong>检验结果：</strong> 检验求得的极值点 $(x, y) &#x3D; (1, 1)$ 是否满足约束条件 $g(x, y) &#x3D; x + y - 1 &#x3D; 0$。在这个例子中，满足条件。然后将 $(1, 1)$ 代入目标函数 $f(x, y) &#x3D; x^2 + y^2$ 中，得到最大值 $f(1, 1) &#x3D; 2$。</p></li></ol><p>因此，在给定约束条件 $g(x, y) &#x3D; x + y - 1 &#x3D; 0$ 下，函数 $f(x, y) &#x3D; x^2 + y^2$ 的最大值为 $2$，在点 $(1, 1)$ 处取得。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>考虑一个二分类问题，我们有一组数据点 ${ (x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n) }$，其中 $x_i$ 是数据特征，$y_i \in {-1, 1}$ 是对应的标签。我们希望找到一个超平面 $w \cdot x + b &#x3D; 0$，使得间隔最大化，同时允许一些数据点出现在超平面错误的一侧。这可以表示为以下优化问题：</p><p>最大化 $\frac{2}{|w|}$<br>在约束条件下：$y_i (w \cdot x_i + b) \geq 1$，对所有的 $i$</p><p>这里，$w$ 是超平面的法向量，$b$ 是偏移量，$y_i$ 是标签，$x_i$ 是数据特征。</p><h3 id="解决步骤-1"><a href="#解决步骤-1" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol><li><p><strong>建立拉格朗日函数：</strong> 构建拉格朗日函数 $L(w, b, \alpha) &#x3D; \frac{1}{2}|w|^2 - \sum_{i&#x3D;1}^{n} \alpha_i [y_i (w \cdot x_i + b) - 1]$，其中 $\alpha_i$ 是拉格朗日乘子。</p></li><li><p><strong>对拉格朗日函数求偏导数：</strong> 对拉格朗日函数 $L$ 分别对 $w, b$ 和 $\alpha_i$ 求偏导数并令其为零：</p><p>$\frac{\partial L}{\partial w} &#x3D; w - \sum_{i&#x3D;1}^{n} \alpha_i y_i x_i &#x3D; 0$<br>$\frac{\partial L}{\partial b} &#x3D; -\sum_{i&#x3D;1}^{n} \alpha_i y_i &#x3D; 0$<br>$\frac{\partial L}{\partial \alpha_i} &#x3D; y_i (w \cdot x_i + b) - 1 &#x3D; 0$</p></li><li><p><strong>解方程组：</strong> 将上述方程组代入拉格朗日函数，解出 $\alpha_i$。然后，使用求得的 $\alpha_i$ 计算 $w$ 和 $b$。</p></li><li><p><strong>得到最终超平面：</strong> 计算得到的 $w$ 和 $b$ 描述了最终的超平面，可以用于分类。</p></li></ol><p>这个例子涉及了SVM中的软间隔最大化问题，通过拉格朗日乘子法可以求解得到支持向量机的模型参数。这是一个在机器学习中非常有用的例子，展示了拉格朗日乘子法在优化问题中的应用。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lagrange Multiplier Method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AdaBoost算法简析</title>
      <link href="/2023/08/02/AdaBoost%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/08/02/AdaBoost%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="AdaBoost算法简析"><a href="#AdaBoost算法简析" class="headerlink" title="AdaBoost算法简析"></a>AdaBoost算法简析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AdaBoost（Adaptive Boosting）是一种集成学习（Ensemble Learning）算法，旨在提高分类算法的性能。它通过将多个弱分类器（通常是简单的、性能略优于随机猜测的分类器）组合在一起，形成一个强分类器，从而实现更准确的分类。</p><p>以下是AdaBoost算法的概述：</p><ol><li><p><strong>数据准备：</strong> 首先，需要准备带有标签的训练数据集，其中每个样本都有一个已知的类别标签。</p></li><li><p><strong>初始化权重：</strong> 对每个样本赋予一个初始权重，这些权重表示样本在训练过程中的重要性。通常情况下，初始权重相等。</p></li><li><p><strong>迭代训练：</strong> AdaBoost通过一系列迭代来构建强分类器。在每次迭代中，它执行以下步骤：</p><p>a. <strong>选择弱分类器：</strong> 从一组可能的弱分类器中选择一个，该选择是基于当前样本权重和分类器的性能来做出的。</p><p>b. <strong>训练弱分类器：</strong> 使用当前样本权重对选择的弱分类器进行训练，使其在当前数据分布下尽可能准确地分类。</p><p>c. <strong>计算错误率：</strong> 计算弱分类器在当前数据分布下的错误率，以便在下一步中进行权重调整。</p><p>d. <strong>更新样本权重：</strong> 根据弱分类器的错误率调整样本权重，增加被错误分类的样本的权重，降低被正确分类的样本的权重。</p></li><li><p><strong>组合弱分类器：</strong> 对于每个迭代步骤，都会为弱分类器分配一个权重，该权重基于其性能。然后，将所有弱分类器的结果按照权重加权组合起来，形成一个强分类器。</p></li><li><p><strong>分类预测：</strong> 使用构建的强分类器来进行新样本的分类预测。强分类器将根据每个弱分类器的权重对样本进行分类，最终输出最可能的类别标签。</p></li></ol><p>AdaBoost的关键思想在于每一次迭代都会调整样本的权重，将注意力集中在被错误分类的样本上，从而逐步改善分类性能。最终，通过组合多个弱分类器，AdaBoost能够产生一个在分类任务中表现良好的强分类器。</p><p>需要注意的是，AdaBoost对异常值比较敏感，因此在使用时需要谨慎处理数据异常情况。另外，AdaBoost在一些特定情况下可能会过拟合，因此可能需要进行适当的调参或者尝试其他集成学习方法。</p><h2 id="AdaBoost与RandomForest"><a href="#AdaBoost与RandomForest" class="headerlink" title="AdaBoost与RandomForest"></a>AdaBoost与RandomForest</h2><p>AdaBoost（Adaptive Boosting）和Random Forest都是集成学习算法，用于提高分类算法的性能。它们有一些共同之处，但也存在一些显著的区别。下面是它们之间的主要区别与联系：</p><p><strong>区别：</strong></p><ol><li><p><strong>基本分类器的选择：</strong></p><ul><li>AdaBoost：AdaBoost的基本分类器是弱分类器，通常是一个简单的分类器，如决策树的深度很小。</li><li>Random Forest：Random Forest的基本分类器是决策树，通常是深度较大的决策树。</li></ul></li><li><p><strong>样本权重：</strong></p><ul><li>AdaBoost：AdaBoost在每次迭代中调整样本的权重，将注意力集中在被错误分类的样本上。</li><li>Random Forest：Random Forest不调整样本权重，每棵决策树都基于原始数据进行训练。</li></ul></li><li><p><strong>训练方式：</strong></p><ul><li>AdaBoost：AdaBoost是通过顺序迭代的方式构建弱分类器，并逐步提高其性能。</li><li>Random Forest：Random Forest是通过并行训练多棵决策树，每棵树都在随机抽取的子样本上进行训练，然后对它们的预测结果进行投票或平均。</li></ul></li><li><p><strong>权重分配：</strong></p><ul><li>AdaBoost：AdaBoost在构建最终分类器时，对每个弱分类器分配一个权重，用于组合它们的预测结果。</li><li>Random Forest：Random Forest对所有决策树的预测结果进行投票（分类问题）或平均（回归问题），最终确定最终结果。</li></ul></li></ol><p><strong>联系：</strong></p><ol><li><p><strong>集成思想：</strong> AdaBoost和Random Forest都采用了集成学习的思想，通过组合多个基本分类器来提高整体性能。</p></li><li><p><strong>减少过拟合：</strong> 两种算法都能有效减少过拟合的风险。AdaBoost通过调整样本权重来关注难以分类的样本，而Random Forest通过随机子样本和特征选择来增加模型的多样性，从而减少过拟合。</p></li><li><p><strong>应用领域：</strong> 两种算法在各种应用领域都有广泛的应用，包括分类和回归问题。</p></li><li><p><strong>模型解释：</strong> 通常情况下，Random Forest的模型比较容易解释，因为它由多个决策树组成。相比之下，由于AdaBoost使用加权投票组合多个弱分类器，解释起来可能稍微复杂一些。</p></li></ol><p>在选择使用AdaBoost还是Random Forest时，你需要考虑数据特点、问题复杂度以及模型性能等因素。需要注意的是，这两种算法并不是适用于所有问题的通用解决方案，有时候其他的集成学习方法或单一模型可能更加适合。</p><h2 id="涉及到的数学公式"><a href="#涉及到的数学公式" class="headerlink" title="涉及到的数学公式"></a>涉及到的数学公式</h2><ol><li><p><strong>初始化样本权重：</strong><br>$$w_i^{(1)} &#x3D; \frac{1}{N} \quad \text{for} \quad i &#x3D; 1, 2, \ldots, N$$</p></li><li><p><strong>弱分类器的权重计算：</strong><br>$$\epsilon_t &#x3D; \sum_{i&#x3D;1}^{N} w_i^{(t)} \cdot \mathbb{1}\left(h_t(x_i) \neq y_i\right)$$</p><p>$$\alpha_t &#x3D; \frac{1}{2} \ln\left(\frac{1 - \epsilon_t}{\epsilon_t}\right)$$</p></li><li><p><strong>样本权重更新：</strong><br>$$w_i^{(t+1)} &#x3D; \frac{w_i^{(t)} \cdot \exp(-\alpha_t \cdot y_i \cdot h_t(x_i))}{Z_t} \quad \text{for} \quad i &#x3D; 1, 2, \ldots, N$$</p><p>其中，<br>$$Z_t &#x3D; \sum_{i&#x3D;1}^{N} w_i^{(t)} \cdot \exp(-\alpha_t \cdot y_i \cdot h_t(x_i))$$</p></li><li><p><strong>最终分类器的组合：</strong><br>$$H(x) &#x3D; \text{sign}\left(\sum_{t&#x3D;1}^{T} \alpha_t \cdot h_t(x)\right)$$</p></li></ol><p>这些公式涵盖了AdaBoost算法的核心数学原理。在这里，$N$ 表示样本数量，$x_i$ 是第 $i$ 个样本的特征，$y_i$ 是第 $i$ 个样本的标签，$h_t(x_i)$ 是第 $t$ 个弱分类器对样本 $x_i$ 的预测结果，$\alpha_t$ 是第 $t$ 个弱分类器的权重，$w_i^{(t)}$ 是第 $t$ 轮迭代中样本 $x_i$ 的权重，$T$ 是迭代轮数。</p><p>需要注意的是，这里的公式只是一个概览，实际的推导和计算过程可能会更加详细和复杂。如果你希望更深入地了解AdaBoost算法的数学原理，建议参考相关的教材、论文或在线资源。</p><h2 id="案例：马疝病的预测"><a href="#案例：马疝病的预测" class="headerlink" title="案例：马疝病的预测"></a>案例：马疝病的预测</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="horseColicTest2.txt" href="/citation/AdaBoost/horseColicTest2.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">horseColicTest2.txt</p><p class="url">/citation/AdaBoost/horseColicTest2.txt</p></div></a></div><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="horseColicTraining2.txt" href="/citation/AdaBoost/horseColicTraining2.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">horseColicTraining2.txt</p><p class="url">/citation/AdaBoost/horseColicTraining2.txt</p></div></a></div></div><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_sim_data</span>():</span><br><span class="line">    data_mat = np.matrix([[<span class="number">1.0</span>, <span class="number">2.1</span>],</span><br><span class="line">                          [<span class="number">2.0</span>, <span class="number">1.1</span>],</span><br><span class="line">                          [<span class="number">1.3</span>, <span class="number">1.0</span>],</span><br><span class="line">                          [<span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                          [<span class="number">2.0</span>, <span class="number">1.0</span>]])</span><br><span class="line">    class_labels = [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">    <span class="keyword">return</span> data_mat, class_labels</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_set</span>(<span class="params">file_name</span>):</span><br><span class="line">    num_feat = <span class="built_in">len</span>(<span class="built_in">open</span>(file_name).readline().split(<span class="string">&#x27;\t&#x27;</span>))</span><br><span class="line">    data_arr = []</span><br><span class="line">    label_arr = []</span><br><span class="line">    fr = <span class="built_in">open</span>(file_name)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line_arr = []</span><br><span class="line">        cur_line = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_feat - <span class="number">1</span>):</span><br><span class="line">            line_arr.append(<span class="built_in">float</span>(cur_line[i]))</span><br><span class="line">        data_arr.append(line_arr)</span><br><span class="line">        label_arr.append(<span class="built_in">float</span>(cur_line[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> np.matrix(data_arr), label_arr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stump_classify</span>(<span class="params">data_mat, dimen, thresh_val, thresh_ineq</span>):</span><br><span class="line">    ret_array = np.ones((np.shape(data_mat)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> thresh_ineq == <span class="string">&#x27;lt&#x27;</span>:</span><br><span class="line">        ret_array[data_mat[:, dimen] &lt;= thresh_val] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret_array[data_mat[:, dimen] &gt; thresh_val] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> ret_array</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_stump</span>(<span class="params">data_arr, class_labels, D</span>):</span><br><span class="line">    data_mat = np.mat(data_arr)</span><br><span class="line">    label_mat = np.mat(class_labels).T</span><br><span class="line">    m, n = np.shape(data_mat)</span><br><span class="line">    num_steps = <span class="number">10.0</span></span><br><span class="line">    best_stump = &#123;&#125;</span><br><span class="line">    best_class_est = np.mat(np.zeros((m, <span class="number">1</span>)))</span><br><span class="line">    min_err = np.inf</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        range_min = data_mat[:, i].<span class="built_in">min</span>()</span><br><span class="line">        range_max = data_mat[:, i].<span class="built_in">max</span>()</span><br><span class="line">        step_size = (range_max - range_min) / num_steps</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>, <span class="built_in">int</span>(num_steps) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> inequal <span class="keyword">in</span> [<span class="string">&#x27;lt&#x27;</span>, <span class="string">&#x27;gt&#x27;</span>]:</span><br><span class="line">                thresh_val = (range_min + <span class="built_in">float</span>(j) * step_size)</span><br><span class="line">                predicted_vals = stump_classify(data_mat, i, thresh_val, inequal)</span><br><span class="line">                err_arr = np.mat(np.ones((m, <span class="number">1</span>)))</span><br><span class="line">                err_arr[predicted_vals == label_mat] = <span class="number">0</span></span><br><span class="line">                weighted_err = D.T * err_arr</span><br><span class="line">                <span class="keyword">if</span> weighted_err &lt; min_err:</span><br><span class="line">                    min_err = weighted_err</span><br><span class="line">                    best_class_est = predicted_vals.copy()</span><br><span class="line">                    best_stump[<span class="string">&#x27;dim&#x27;</span>] = i</span><br><span class="line">                    best_stump[<span class="string">&#x27;thresh&#x27;</span>] = thresh_val</span><br><span class="line">                    best_stump[<span class="string">&#x27;ineq&#x27;</span>] = inequal</span><br><span class="line">    <span class="keyword">return</span> best_stump, min_err, best_class_est</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ada_boost_train_ds</span>(<span class="params">data_arr, class_labels, num_it=<span class="number">40</span></span>):</span><br><span class="line">    weak_class_arr = []</span><br><span class="line">    m = np.shape(data_arr)[<span class="number">0</span>]</span><br><span class="line">    D = np.mat(np.ones((m, <span class="number">1</span>)) / m)</span><br><span class="line">    agg_class_est = np.mat(np.zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_it):</span><br><span class="line">        best_stump, error, class_est = build_stump(data_arr, class_labels, D)</span><br><span class="line">        alpha = <span class="built_in">float</span>(<span class="number">0.5</span> * np.log((<span class="number">1.0</span> - error) / <span class="built_in">max</span>(error, <span class="number">1e-16</span>)))</span><br><span class="line">        best_stump[<span class="string">&#x27;alpha&#x27;</span>] = alpha</span><br><span class="line">        weak_class_arr.append(best_stump)</span><br><span class="line">        expon = np.multiply(-<span class="number">1</span> * alpha * np.mat(class_labels).T, class_est)</span><br><span class="line">        D = np.multiply(D, np.exp(expon))</span><br><span class="line">        D = D / D.<span class="built_in">sum</span>()</span><br><span class="line">        agg_class_est += alpha * class_est</span><br><span class="line">        agg_errors = np.multiply(np.sign(agg_class_est) != np.mat(class_labels).T,</span><br><span class="line">                                 np.ones((m, <span class="number">1</span>)))</span><br><span class="line">        error_rate = agg_errors.<span class="built_in">sum</span>() / m</span><br><span class="line">        <span class="keyword">if</span> error_rate == <span class="number">0.0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> weak_class_arr, agg_class_est</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ada_classify</span>(<span class="params">data_to_class, classifier_arr</span>):</span><br><span class="line">    data_mat = np.mat(data_to_class)</span><br><span class="line">    m = np.shape(data_mat)[<span class="number">0</span>]</span><br><span class="line">    agg_class_est = np.mat(np.zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classifier_arr)):</span><br><span class="line">        class_est = stump_classify(</span><br><span class="line">            data_mat, classifier_arr[i][<span class="string">&#x27;dim&#x27;</span>],</span><br><span class="line">            classifier_arr[i][<span class="string">&#x27;thresh&#x27;</span>],</span><br><span class="line">            classifier_arr[i][<span class="string">&#x27;ineq&#x27;</span>]</span><br><span class="line">        )</span><br><span class="line">        agg_class_est += classifier_arr[i][<span class="string">&#x27;alpha&#x27;</span>] * class_est</span><br><span class="line">    <span class="keyword">return</span> np.sign(agg_class_est)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_roc</span>(<span class="params">pred_strengths, class_labels</span>):</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    y_sum = <span class="number">0.0</span></span><br><span class="line">    num_pos_class = np.<span class="built_in">sum</span>(np.array(class_labels) == <span class="number">1.0</span>)</span><br><span class="line">    y_step = <span class="number">1</span> / <span class="built_in">float</span>(num_pos_class)</span><br><span class="line">    x_step = <span class="number">1</span> / <span class="built_in">float</span>(<span class="built_in">len</span>(class_labels) - num_pos_class)</span><br><span class="line">    sorted_indicies = pred_strengths.argsort()</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    fig.clf()</span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    cur = (<span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> sorted_indicies.tolist()[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> class_labels[index] == <span class="number">1.0</span>:</span><br><span class="line">            del_x = <span class="number">0</span></span><br><span class="line">            del_y = y_step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            del_x = x_step</span><br><span class="line">            del_y = <span class="number">0</span></span><br><span class="line">            y_sum += cur[<span class="number">1</span>]</span><br><span class="line">        ax.plot([cur[<span class="number">0</span>], cur[<span class="number">0</span>] - del_x], [cur[<span class="number">1</span>], cur[<span class="number">1</span>] - del_y], c=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">        cur = (cur[<span class="number">0</span>] - del_x, cur[<span class="number">1</span>] - del_y)</span><br><span class="line">    ax.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&#x27;b--&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;False positive rate&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True positive rate&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;ROC curve for AdaBoost horse colic detection system&#x27;</span>)</span><br><span class="line">    ax.axis([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the Area Under the Curve is: &quot;</span>, y_sum * x_step)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    data_mat, class_labels = load_data_set(<span class="string">&#x27;7.AdaBoost/horseColicTraining2.txt&#x27;</span>)</span><br><span class="line">    weak_class_arr, agg_class_est = ada_boost_train_ds(data_mat, class_labels, <span class="number">40</span>)</span><br><span class="line">    plot_roc(agg_class_est, class_labels)</span><br><span class="line">    data_arr_test, label_arr_test = load_data_set(<span class="string">&quot;7.AdaBoost/horseColicTest2.txt&quot;</span>)</span><br><span class="line">    m = np.shape(data_arr_test)[<span class="number">0</span>]</span><br><span class="line">    predicting10 = ada_classify(data_arr_test, weak_class_arr)</span><br><span class="line">    err_arr = np.mat(np.ones((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(m,</span><br><span class="line">          err_arr[predicting10 != np.mat(label_arr_test).T].<span class="built_in">sum</span>(),</span><br><span class="line">          err_arr[predicting10 != np.mat(label_arr_test).T].<span class="built_in">sum</span>() / m</span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><div class="note info"><p>来源于 <a href="https://www.apachecn.org/">ApacheCN</a></p></div><h2 id="DT与AdaBoost"><a href="#DT与AdaBoost" class="headerlink" title="DT与AdaBoost"></a>DT与AdaBoost</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">X = np.linspace(<span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>)[:, np.newaxis]</span><br><span class="line">y = np.sin(X).ravel() + np.sin(<span class="number">6</span> * X).ravel() + rng.normal(<span class="number">0</span>, <span class="number">0.1</span>, X.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">regr_1 = DecisionTreeRegressor(max_depth=<span class="number">4</span>)</span><br><span class="line">regr_2 = AdaBoostRegressor(DecisionTreeRegressor(max_depth=<span class="number">4</span>), n_estimators=<span class="number">300</span>, random_state=rng)</span><br><span class="line"></span><br><span class="line">regr_1.fit(X, y)</span><br><span class="line">regr_2.fit(X, y)</span><br><span class="line"></span><br><span class="line">y_1 = regr_1.predict(X)</span><br><span class="line">y_2 = regr_2.predict(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, c=<span class="string">&quot;k&quot;</span>, label=<span class="string">&quot;training samples&quot;</span>)</span><br><span class="line">plt.plot(X, y_1, c=<span class="string">&quot;g&quot;</span>, label=<span class="string">&quot;n_estimators=1&quot;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(X, y_2, c=<span class="string">&quot;r&quot;</span>, label=<span class="string">&quot;n_estimators=300&quot;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;target&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Boosted Decision Tree Regression&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y---&#x27;</span>, <span class="built_in">type</span>(y[<span class="number">0</span>]), <span class="built_in">len</span>(y), y[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_1---&#x27;</span>, <span class="built_in">type</span>(y_1[<span class="number">0</span>]), <span class="built_in">len</span>(y_1), y_1[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_2---&#x27;</span>, <span class="built_in">type</span>(y_2[<span class="number">0</span>]), <span class="built_in">len</span>(y_2), y_2[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">y_true = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">y_scores = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_scores---&#x27;</span>, <span class="built_in">type</span>(y_scores[<span class="number">0</span>]), <span class="built_in">len</span>(y_scores), y_scores)</span><br><span class="line"><span class="built_in">print</span>(metrics.roc_auc_score(y_true, y_scores))</span><br></pre></td></tr></table></figure><img src="/citation/AdaBoost/img.png" class="lazyload placeholder" data-srcset="/citation/AdaBoost/img.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> AdaBoost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RandomForest算法简析</title>
      <link href="/2023/08/02/RandomForest%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/08/02/RandomForest%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="RandomForest算法简析"><a href="#RandomForest算法简析" class="headerlink" title="RandomForest算法简析"></a>RandomForest算法简析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随机森林（Random Forest）是一种强大且流行的机器学习算法，用于解决分类和回归问题。它是集成学习（Ensemble Learning）方法的一种，通过组合多个决策树来形成一个更强大的模型。随机森林由贝叶斯学者Leo Breiman于2001年提出，并在实践中被广泛应用。</p><p>以下是随机森林的概述：</p><ol><li><p>决策树基本原理：首先需要了解决策树的基本原理。决策树是一种非参数化的监督学习方法，通过在输入特征上逐步进行二分划分，将数据集分割成不同的区域，从而构建一个树形的分类模型。</p></li><li><p>随机森林组成：随机森林由多个决策树组成。在构建每个决策树时，采用的数据是从原始训练集中有放回地随机抽取的（有放回采样，即Bootstrap采样），同时每个决策树使用的特征子集也是随机选择的。</p></li><li><p>随机性：随机森林的随机性体现在两个方面：首先，通过随机抽取数据和特征子集，使得每个决策树都有所不同；其次，当进行树节点划分时，不再搜索所有可能的特征，而是随机选择特征子集中的一个特征进行划分。这种随机性有助于降低模型的方差，提高泛化性能。</p></li><li><p>投票集成：在分类问题中，每个决策树会给出一个预测结果，最终的分类结果是通过投票机制来确定，即采用多数投票的结果作为最终输出。在回归问题中，随机森林的预测结果是多个决策树预测结果的平均值。</p></li><li><p>随机森林的优点：随机森林在处理高维数据和大规模数据时表现出色，具有很强的泛化能力，不容易过拟合，且对于异常值和噪声相对稳健。此外，随机森林能够评估特征的重要性，对于特征选择和可视化数据具有一定帮助。</p></li><li><p>参数调节：随机森林中的主要参数包括决策树的数量、每个决策树的最大深度、特征子集大小等。在实践中，可以通过交叉验证等技术来选择合适的参数值，从而优化模型的性能。</p></li></ol><p>总结来说，随机森林是一种强大且易于使用的机器学习算法，适用于分类和回归问题，并在许多现实世界的应用中取得了很好的效果。</p><h2 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h2><p>集成方法（Ensemble Methods）是一种机器学习技术，通过组合多个基本模型来构建一个更强大、更稳健的预测模型。这些基本模型可以是同质的（相同类型的算法）或异质的（不同类型的算法），它们通常被称为”弱学习器”（Weak Learners）或”基学习器”（Base Learners）。</p><p>集成方法通过将多个弱学习器的预测结果进行加权平均或投票等方式，从而得到更准确、泛化能力更强的综合预测结果。相比单一的基本模型，集成方法能够降低过拟合风险，提高模型的鲁棒性和稳定性。</p><p>集成方法的主要优势在于它能够在不同的数据集和问题上产生出色的表现。这是因为集成方法利用了多个模型的优势，而不受单个模型的局限性。在实践中，集成方法通常比单个模型更容易调整和优化，尤其在处理复杂任务和大规模数据时具有很大的优势。</p><p>常见的集成方法包括：</p><ol><li><p><strong>Bagging（Bootstrap Aggregating）</strong>: Bagging使用有放回抽样（Bootstrap采样）从原始训练数据中生成多个不同的训练集，然后在每个训练集上构建独立的弱学习器。最终的预测结果是这些弱学习器预测结果的平均值（回归问题）或多数投票结果（分类问题）。</p></li><li><p><strong>Boosting</strong>: Boosting是一种迭代的集成方法，通过顺序构建多个弱学习器，每个学习器都试图纠正前一个学习器的错误。Boosting方法根据预测错误的样本给予其更高的权重，以便下一个学习器更关注这些难以分类的样本。常见的Boosting算法有AdaBoost和Gradient Boosting Machine (GBM)。</p></li><li><p><strong>Stacking</strong>: Stacking是一种更复杂的集成方法，它不仅仅简单地将多个模型的结果进行加权平均，而是将不同模型的预测结果作为新的特征，然后再训练一个元学习器来产生最终的预测结果。</p></li><li><p><strong>Random Forest</strong>: 此前已经提到过，随机森林是一种基于Bagging思想的集成学习方法，由多个决策树组成。</p></li></ol><p>集成方法在机器学习领域得到广泛应用，特别是在数据挖掘、分类和回归任务中。通过将多个模型的优势相结合，集成方法能够显著提高预测性能，成为了许多机器学习竞赛和实际应用中的重要技术。</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><p>随机森林（Random Forest）算法的构建过程如下：</p><ol><li><p>数据准备：首先，将原始数据集拆分成训练集和测试集。训练集用于构建随机森林模型，测试集用于评估模型的性能。</p></li><li><p>随机抽样：对于每棵决策树，从训练集中进行有放回地随机抽样（Bootstrap采样），得到一个新的训练子集。这意味着每个子集可能包含一部分重复样本，而其他样本可能会被省略。这种随机抽样可以确保每棵决策树之间有差异，增加模型的多样性。</p></li><li><p>特征随机选择：在每个节点处，决策树的构建不会考虑所有的特征，而是随机选择一个特征子集来进行节点划分。这样做的目的是增加模型的随机性，防止过度拟合，并鼓励不同决策树使用不同的特征来构建树。</p></li><li><p>构建决策树：根据上述随机抽样和特征选择的训练子集，在每个节点上使用某种决策树算法（通常是CART算法，即分类与回归树）来划分数据。决策树会根据选择的特征和划分准则将数据集划分为更小的子集，直到满足某个停止条件（例如：节点样本数小于某个阈值、树的深度达到一定值等）为止。</p></li><li><p>集成决策：对于分类问题，每棵决策树投票选择它们认为的最终类别，并以多数票决定最终的分类结果。对于回归问题，每棵决策树给出一个预测值，最终的预测结果是这些预测值的平均值。</p></li><li><p>模型评估：使用测试集评估随机森林的性能，可以使用各种指标如准确率、精确度、召回率、F1分数等。</p></li><li><p>特征重要性评估：随机森林可以输出每个特征的重要性分数，用于衡量每个特征对模型预测性能的贡献程度。</p></li></ol><h2 id="涉及到的数学公式"><a href="#涉及到的数学公式" class="headerlink" title="涉及到的数学公式"></a>涉及到的数学公式</h2><ol><li><p>基尼不纯度（Gini Impurity）：用于衡量节点的不纯度，对于分类问题，基尼不纯度定义如下：<br>$$ \text{Gini}(p) &#x3D; 1 - \sum_{i&#x3D;1}^{K} p_i^2 $$<br>其中，$K$ 是类别的数量，$p_i$ 是类别$i$在节点中的样本比例。</p></li><li><p>信息增益（Information Gain）：用于在决策树节点划分时选择最优特征。对于分类问题，信息增益定义如下：<br>$$ \text{IG}(D, f) &#x3D; \text{Gini}(D) - \sum_{v \in \text{Values}(f)} \frac{|D_v|}{|D|} \text{Gini}(D_v) $$<br>其中，$D$ 是当前节点的数据集，$f$ 是特征，$\text{Values}(f)$ 是特征$f$的取值集合，$D_v$ 是特征$f$取值为$v$时对应的数据子集。</p></li><li><p>均方误差（Mean Squared Error，MSE）：用于回归问题中衡量节点的纯度，定义如下：<br>$$ \text{MSE}(D) &#x3D; \frac{1}{|D|} \sum_{i&#x3D;1}^{|D|} (y_i - \bar{y})^2 $$<br>其中，$D$ 是当前节点的数据集，$y_i$ 是样本$i$的真实输出值，$\bar{y}$ 是节点中所有样本输出值的均值。</p></li><li><p>随机森林中的投票或平均：对于分类问题，随机森林使用投票机制，即多个决策树的预测结果中取多数票作为最终结果。对于回归问题，随机森林使用平均值，即多个决策树的预测值取平均作为最终结果。</p></li></ol><h2 id="案例：声纳信号分类"><a href="#案例：声纳信号分类" class="headerlink" title="案例：声纳信号分类"></a>案例：声纳信号分类</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="sonar-all-data.txt" href="/citation/RandomForest/sonar-all-data.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">sonar-all-data.txt</p><p class="url">/citation/RandomForest/sonar-all-data.txt</p></div></a></div></div><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> seed, randrange, random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">filename</span>):</span><br><span class="line">    dataset = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            lineArr = []</span><br><span class="line">            <span class="keyword">for</span> featrue <span class="keyword">in</span> line.split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">                str_f = featrue.strip()</span><br><span class="line">                <span class="keyword">if</span> str_f.isdigit():</span><br><span class="line">                    lineArr.append(<span class="built_in">float</span>(str_f))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lineArr.append(str_f)</span><br><span class="line">            dataset.append(lineArr)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_validation_split</span>(<span class="params">dataset, n_folds</span>):</span><br><span class="line">    dataset_split = <span class="built_in">list</span>()</span><br><span class="line">    dataset_copy = <span class="built_in">list</span>(dataset)</span><br><span class="line">    fold_size = <span class="built_in">len</span>(dataset) / n_folds</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_folds):</span><br><span class="line">        fold = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(fold) &lt; fold_size:</span><br><span class="line">            index = randrange(<span class="built_in">len</span>(dataset_copy))</span><br><span class="line">            fold.append(dataset_copy[index])</span><br><span class="line">        dataset_split.append(fold)</span><br><span class="line">    <span class="keyword">return</span> dataset_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_split</span>(<span class="params">index, value, dataset</span>):</span><br><span class="line">    left, right = <span class="built_in">list</span>(), <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> dataset:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(row[index]) &lt; <span class="built_in">str</span>(value):</span><br><span class="line">            left.append(row)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(row)</span><br><span class="line">    <span class="keyword">return</span> left, right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gini_index</span>(<span class="params">groups, class_values</span>):</span><br><span class="line">    gini = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> class_value <span class="keyword">in</span> class_values:</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> groups:</span><br><span class="line">            size = <span class="built_in">len</span>(group)</span><br><span class="line">            <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            proportion = [row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> group].count(class_value) / <span class="built_in">float</span>(size)</span><br><span class="line">            gini += (proportion * (<span class="number">1.0</span> - proportion))</span><br><span class="line">    <span class="keyword">return</span> gini</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_split</span>(<span class="params">dataset, n_features</span>):</span><br><span class="line">    class_values = <span class="built_in">list</span>(<span class="built_in">set</span>(row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> dataset))</span><br><span class="line">    b_index, b_value, b_score, b_groups = <span class="number">999</span>, <span class="number">999</span>, <span class="number">999</span>, <span class="literal">None</span></span><br><span class="line">    features = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(features) &lt; n_features:</span><br><span class="line">        index = randrange(<span class="built_in">len</span>(dataset[<span class="number">0</span>]) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">not</span> <span class="keyword">in</span> features:</span><br><span class="line">            features.append(index)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> features:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> dataset:</span><br><span class="line">            groups = test_split(index, row[index], dataset)</span><br><span class="line">            gini = gini_index(groups, class_values)</span><br><span class="line">            <span class="keyword">if</span> gini &lt; b_score:</span><br><span class="line">                b_index, b_value, b_score, b_groups = index, row[index], gini, groups</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;index&#x27;</span>: b_index, <span class="string">&#x27;value&#x27;</span>: b_value, <span class="string">&#x27;groups&#x27;</span>: b_groups&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_terminal</span>(<span class="params">group</span>):</span><br><span class="line">    outcomes = [row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> group]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(outcomes), key=outcomes.count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split</span>(<span class="params">node, max_depth, min_size, n_features, depth</span>):</span><br><span class="line">    left, right = node[<span class="string">&#x27;groups&#x27;</span>]</span><br><span class="line">    <span class="keyword">del</span> (node[<span class="string">&#x27;groups&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">        node[<span class="string">&#x27;left&#x27;</span>] = node[<span class="string">&#x27;right&#x27;</span>] = to_terminal(left + right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> depth &gt;= max_depth:</span><br><span class="line">        node[<span class="string">&#x27;left&#x27;</span>], node[<span class="string">&#x27;right&#x27;</span>] = to_terminal(left), to_terminal(right)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(left) &lt;= min_size:</span><br><span class="line">        node[<span class="string">&#x27;left&#x27;</span>] = to_terminal(left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node[<span class="string">&#x27;left&#x27;</span>] = get_split(left, n_features)</span><br><span class="line">        split(node[<span class="string">&#x27;left&#x27;</span>], max_depth, min_size, n_features, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(right) &lt;= min_size:</span><br><span class="line">        node[<span class="string">&#x27;right&#x27;</span>] = to_terminal(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node[<span class="string">&#x27;right&#x27;</span>] = get_split(right, n_features)</span><br><span class="line">        split(node[<span class="string">&#x27;right&#x27;</span>], max_depth, min_size, n_features, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_tree</span>(<span class="params">train, max_depth, min_size, n_features</span>):</span><br><span class="line">    root = get_split(train, n_features)</span><br><span class="line">    split(root, max_depth, min_size, n_features, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">node, row</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(row[node[<span class="string">&#x27;index&#x27;</span>]]) &lt; <span class="built_in">str</span>(node[<span class="string">&#x27;value&#x27;</span>]):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(node[<span class="string">&#x27;left&#x27;</span>], <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">return</span> predict(node[<span class="string">&#x27;left&#x27;</span>], row)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node[<span class="string">&#x27;left&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(node[<span class="string">&#x27;right&#x27;</span>], <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">return</span> predict(node[<span class="string">&#x27;right&#x27;</span>], row)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node[<span class="string">&#x27;right&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bagging_predict</span>(<span class="params">trees, row</span>):</span><br><span class="line">    predictions = [predict(tree, row) <span class="keyword">for</span> tree <span class="keyword">in</span> trees]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(predictions), key=predictions.count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subsample</span>(<span class="params">dataset, ratio</span>):</span><br><span class="line">    sample = <span class="built_in">list</span>()</span><br><span class="line">    n_sample = <span class="built_in">round</span>(<span class="built_in">len</span>(dataset) * ratio)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(sample) &lt; n_sample:</span><br><span class="line">        index = randrange(<span class="built_in">len</span>(dataset))</span><br><span class="line">        sample.append(dataset[index])</span><br><span class="line">    <span class="keyword">return</span> sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_forest</span>(<span class="params">train, test, max_depth, min_size, sample_size, n_trees, n_features</span>):</span><br><span class="line">    trees = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_trees):</span><br><span class="line">        sample = subsample(train, sample_size)</span><br><span class="line">        tree = build_tree(sample, max_depth, min_size, n_features)</span><br><span class="line">        trees.append(tree)</span><br><span class="line">    predictions = [bagging_predict(trees, row) <span class="keyword">for</span> row <span class="keyword">in</span> test]</span><br><span class="line">    <span class="keyword">return</span> predictions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy_metric</span>(<span class="params">actual, predicted</span>):</span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(actual)):</span><br><span class="line">        <span class="keyword">if</span> actual[i] == predicted[i]:</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">float</span>(<span class="built_in">len</span>(actual)) * <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_algorithm</span>(<span class="params">dataset, algorithm, n_folds, *args</span>):</span><br><span class="line">    folds = cross_validation_split(dataset, n_folds)</span><br><span class="line">    scores = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> fold <span class="keyword">in</span> folds:</span><br><span class="line">        train_set = <span class="built_in">list</span>(folds)</span><br><span class="line">        train_set.remove(fold)</span><br><span class="line">        train_set = <span class="built_in">sum</span>(train_set, [])</span><br><span class="line">        test_set = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> fold:</span><br><span class="line">            row_copy = <span class="built_in">list</span>(row)</span><br><span class="line">            row_copy[-<span class="number">1</span>] = <span class="literal">None</span></span><br><span class="line">            test_set.append(row_copy)</span><br><span class="line">        predicted = algorithm(train_set, test_set, *args)</span><br><span class="line">        actual = [row[-<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> fold]</span><br><span class="line">        accuracy = accuracy_metric(actual, predicted)</span><br><span class="line">        scores.append(accuracy)</span><br><span class="line">    <span class="keyword">return</span> scores</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dataset = loadDataSet(<span class="string">&#x27;7.RandomForest/sonar-all-data.txt&#x27;</span>)</span><br><span class="line">    n_folds = <span class="number">5</span></span><br><span class="line">    max_depth = <span class="number">20</span></span><br><span class="line">    min_size = <span class="number">1</span></span><br><span class="line">    sample_size = <span class="number">1.0</span></span><br><span class="line">    n_features = <span class="number">15</span></span><br><span class="line">    <span class="keyword">for</span> n_trees <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>]:</span><br><span class="line">        scores = evaluate_algorithm(dataset, random_forest, n_folds, max_depth, min_size, sample_size, n_trees, n_features)</span><br><span class="line">        seed(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;random=&#x27;</span>, random())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trees: %d&#x27;</span> % n_trees)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Scores: %s&#x27;</span> % scores)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Mean Accuracy: %.3f%%&#x27;</span> % (<span class="built_in">sum</span>(scores) / <span class="built_in">float</span>(<span class="built_in">len</span>(scores))))</span><br></pre></td></tr></table></figure><div class="note info"><p>来源于 <a href="https://www.apachecn.org/">ApacheCN</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Random Forest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVM简析</title>
      <link href="/2023/08/01/SVM%E7%AE%80%E6%9E%90/"/>
      <url>/2023/08/01/SVM%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SVM支持向量机"><a href="#SVM支持向量机" class="headerlink" title="SVM支持向量机"></a>SVM支持向量机</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SVM（支持向量机）是一种常用的监督学习算法，用于分类和回归任务。其主要目标是找到一个超平面，将不同类别的数据点有效地分隔开，并使得边距最大化。在分类问题中，SVM将数据点映射到特征空间，并通过支持向量寻找最优超平面，以在未知数据上取得良好的泛化性能。</p><p>SVM的核心原理包括以下几点：</p><ol><li><p>支持向量：在数据点中，距离超平面最近的一些数据点被称为支持向量，它们对超平面的位置和间隔起着关键作用。</p></li><li><p>最大边距：SVM通过最大化超平面与支持向量之间的边距来寻找最优解。最大边距可以提高模型的鲁棒性，使其对新数据更具预测能力。</p></li><li><p>分类器构建：SVM的目标是解决一个优化问题，通过数学方法找到最优的超平面。这个优化问题是一个凸二次规划问题，在线性可分的情况下有解。</p></li><li><p>核函数：对于线性不可分的数据，SVM可以通过核函数将数据映射到高维特征空间，在高维空间中找到超平面，从而实现线性分类。常用的核函数有线性核、多项式核和高斯核等。</p></li><li><p>正则化参数：SVM引入一个正则化参数C，用于平衡最大化边距和分类错误之间的权衡。较小的C值允许一些分类错误，而较大的C值对分类错误施加更严格的惩罚。</p></li></ol><p>SVM具有良好的泛化能力，对于小样本数据和高维特征空间都表现出较好的性能。它在图像分类、文本分类、生物信息学等领域取得了广泛的应用。虽然SVM在处理大规模数据时存在一定的挑战，但在许多实际问题中，它仍然是一个有效且强大的分类器和回归器。</p><h2 id="涉及到的数学公式"><a href="#涉及到的数学公式" class="headerlink" title="涉及到的数学公式"></a>涉及到的数学公式</h2><ol><li><p>SVM分类器：</p><ul><li>假设超平面的方程为：$$f(x) &#x3D; w^T x + b$$</li><li>其中，$f(x)$ 是输入样本 $x$ 的预测输出，$w$ 是超平面的法向量（权重），$b$ 是超平面的偏置项。</li></ul></li><li><p>超平面到数据点的距离：</p><ul><li>数据点 $x$ 到超平面 $f(x)$ 的带符号距离为：$$d &#x3D; \frac{w^T x + b}{|w|}$$，其中 $|w|$ 是 $w$ 的L2范数。</li></ul></li><li><p>分类决策规则：</p><ul><li>如果 $f(x) \geq 0$，则预测 $x$ 属于正类别。</li><li>如果 $f(x) &lt; 0$，则预测 $x$ 属于负类别。</li></ul></li><li><p>间隔（边距）：</p><ul><li>对于超平面 $(w^T x + b) &#x3D; 0$，它到最近的正类别支持向量和最近的负类别支持向量之间的距离为 $\frac{2}{|w|}$。</li><li>SVM 的目标是最大化边距，即最小化 $|w|$。</li></ul></li><li><p>优化问题：<br>   SVM的优化问题是一个凸二次规划（Quadratic Programming，QP）问题。对于线性可分和线性不可分的情况，可以使用不同的方法来解决SVM的优化问题。</p><ol><li><p>线性可分情况下的优化问题：<br>对于线性可分的SVM，优化问题可以表示为：<br>$$\text{Minimize:} \quad \frac{1}{2} |w|^2$$<br>$$\text{Subject to:} \quad y_i (w^T x_i + b) \geq 1, \text{for all} \ i$$<br>其中，$x_i$ 是训练样本，$y_i$ 是样本 $x_i$ 的标签（+1 或 -1），$w$ 是超平面的法向量，$b$ 是超平面的偏置项。</p><p>这是一个凸二次规划问题，可以使用现有的凸优化求解器来求解。常用的凸优化求解器包括：</p><ul><li><a href="/2023/08/01/SVM%E7%AE%80%E6%9E%90/#%E5%BA%8F%E5%88%97%E6%9C%80%E5%B0%8F%E4%BC%98%E5%8C%96SMO">序列最小优化算法</a>（Sequential Minimal Optimization，SMO）</li><li>内点法（Interior Point Method）</li><li>梯度下降法（Gradient Descent）</li><li>坐标下降法（Coordinate Descent）等</li></ul><p>这些方法可以找到拉格朗日乘子 $\alpha$ 的最优解，进而求解出超平面的参数 $w$ 和 $b$。</p></li><li><p>线性不可分情况下的优化问题：<br>当数据线性不可分时，SVM引入松弛变量 $\xi_i$，使得部分数据点可以位于边界区域内。优化问题变为：<br>$$\text{Minimize:} \quad \frac{1}{2} |w|^2 + C \sum \xi_i$$<br>$$\text{Subject to:} \quad y_i (w^T x_i + b) \geq 1 - \xi_i, \text{for all} \ i$$<br>$$\xi_i \geq 0, \text{for all} \ i$$<br>其中，$C$ 是一个正则化参数，控制了分类错误的惩罚。</p><p>这也是一个凸二次规划问题，可以使用相同的凸优化求解器来求解。通过求解优化问题，可以得到拉格朗日乘子 $\alpha$ 和松弛变量 $\xi_i$ 的最优解，进而求解出超平面的参数 $w$ 和 $b$。</p></li></ol><p>需要注意的是，当遇到非线性问题时，需要使用核函数来将数据映射到高维特征空间，然后再应用上述方法来求解对偶问题。这样，可以将非线性SVM转化为一个线性SVM问题来求解。</p></li><li><p>核函数：</p><ul><li>SVM通过核函数将数据映射到高维特征空间，以实现非线性分类。常用的核函数有线性核、多项式核和高斯核。</li><li>线性核：$$K(x_i, x_j) &#x3D; x_i^T x_j$$</li><li>多项式核：$$K(x_i, x_j) &#x3D; (\gamma x_i^T x_j + r)^d$$</li><li>高斯核（径向基核）：$$K(x_i, x_j) &#x3D; \exp(-\gamma |x_i - x_j|^2)$$</li></ul></li></ol><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><p>数据预处理：</p><ul><li>收集和准备训练数据集，确保数据是有标签的，并且特征值和标签值已经转换为数值形式。</li><li>如果数据集中存在缺失值或异常值，进行数据清洗和处理。</li></ul></li><li><p>特征缩放：</p><ul><li>对特征值进行缩放，确保所有特征在相同的尺度范围内。常见的缩放方法包括标准化（均值为0，方差为1）或者归一化（将特征缩放到0到1的范围内）。</li></ul></li><li><p>训练集和测试集划分：</p><ul><li>将数据集划分为训练集和测试集，用于模型的训练和评估。</li></ul></li><li><p>核函数选择（可选）：</p><ul><li>如果数据集是线性不可分的，需要选择合适的核函数对数据进行映射。常见的核函数有线性核、多项式核和高斯核等。</li></ul></li><li><p>优化问题解决：</p><ul><li>使用优化算法（例如凸二次规划问题的求解器）来找到SVM的最优超平面。</li><li>线性可分的情况下，使用硬间隔SVM；线性不可分的情况下，使用软间隔SVM。</li></ul></li><li><p>正则化参数选择（可选）：</p><ul><li>对于软间隔SVM，需要选择合适的正则化参数C，该参数控制了分类错误的惩罚程度。C值较大将更严格惩罚分类错误，C值较小则更容忍分类错误。</li></ul></li><li><p>训练模型：</p><ul><li>使用训练集来训练SVM模型。模型的训练过程就是优化问题求解的过程，找到最优的超平面和参数。</li></ul></li><li><p>预测：</p><ul><li>使用训练好的模型对新的样本进行预测，计算预测输出的值 $f(x)$。</li></ul></li><li><p>评估模型性能：</p><ul><li>使用测试集来评估模型的性能。常见的评估指标包括准确率、精确率、召回率、F1-score等。</li></ul></li><li><p>调优（可选）：</p><ul><li>可以根据模型在测试集上的表现进行调优，例如尝试不同的核函数、调整正则化参数C等。</li></ul></li><li><p>应用模型：</p><ul><li>在实际应用中，使用训练好的SVM模型来进行分类任务，对新的未知样本进行分类预测。</li></ul></li></ol><h2 id="SVM与Logistic-Regression"><a href="#SVM与Logistic-Regression" class="headerlink" title="SVM与Logistic Regression"></a>SVM与Logistic Regression</h2><p>SVM（支持向量机）和逻辑回归在一些方面的数学公式和算法确实有相似之处，但它们在目标函数、决策边界和优化算法等方面存在明显的区别。下面列出它们的相似之处和区别：</p><p>相似之处：</p><ol><li><p>都是监督学习算法：SVM和逻辑回归都属于监督学习算法，都是用于解决分类问题。</p></li><li><p>都使用线性模型：SVM和逻辑回归在默认情况下都使用线性模型进行分类。线性模型是通过特征的线性组合来进行分类的。</p></li><li><p>都基于概率：逻辑回归可以输出样本属于某一类别的概率，而SVM通过决策函数的符号来判断样本的类别。</p></li></ol><p>区别：</p><ol><li><p>目标函数和决策边界：</p><ul><li>逻辑回归的目标是最小化Logistic损失函数，并使用sigmoid函数将线性模型的输出映射到[0, 1]的概率值。决策边界是线性的。</li><li>SVM的目标是找到一个能够将不同类别的数据点有效分隔开的超平面，并最大化边距。决策边界是距离支持向量最近的超平面。</li></ul></li><li><p>损失函数：</p><ul><li>逻辑回归使用Logistic损失函数（也称为交叉熵损失函数），用于衡量模型预测与实际标签之间的差异。</li><li>SVM使用Hinge损失函数，它对正确分类的样本施加较小的损失，对于错误分类的样本施加较大的损失。</li></ul></li><li><p>优化算法：</p><ul><li>逻辑回归通常使用梯度下降等优化算法来最小化损失函数。</li><li>SVM使用凸二次规划等优化算法来找到最优的超平面。</li></ul></li><li><p>处理线性不可分数据：</p><ul><li>逻辑回归可以处理线性不可分的数据，但在处理非线性问题时可能需要引入特征工程或使用多项式特征。</li><li>SVM通过使用核函数将数据映射到高维特征空间，从而实现处理非线性分类问题。</li></ul></li></ol><h2 id="判断线性可分"><a href="#判断线性可分" class="headerlink" title="判断线性可分"></a>判断线性可分</h2><p>在SVM中，线性可分是指数据集在特征空间中存在一个超平面，能够将不同类别的数据点完全正确地分隔开，而不会出现任何错误分类。判断数据是否线性可分可以通过以下方法：</p><ol><li><p>可视化数据：将数据绘制在二维或三维空间中，观察数据点的分布情况。如果数据点可以被一个直线（在二维空间）或一个平面（在三维空间）完全分开，那么数据集很可能是线性可分的。</p></li><li><p>线性SVM的结果：使用线性SVM对数据进行训练并绘制决策边界。如果线性SVM能够找到一个超平面，使得所有数据点都被正确分类，那么数据集是线性可分的。</p></li><li><p>检查线性约束条件：对于二分类问题，在SVM中，线性可分的条件是所有数据点满足以下线性约束条件：<br>$$y_i (w^T x_i + b) \geq 1, \text{for all} \ i$$<br>其中，$x_i$ 是数据点，$y_i$ 是数据点的标签（+1 或 -1），$w$ 是超平面的法向量，$b$ 是超平面的偏置项。</p></li><li><p>优化问题的结果：如果使用线性SVM解决优化问题，得到了一组满足上述约束条件的最优权重$w$和偏置项$b$，而且目标函数值为0（即最大化边距的结果），则说明数据是线性可分的。</p></li></ol><p>需要注意的是，在实际应用中，数据可能并不是完全线性可分的，而是存在一些噪声或重叠情况。在这种情况下，可以使用软间隔SVM来处理部分分类错误，或者使用核函数将数据映射到高维特征空间来处理非线性可分问题。</p><h2 id="序列最小优化SMO"><a href="#序列最小优化SMO" class="headerlink" title="序列最小优化SMO"></a>序列最小优化SMO</h2><p>序列最小优化（Sequential Minimal Optimization，简称SMO）是一种用于求解支持向量机（SVM）的优化算法，特别适用于处理大规模数据集的情况。SMO算法由John Platt于1998年提出，是一种迭代算法，通过不断选择两个变量进行优化，以逐步收敛到SVM的最优解。</p><p>SMO算法的基本思想是将SVM的对偶问题转化为一个二次规划问题，并采用启发式的方法来解决这个二次规划问题。SMO算法的主要步骤如下：</p><ol><li><p>初始化：初始化拉格朗日乘子 $\alpha$ 和偏置项 $b$ 为0，选择一个迭代次数的阈值或设置最大迭代次数。</p></li><li><p>选择两个变量：在每一次迭代中，选择两个需要更新的拉格朗日乘子 $\alpha_i$ 和 $\alpha_j$。选择的方法可以采用启发式的方式，例如通过最大步长来选择 $\alpha_i$ 和 $\alpha_j$。</p></li><li><p>优化两个变量：固定其他拉格朗日乘子 $\alpha$，将问题转化为一个只有两个变量的二次规划问题，并通过解析求解或优化算法（如SMO内循环）来找到 $\alpha_i$ 和 $\alpha_j$ 的最优解。</p></li><li><p>更新参数：根据得到的 $\alpha_i$ 和 $\alpha_j$ 的最优解，更新拉格朗日乘子 $\alpha$ 和偏置项 $b$。</p></li><li><p>终止条件：检查迭代次数是否达到设定的阈值，或者拉格朗日乘子的变化是否小于设定的容差。如果满足终止条件，则算法结束；否则，返回步骤2，继续下一轮迭代。</p></li></ol><p>SMO算法的优点在于，它每次只更新两个拉格朗日乘子，因此在每一步的计算量相对较小。同时，SMO算法还使用了一些启发式的策略，帮助在高维空间中搜索更快地收敛到SVM的最优解。这使得SMO算法在大规模数据集下表现出了较好的计算效率。</p><p>值得注意的是，SMO算法用于求解线性SVM，当遇到非线性问题时，需要使用核函数来将数据映射到高维特征空间，然后再应用SMO算法来求解对偶问题。这样，SMO算法也可以用于求解非线性SVM。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="testSet.txt" href="/citation/svm/testSet.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">testSet.txt</p><p class="url">/citation/svm/testSet.txt</p></div></a></div></div><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">fileName</span>):</span><br><span class="line">    dataMat = []</span><br><span class="line">    labelMat = []</span><br><span class="line">    fr = <span class="built_in">open</span>(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        dataMat.append([<span class="built_in">float</span>(lineArr[<span class="number">0</span>]), <span class="built_in">float</span>(lineArr[<span class="number">1</span>])])</span><br><span class="line">        labelMat.append(<span class="built_in">float</span>(lineArr[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectJrand</span>(<span class="params">i, m</span>):</span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span> j == i:</span><br><span class="line">        j = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, m))</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clipAlpha</span>(<span class="params">aj, H, L</span>):</span><br><span class="line">    <span class="keyword">if</span> aj &gt; H:</span><br><span class="line">        aj = H</span><br><span class="line">    <span class="keyword">if</span> L &gt; aj:</span><br><span class="line">        aj = L</span><br><span class="line">    <span class="keyword">return</span> aj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smoSimple</span>(<span class="params">dataMatIn, classLabels, C, toler, maxIter</span>):</span><br><span class="line">    dataMatrix = mat(dataMatIn)</span><br><span class="line">    labelMat = mat(classLabels).transpose()</span><br><span class="line">    m, n = shape(dataMatrix)</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    alphas = mat(zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">iter</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">iter</span> &lt; maxIter):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            fXi = <span class="built_in">float</span>(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[i, :].T)) + b</span><br><span class="line">            Ei = fXi - <span class="built_in">float</span>(labelMat[i])</span><br><span class="line">            <span class="keyword">if</span> ((labelMat[i] * Ei &lt; -toler) <span class="keyword">and</span> (alphas[i] &lt; C)) <span class="keyword">or</span> ((labelMat[i] * Ei &gt; toler) <span class="keyword">and</span> (alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">                j = selectJrand(i, m)</span><br><span class="line">                fXj = <span class="built_in">float</span>(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[j, :].T)) + b</span><br><span class="line">                Ej = fXj - <span class="built_in">float</span>(labelMat[j])</span><br><span class="line">                alphaIold = alphas[i].copy()</span><br><span class="line">                alphaJold = alphas[j].copy()</span><br><span class="line">                <span class="keyword">if</span> (labelMat[i] != labelMat[j]):</span><br><span class="line">                    L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">                    H = <span class="built_in">min</span>(C, C + alphas[j] - alphas[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">                    H = <span class="built_in">min</span>(C, alphas[j] + alphas[i])</span><br><span class="line">                <span class="keyword">if</span> L == H:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                eta = <span class="number">2.0</span> * dataMatrix[i, :] * dataMatrix[j, :].T - dataMatrix[i, :] * dataMatrix[i, :].T - dataMatrix[j, :] * dataMatrix[j, :].T</span><br><span class="line">                <span class="keyword">if</span> eta &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                alphas[j] -= labelMat[j] * (Ei - Ej) / eta</span><br><span class="line">                alphas[j] = clipAlpha(alphas[j], H, L)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                alphas[i] += labelMat[j] * labelMat[i] * (alphaJold - alphas[j])</span><br><span class="line">                b1 = b - Ei - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i, :] * dataMatrix[i, :].T - labelMat[j] * (alphas[j] - alphaJold) * dataMatrix[i, :] * dataMatrix[j, :].T</span><br><span class="line">                b2 = b - Ej - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i, :] * dataMatrix[j, :].T - labelMat[j] * (alphas[j] - alphaJold) * dataMatrix[j, :] * dataMatrix[j, :].T</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; alphas[i]) <span class="keyword">and</span> (C &gt; alphas[i]):</span><br><span class="line">                    b = b1</span><br><span class="line">                <span class="keyword">elif</span> (<span class="number">0</span> &lt; alphas[j]) <span class="keyword">and</span> (C &gt; alphas[j]):</span><br><span class="line">                    b = b2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b = (b1 + b2) / <span class="number">2.0</span></span><br><span class="line">                alphaPairsChanged += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (alphaPairsChanged == <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">iter</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> b, alphas</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcWs</span>(<span class="params">alphas, dataArr, classLabels</span>):</span><br><span class="line">    X = mat(dataArr)</span><br><span class="line">    labelMat = mat(classLabels).transpose()</span><br><span class="line">    m, n = shape(X)</span><br><span class="line">    w = zeros((n, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        w += multiply(alphas[i] * labelMat[i], X[i, :].T)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotfig_SVM</span>(<span class="params">xMat, yMat, ws, b, alphas</span>):</span><br><span class="line">    xMat = mat(xMat)</span><br><span class="line">    yMat = mat(yMat)</span><br><span class="line">    b = array(b)[<span class="number">0</span>]</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xMat[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>], xMat[:, <span class="number">1</span>].flatten().A[<span class="number">0</span>])</span><br><span class="line">    x = arange(-<span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-b - ws[<span class="number">0</span>, <span class="number">0</span>] * x) / ws[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(shape(yMat[<span class="number">0</span>, :])[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> yMat[<span class="number">0</span>, i] &gt; <span class="number">0</span>:</span><br><span class="line">            ax.plot(xMat[i, <span class="number">0</span>], xMat[i, <span class="number">1</span>], <span class="string">&#x27;cx&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ax.plot(xMat[i, <span class="number">0</span>], xMat[i, <span class="number">1</span>], <span class="string">&#x27;kp&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> alphas[i] &gt; <span class="number">0.0</span>:</span><br><span class="line">            ax.plot(xMat[i, <span class="number">0</span>], xMat[i, <span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dataArr, labelArr = loadDataSet(<span class="string">&#x27;6.SVM/testSet.txt&#x27;</span>)</span><br><span class="line">    b, alphas = smoSimple(dataArr, labelArr, <span class="number">0.6</span>, <span class="number">0.001</span>, <span class="number">40</span>)</span><br><span class="line">    ws = calcWs(alphas, dataArr, labelArr)</span><br><span class="line">    plotfig_SVM(dataArr, labelArr, ws, b, alphas)</span><br></pre></td></tr></table></figure><div class="note info"><p>来源于 <a href="https://www.apachecn.org/">ApacheCN</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> SVM </tag>
            
            <tag> Lagrange Multiplier Method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression算法简析</title>
      <link href="/2023/07/31/Logistic%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/07/31/Logistic%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Logistic-Regression算法简析"><a href="#Logistic-Regression算法简析" class="headerlink" title="Logistic Regression算法简析"></a>Logistic Regression算法简析</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Logistic Regression是一种广义线性模型，用于处理二分类问题。它通过建立一个线性模型，并使用逻辑函数（sigmoid函数）将线性输出转换为概率值，从而对输入数据进行分类。</p><p>模型假设：</p><ul><li>假设输入特征和输出类别之间存在线性关系。</li><li>用sigmoid函数将线性输出映射到0和1之间的概率值。</li></ul><p><strong>sigmoid函数：</strong><br>sigmoid函数（也称为Logistic函数）定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigmoid(z) = 1 / (1 + exp(-z))</span><br></pre></td></tr></table></figure><p>其中z是输入的线性输出。</p><p><strong>梯度提升与梯度下降</strong></p><p>梯度提升（Gradient Boosting）和梯度下降（Gradient Descent）是两个不同的机器学习概念，虽然它们都涉及梯度（Gradient）这一术语，但在方法和应用上有很大的区别。</p><p><strong>梯度提升（Gradient Boosting）：</strong><br>梯度提升是一种集成学习技术，它通过将多个弱学习器（通常是决策树）进行串行训练，每次训练都尝试纠正前一轮训练中模型的错误，从而逐步提高整体模型的性能。这种技术通过迭代的方式构建一个强大的集成模型，每一步都关注先前模型的残差（预测值与真实值之间的差异），然后训练一个新的模型来纠正这些残差。梯度提升的主要代表算法是Gradient Boosting Machine（GBM）和XGBoost。</p><p><strong>梯度下降（Gradient Descent）：</strong><br>梯度下降是一种用于优化目标函数的迭代优化算法。它的主要目标是在参数空间中找到目标函数的最小值点（或最大值点）。在机器学习中，这通常涉及到最小化损失函数，例如平方误差损失或交叉熵损失等。梯度下降的基本思想是通过计算目标函数关于参数的梯度（导数），朝着梯度的反方向调整参数，以使目标函数值逐步减小。梯度下降有多种变种，如批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）和小批量梯度下降（Mini-batch Gradient Descent）等。</p><p><strong>主要区别：</strong></p><ul><li>梯度提升是一种集成学习算法，用于构建强大的预测模型，通过串行训练多个弱学习器来逐步提高整体模型的性能。</li><li>梯度下降是一种优化算法，用于找到目标函数的最小值点，通过计算梯度并朝着梯度的反方向调整参数来实现优化。</li></ul><p>尽管它们涉及到梯度这个共同点，但是梯度提升和梯度下降是两个不同的概念，分别用于解决集成学习和优化问题。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><em>优点</em>：</p><ul><li>实现简单，计算效率高。</li><li>可解释性强，能够看到每个特征的权重对预测的影响。</li><li>在特征空间较简单的问题上表现良好。</li></ul><p><em>缺点</em>：</p><ul><li>不能处理复杂的数据关系，对于非线性问题表现不佳。</li><li>对异常值比较敏感，容易受到噪声的影响。</li><li>不能直接处理多分类问题，通常需要使用一对多（One-vs-Rest）或Softmax等策略来扩展到多分类。</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Logistic Regression在许多领域有广泛的应用，尤其在二分类问题中常见，如：</p><ul><li>垃圾邮件分类：判断一封邮件是否为垃圾邮件。</li><li>金融风险预测：预测客户是否有违约风险。</li><li>医学诊断：判断患者是否患有某种疾病。</li><li>自然语言处理：情感分析，判断文本的情感倾向。</li></ul><h2 id="涉及到的数学公式"><a href="#涉及到的数学公式" class="headerlink" title="涉及到的数学公式"></a>涉及到的数学公式</h2><ol><li><p>假设函数：<br> 逻辑回归的假设函数表示为：<br> $$ h_\theta(x) &#x3D; \frac{1}{1 + e^{-\theta^T x}} $$</p><p> 其中，</p><ul><li>$ h_\theta(x) $ 是根据输入特征 $ x $ 和模型参数 $ \theta $ 得到的预测值（类别为1的概率）。</li><li>$ \theta $ 是模型的参数向量。</li><li>$ \theta^T $ 表示 $ \theta $ 的转置。</li><li>$ e $ 是自然对数的底数。</li></ul></li><li><p>损失函数：<br>逻辑回归使用交叉熵损失函数来衡量预测值与真实类别之间的差异。对于二分类问题，交叉熵损失函数表示为：<br>$$ J(\theta) &#x3D; -\frac{1}{m} \sum_{i&#x3D;1}^{m} \left[ y^{(i)} \log(h_\theta(x^{(i)})) + (1 - y^{(i)}) \log(1 - h_\theta(x^{(i)})) \right] $$</p><p> 其中，</p><ul><li>$ J(\theta) $ 是损失函数。</li><li>$ m $ 是训练样本的数量。</li><li>$ x^{(i)} $ 表示第 $ i $ 个训练样本的特征向量。</li><li>$ y^{(i)} $ 是第 $ i $ 个训练样本的真实类别（0或1）。</li><li>$ h_\theta(x^{(i)}) $ 是根据假设函数预测的类别为1的概率。</li></ul></li><li><p>梯度下降更新规则：<br>梯度下降的目标是最小化损失函数 $ J(\theta) $。为了更新模型参数 $ \theta $，我们需要计算损失函数对于每个参数的偏导数，然后根据梯度的方向和学习率来更新参数。更新规则如下：<br>$$ \theta_j :&#x3D; \theta_j - \alpha \frac{\partial J(\theta)}{\partial \theta_j} $$</p><p> 其中，</p><ul><li>$ \alpha $ 是学习率（控制参数更新的步长）。</li><li>$ \frac{\partial J(\theta)}{\partial \theta_j} $ 是损失函数对于参数 $ \theta_j $ 的偏导数。</li></ul><p> 对于逻辑回归，梯度下降的具体更新规则是：<br> $$ \theta_j :&#x3D; \theta_j - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} \left( h_\theta(x^{(i)}) - y^{(i)} \right) x_j^{(i)} $$</p><p> 其中，$ x_j^{(i)} $ 是第 $ i $ 个训练样本的第 $ j $ 个特征值。</p></li></ol><p>通过不断迭代更新参数，梯度下降会使损失函数逐渐减小，从而找到最优的模型参数，使得逻辑回归模型能够较好地拟合训练数据并作出准确的预测。</p><h2 id="案例：从疝气病症预测病马的死亡率"><a href="#案例：从疝气病症预测病马的死亡率" class="headerlink" title="案例：从疝气病症预测病马的死亡率"></a>案例：从疝气病症预测病马的死亡率</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="HorseColicTest.txt" href="/citation/HorseColic/HorseColicTest.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">HorseColicTest.txt</p><p class="url">/citation/HorseColic/HorseColicTest.txt</p></div></a></div><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="HorseColicTraining.txt" href="/citation/HorseColic/HorseColicTraining.txt"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">HorseColicTraining.txt</p><p class="url">/citation/HorseColic/HorseColicTraining.txt</p></div></a></div></div><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -------从疝气病症预测病马的死亡率------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">colic_test</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    打开测试集和训练集，并对数据进行格式化处理,其实最主要的的部分，比如缺失值的补充（真的需要学会的），人家已经做了</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    f_train = <span class="built_in">open</span>(<span class="string">&#x27;5.Logistic/HorseColicTraining.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    f_test = <span class="built_in">open</span>(<span class="string">&#x27;5.Logistic/HorseColicTest.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    training_set = []</span><br><span class="line">    training_labels = []</span><br><span class="line">    <span class="comment"># 解析训练数据集中的数据特征和Labels</span></span><br><span class="line">    <span class="comment"># trainingSet 中存储训练数据集的特征，trainingLabels 存储训练数据集的样本对应的分类标签</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_train.readlines():</span><br><span class="line">        curr_line = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_line) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span>    <span class="comment"># 这里如果就一个空的元素，则跳过本次循环</span></span><br><span class="line">        line_arr = [<span class="built_in">float</span>(curr_line[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>)]</span><br><span class="line">        training_set.append(line_arr)</span><br><span class="line">        training_labels.append(<span class="built_in">float</span>(curr_line[<span class="number">21</span>]))</span><br><span class="line">    <span class="comment"># 使用 改进后的 随机梯度下降算法 求得在此数据集上的最佳回归系数 trainWeights</span></span><br><span class="line">    train_weights = stoc_grad_ascent1(np.array(training_set), training_labels, <span class="number">500</span>)</span><br><span class="line">    error_count = <span class="number">0</span></span><br><span class="line">    num_test_vec = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 读取 测试数据集 进行测试，计算分类错误的样本条数和最终的错误率</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_test.readlines():</span><br><span class="line">        num_test_vec += <span class="number">1</span></span><br><span class="line">        curr_line = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_line) == <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">continue</span>    <span class="comment"># 这里如果就一个空的元素，则跳过本次循环</span></span><br><span class="line">        line_arr = [<span class="built_in">float</span>(curr_line[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>)]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(classify_vector(np.array(line_arr), train_weights)) != <span class="built_in">int</span>(curr_line[<span class="number">21</span>]):</span><br><span class="line">            error_count += <span class="number">1</span></span><br><span class="line">    error_rate = error_count / num_test_vec</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the error rate is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(error_rate))</span><br><span class="line">    <span class="keyword">return</span> error_rate</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stoc_grad_ascent1</span>(<span class="params">data_mat, class_labels, num_iter=<span class="number">150</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    改进版的随机梯度上升，使用随机的一个样本来更新回归系数</span></span><br><span class="line"><span class="string">    :param data_mat: 输入数据的数据特征（除去最后一列）,ndarray</span></span><br><span class="line"><span class="string">    :param class_labels: 输入数据的类别标签（最后一列数据</span></span><br><span class="line"><span class="string">    :param num_iter: 迭代次数</span></span><br><span class="line"><span class="string">    :return: 得到的最佳回归系数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m, n = np.shape(data_mat)</span><br><span class="line">    weights = np.ones(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_iter):</span><br><span class="line">        <span class="comment"># 这里必须要用list，不然后面的del没法使用</span></span><br><span class="line">        data_index = <span class="built_in">list</span>(<span class="built_in">range</span>(m))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># i和j的不断增大，导致alpha的值不断减少，但是不为0</span></span><br><span class="line">            alpha = <span class="number">4</span> / (<span class="number">1.0</span> + j + i) + <span class="number">0.01</span></span><br><span class="line">            <span class="comment"># 随机产生一个 0～len()之间的一个值</span></span><br><span class="line">            <span class="comment"># random.uniform(x, y) 方法将随机生成下一个实数，它在[x,y]范围内,x是这个范围内的最小值，y是这个范围内的最大值。</span></span><br><span class="line">            rand_index = <span class="built_in">int</span>(np.random.uniform(<span class="number">0</span>, <span class="built_in">len</span>(data_index)))</span><br><span class="line">            h = sigmoid(np.<span class="built_in">sum</span>(data_mat[data_index[rand_index]] * weights))</span><br><span class="line">            error = class_labels[data_index[rand_index]] - h</span><br><span class="line">            weights = weights + alpha * error * data_mat[data_index[rand_index]]</span><br><span class="line">            <span class="keyword">del</span>(data_index[rand_index])</span><br><span class="line">    <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 这里其实非常有必要解释一下，会出现的错误 RuntimeWarning: overflow encountered in exp</span></span><br><span class="line">    <span class="comment"># 这里是因为我们输入的有的 x 实在是太小了，比如 -6000之类的，那么计算一个数字 np.exp(6000)这个结果太大了，没法表示，所以就溢出了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify_vector</span>(<span class="params">in_x, weights</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最终的分类函数，根据回归系数和特征向量来计算 Sigmoid 的值，大于0.5函数返回1，否则返回0</span></span><br><span class="line"><span class="string">    :param in_x: 特征向量，features</span></span><br><span class="line"><span class="string">    :param weights: 根据梯度下降/随机梯度下降 计算得到的回归系数</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># print(np.sum(in_x * weights))</span></span><br><span class="line">    prob = sigmoid(np.<span class="built_in">sum</span>(in_x * weights))</span><br><span class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    colic_test()</span><br></pre></td></tr></table></figure><div class="note info"><p>来源于 <a href="https://www.apachecn.org/">ApacheCN</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Logistic Regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯算法简析</title>
      <link href="/2023/07/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/07/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素贝叶斯算法简析"><a href="#朴素贝叶斯算法简析" class="headerlink" title="朴素贝叶斯算法简析"></a>朴素贝叶斯算法简析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>朴素贝叶斯算法是一种常见的分类算法，它基于贝叶斯定理和特征间的“朴素”独立性假设。该算法常被用于文本分类、垃圾邮件过滤、情感分析等自然语言处理任务，以及其他许多机器学习问题。</p><p>这里简要解释一下朴素贝叶斯算法的基本原理：</p><ol><li><p>贝叶斯定理：<br>贝叶斯定理是概率论中的一个重要理论，用于计算在已知一些条件的情况下，某事件的概率。对于分类问题，贝叶斯定理可以表示为：<br>$$ P(y|x) &#x3D; \frac{P(x|y) \cdot P(y)}{P(x)} $$</p><blockquote><ul><li>$P(y|x)$：这是在给定特征 $x$ 的条件下，类别 $y$ 的概率。在分类问题中，我们希望找到使得 $P(y|x)$ 最大化的类别 $y$，即为预测的类别。</li><li>$P(x|y)$：这是在类别 $y$ 已知的情况下，特征 $x$ 出现的概率。在朴素贝叶斯算法中，我们通过训练数据来估计这些概率。</li><li>$P(y)$：这是类别 $y$ 的先验概率，即在不考虑特征 $x$ 的情况下，类别 $y$ 出现的概率。在训练阶段，我们也可以通过训练数据来估计这些先验概率。</li><li>$P(x)$：这是特征 $x$ 的先验概率，即在不考虑类别 $y$ 的情况下，特征 $x$ 出现的概率。在预测阶段，这个值通常可以忽略，因为它在每个类别的计算中都是相同的，并且对于最大化后验概率并不影响结果。<br>在朴素贝叶斯算法中，我们的目标是预测一个新的样本的类别 $y_{\text{pred}}$，它的计算可以通过找到使得 $P(y|x)$ 最大化的类别 $y$ 来实现，即：<br>$$ y_{\text{pred}} &#x3D; \underset{y}{\text{argmax}} : P(y|x) $$<br>根据贝叶斯定理的公式，可以将 $P(y|x)$ 表示为：<br>$$ P(y|x) &#x3D; \frac{P(x|y) \cdot P(y)}{P(x)} $$<br>然后通过计算每个类别 $y$ 的后验概率 $P(y|x)$ 并选择最大概率的类别作为预测结果。</li></ul></blockquote></li><li><p>朴素独立性假设：<br>为了简化计算，朴素贝叶斯算法假设特征之间相互独立，即给定类别 $y$ 的情况下，每个特征 $x_i$ 的出现与其他特征无关。虽然这个假设在现实中并不总是成立，但在许多实际问题中，朴素贝叶斯仍然表现出色。</p></li><li><p>训练阶段：<br>在训练阶段，朴素贝叶斯算法从已标记的训练数据中学习类别和特征之间的条件概率。对于每个类别 $y$，算法计算每个特征 $x_i$ 在该类别下出现的概率 $P(x_i|y)$。</p></li><li><p>预测阶段：<br>在预测阶段，给定一个新的样本数据的特征 $x_{\text{new}}$，朴素贝叶斯算法通过以下方式来预测它的类别 $y_{\text{pred}}$：<br>$$ y_{\text{pred}} &#x3D; \underset{y}{\text{argmax}} : P(y) \cdot \prod_{i} P(x_{\text{new},i}|y) $$<br>其中，$P(y)$ 是类别的先验概率，$\prod_{i} P(x_{\text{new},i}|y)$ 是根据朴素独立性假设计算的给定类别下所有特征概率的乘积。</p></li></ol><p>总结来说，朴素贝叶斯算法是一种简单且高效的分类算法，尤其适用于特征维度较高的问题。虽然它在某些复杂任务上可能表现不如其他更复杂的算法，但在许多实际应用中，它仍然是一个非常实用的选择。</p><h2 id="案例：屏蔽社区留言板的侮辱性言论"><a href="#案例：屏蔽社区留言板的侮辱性言论" class="headerlink" title="案例：屏蔽社区留言板的侮辱性言论"></a>案例：屏蔽社区留言板的侮辱性言论</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------项目案例1: 屏蔽社区留言板的侮辱性言论------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_set</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建数据集,都是假的 fake data set </span></span><br><span class="line"><span class="string">    :return: 单词列表posting_list, 所属类别class_vec</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posting_list = [</span><br><span class="line">        [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;gar e&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]]</span><br><span class="line">    class_vec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 1 is 侮辱性的文字, 0 is not</span></span><br><span class="line">    <span class="keyword">return</span> posting_list, class_vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_vocab_list</span>(<span class="params">data_set</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取所有单词的集合</span></span><br><span class="line"><span class="string">    :param data_set: 数据集</span></span><br><span class="line"><span class="string">    :return: 所有单词的集合(即不含重复元素的单词列表)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vocab_set = <span class="built_in">set</span>()  <span class="comment"># create empty set</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data_set:</span><br><span class="line">        <span class="comment"># | 求两个集合的并集</span></span><br><span class="line">        vocab_set = vocab_set | <span class="built_in">set</span>(item)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocab_set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_of_words2vec</span>(<span class="params">vocab_list, input_set</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    遍历查看该单词是否出现，出现该单词则将该单词置1</span></span><br><span class="line"><span class="string">    :param vocab_list: 所有单词集合列表</span></span><br><span class="line"><span class="string">    :param input_set: 输入数据集</span></span><br><span class="line"><span class="string">    :return: 匹配列表[0,1,0,1...]，其中 1与0 表示词汇表中的单词是否出现在输入的数据集中</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建一个和词汇表等长的向量，并将其元素都设置为0</span></span><br><span class="line">    result = [<span class="number">0</span>] * <span class="built_in">len</span>(vocab_list)</span><br><span class="line">    <span class="comment"># 遍历文档中的所有单词，如果出现了词汇表中的单词，则将输出的文档向量中的对应值设为1</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> input_set:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocab_list:</span><br><span class="line">            result[vocab_list.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 这个后面应该注释掉，因为对你没什么用，这只是为了辅助调试的</span></span><br><span class="line">            <span class="comment"># print(&#x27;the word: &#123;&#125; is not in my vocabulary&#x27;.format(word))</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_train_naive_bayes</span>(<span class="params">train_mat, train_category</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    朴素贝叶斯分类原版</span></span><br><span class="line"><span class="string">    :param train_mat:  type is ndarray</span></span><br><span class="line"><span class="string">                    总的输入文本，大致是 [[0,1,0,1], [], []]</span></span><br><span class="line"><span class="string">    :param train_category: 文件对应的类别分类， [0, 1, 0],</span></span><br><span class="line"><span class="string">                            列表的长度应该等于上面那个输入文本的长度</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    train_doc_num = <span class="built_in">len</span>(train_mat)</span><br><span class="line">    words_num = <span class="built_in">len</span>(train_mat[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 因为侮辱性的被标记为了1， 所以只要把他们相加就可以得到侮辱性的有多少</span></span><br><span class="line">    <span class="comment"># 侮辱性文件的出现概率，即train_category中所有的1的个数，</span></span><br><span class="line">    <span class="comment"># 代表的就是多少个侮辱性文件，与文件的总数相除就得到了侮辱性文件的出现概率</span></span><br><span class="line">    pos_abusive = np.<span class="built_in">sum</span>(train_category) / train_doc_num</span><br><span class="line">    <span class="comment"># 单词出现的次数</span></span><br><span class="line">    <span class="comment"># 原版</span></span><br><span class="line">    p0num = np.zeros(words_num)</span><br><span class="line">    p1num = np.zeros(words_num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 整个数据集单词出现的次数（原来是0，后面改成2了）</span></span><br><span class="line">    p0num_all = <span class="number">0</span></span><br><span class="line">    p1num_all = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_doc_num):</span><br><span class="line">        <span class="comment"># 遍历所有的文件，如果是侮辱性文件，就计算此侮辱性文件中出现的侮辱性单词的个数</span></span><br><span class="line">        <span class="keyword">if</span> train_category[i] == <span class="number">1</span>:</span><br><span class="line">            p1num += train_mat[i]</span><br><span class="line">            p1num_all += np.<span class="built_in">sum</span>(train_mat[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0num += train_mat[i]</span><br><span class="line">            p0num_all += np.<span class="built_in">sum</span>(train_mat[i])</span><br><span class="line">    <span class="comment"># 后面需要改成改成取 log 函数</span></span><br><span class="line">    p1vec = p1num / p1num_all</span><br><span class="line">    p0vec = p0num / p0num_all</span><br><span class="line">    <span class="keyword">return</span> p0vec, p1vec, pos_abusive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_naive_bayes</span>(<span class="params">train_mat, train_category</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    朴素贝叶斯分类修正版，　注意和原来的对比，为什么这么做可以查看书</span></span><br><span class="line"><span class="string">    :param train_mat:  type is ndarray</span></span><br><span class="line"><span class="string">                    总的输入文本，大致是 [[0,1,0,1], [], []]</span></span><br><span class="line"><span class="string">    :param train_category: 文件对应的类别分类， [0, 1, 0],</span></span><br><span class="line"><span class="string">                            列表的长度应该等于上面那个输入文本的长度</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    train_doc_num = <span class="built_in">len</span>(train_mat)</span><br><span class="line">    words_num = <span class="built_in">len</span>(train_mat[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 因为侮辱性的被标记为了1， 所以只要把他们相加就可以得到侮辱性的有多少</span></span><br><span class="line">    <span class="comment"># 侮辱性文件的出现概率，即train_category中所有的1的个数，</span></span><br><span class="line">    <span class="comment"># 代表的就是多少个侮辱性文件，与文件的总数相除就得到了侮辱性文件的出现概率</span></span><br><span class="line">    pos_abusive = np.<span class="built_in">sum</span>(train_category) / train_doc_num</span><br><span class="line">    <span class="comment"># 单词出现的次数</span></span><br><span class="line">    <span class="comment"># 原版，变成ones是修改版，这是为了防止数字过小溢出</span></span><br><span class="line">    <span class="comment"># p0num = np.zeros(words_num)</span></span><br><span class="line">    <span class="comment"># p1num = np.zeros(words_num)</span></span><br><span class="line">    p0num = np.ones(words_num)</span><br><span class="line">    p1num = np.ones(words_num)</span><br><span class="line">    <span class="comment"># 整个数据集单词出现的次数（原来是0，后面改成2了）</span></span><br><span class="line">    p0num_all = <span class="number">2.0</span></span><br><span class="line">    p1num_all = <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(train_doc_num):</span><br><span class="line">        <span class="comment"># 遍历所有的文件，如果是侮辱性文件，就计算此侮辱性文件中出现的侮辱性单词的个数</span></span><br><span class="line">        <span class="keyword">if</span> train_category[i] == <span class="number">1</span>:</span><br><span class="line">            p1num += train_mat[i]</span><br><span class="line">            p1num_all += np.<span class="built_in">sum</span>(train_mat[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0num += train_mat[i]</span><br><span class="line">            p0num_all += np.<span class="built_in">sum</span>(train_mat[i])</span><br><span class="line">    <span class="comment"># 后面改成取 log 函数</span></span><br><span class="line">    p1vec = np.log(p1num / p1num_all)</span><br><span class="line">    p0vec = np.log(p0num / p0num_all)</span><br><span class="line">    <span class="keyword">return</span> p0vec, p1vec, pos_abusive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify_naive_bayes</span>(<span class="params">vec2classify, p0vec, p1vec, p_class1</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用算法: </span></span><br><span class="line"><span class="string">        # 将乘法转换为加法</span></span><br><span class="line"><span class="string">        乘法: P(C|F1F2...Fn) = P(F1F2...Fn|C)P(C)/P(F1F2...Fn)</span></span><br><span class="line"><span class="string">        加法: P(F1|C)*P(F2|C)....P(Fn|C)P(C) -&gt; log(P(F1|C))+log(P(F2|C))+....+log(P(Fn|C))+log(P(C))</span></span><br><span class="line"><span class="string">    :param vec2classify: 待测数据[0,1,1,1,1...]，即要分类的向量</span></span><br><span class="line"><span class="string">    :param p0vec: 类别0，即正常文档的[log(P(F1|C0)),log(P(F2|C0)),log(P(F3|C0)),log(P(F4|C0)),log(P(F5|C0))....]列表</span></span><br><span class="line"><span class="string">    :param p1vec: 类别1，即侮辱性文档的[log(P(F1|C1)),log(P(F2|C1)),log(P(F3|C1)),log(P(F4|C1)),log(P(F5|C1))....]列表</span></span><br><span class="line"><span class="string">    :param p_class1: 类别1，侮辱性文件的出现概率</span></span><br><span class="line"><span class="string">    :return: 类别1 or 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算公式  log(P(F1|C))+log(P(F2|C))+....+log(P(Fn|C))+log(P(C))</span></span><br><span class="line">    <span class="comment"># 使用 NumPy 数组来计算两个向量相乘的结果，这里的相乘是指对应元素相乘，即先将两个向量中的第一个元素相乘，然后将第2个元素相乘，以此类推。</span></span><br><span class="line">    <span class="comment"># 我的理解是: 这里的 vec2Classify * p1Vec 的意思就是将每个词与其对应的概率相关联起来</span></span><br><span class="line">    <span class="comment"># 可以理解为 1.单词在词汇表中的条件下，文件是good 类别的概率 也可以理解为 2.在整个空间下，文件既在词汇表中又是good类别的概率</span></span><br><span class="line">    p1 = np.<span class="built_in">sum</span>(vec2classify * p1vec) + np.log(p_class1)</span><br><span class="line">    p0 = np.<span class="built_in">sum</span>(vec2classify * p0vec) + np.log(<span class="number">1</span> - p_class1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bag_words2vec</span>(<span class="params">vocab_list, input_set</span>):</span><br><span class="line">    <span class="comment"># 注意和原来的做对比</span></span><br><span class="line">    result = [<span class="number">0</span>] * <span class="built_in">len</span>(vocab_list)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> input_set:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocab_list:</span><br><span class="line">            result[vocab_list.index(word)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;the word: &#123;&#125; is not in my vocabulary&#x27;</span>.<span class="built_in">format</span>(word))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testing_naive_bayes</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    测试朴素贝叶斯算法</span></span><br><span class="line"><span class="string">    :return: no return </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 加载数据集</span></span><br><span class="line">    list_post, list_classes = load_data_set()</span><br><span class="line">    <span class="comment"># 2. 创建单词集合</span></span><br><span class="line">    vocab_list = create_vocab_list(list_post)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算单词是否出现并创建数据矩阵</span></span><br><span class="line">    train_mat = []</span><br><span class="line">    <span class="keyword">for</span> post_in <span class="keyword">in</span> list_post:</span><br><span class="line">        train_mat.append(</span><br><span class="line">            <span class="comment"># 返回m*len(vocab_list)的矩阵， 记录的都是0，1信息</span></span><br><span class="line">            <span class="comment"># 其实就是那个东西的句子向量（就是data_set里面每一行,也不算句子吧)</span></span><br><span class="line">            set_of_words2vec(vocab_list, post_in)</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># 4. 训练数据</span></span><br><span class="line">    p0v, p1v, p_abusive = train_naive_bayes(np.array(train_mat), np.array(list_classes))</span><br><span class="line">    <span class="comment"># 5. 测试数据</span></span><br><span class="line">    test_one = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">    test_one_doc = np.array(set_of_words2vec(vocab_list, test_one))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the result is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(classify_naive_bayes(test_one_doc, p0v, p1v, p_abusive)))</span><br><span class="line">    test_two = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">    test_two_doc = np.array(set_of_words2vec(vocab_list, test_two))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;the result is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(classify_naive_bayes(test_two_doc, p0v, p1v, p_abusive)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    testing_naive_bayes()</span><br></pre></td></tr></table></figure><div class="note info"><p>来源于 <a href="https://www.apachecn.org/">ApacheCN</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Naive Bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DecisionTree算法简析</title>
      <link href="/2023/07/29/DecisionTree%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/07/29/DecisionTree%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="DecisionTree算法简析"><a href="#DecisionTree算法简析" class="headerlink" title="DecisionTree算法简析"></a>DecisionTree算法简析</h1><p>决策树（Decision Tree）是一种常见的机器学习算法，它可用于分类和回归任务。决策树通过对数据进行一系列逻辑判断，构建一个树状结构来进行决策。在分类问题中，决策树用于预测输入数据所属的类别；在回归问题中，它用于预测连续型的输出值。</p><p>决策树的构建过程基于训练数据，通过选择最佳的特征来进行节点分裂，直到达到某个停止条件。构建好的决策树能够提供清晰的决策路径，易于解释，并且可以很好地处理非线性关系。</p><p>以下是决策树算法的简要分析：</p><ol><li><p>特征选择：决策树的核心是选择最佳的特征来进行节点的分裂。通常采用信息增益、信息增益比、基尼不纯度等指标来评估特征的重要性，选择能够最好地分隔数据的特征。</p></li><li><p>节点分裂：决策树根据特征的取值将数据划分为不同的子集。分裂过程持续进行，直到达到停止条件，例如达到最大树深度、子集中的样本数量过少等。</p></li><li><p>树的构建：决策树的构建是一个递归的过程，从根节点开始，根据特征选择和节点分裂的原则逐步构建分支，直到生成一个完整的决策树。</p></li><li><p>剪枝：构建好的决策树可能存在过拟合问题（对训练数据过度拟合）。剪枝是一种通过去除一些不重要的节点来减少复杂度、提高泛化能力的技术。</p></li><li><p>预测：用新的数据样本在决策树上进行遍历，根据叶节点的类别（分类问题）或预测值（回归问题）进行预测。</p></li></ol><p>决策树算法的优点包括易于解释、处理非线性关系和对缺失值不敏感。然而，它也有一些缺点，如容易过拟合、对噪声敏感等。为了改进决策树算法，人们发展了一些变种，如随机森林（Random Forest）和梯度提升决策树（Gradient Boosting Decision Tree），以提高模型的性能和鲁棒性。</p><p>总的来说，决策树是一种强大的算法，特别适用于解决分类和回归问题，同时也是学习机器学习算法基础的重要内容之一。</p><h3 id="设计到的数学公式"><a href="#设计到的数学公式" class="headerlink" title="设计到的数学公式"></a>设计到的数学公式</h3><p>当涉及到决策树及其相关算法时，可能会使用以下公式。下面是这些公式的使用示例，使用MathJax进行表示：</p><ol><li><p><strong>信息熵（Entropy）</strong>：衡量数据集的混乱程度，对于分类问题的特征选择很重要。</p><p> $$<br> H(X) &#x3D; -\sum_{i&#x3D;1}^{n} p(x_i) \log(p(x_i))<br> $$</p><p> 其中，$H(X)$表示数据集$X$的信息熵，$p(x_i)$是数据集$X$中类别为$x_i$的样本占比。</p></li><li><p><strong>信息增益（Information Gain）</strong>：表示使用某个特征对数据集进行划分所获得的信息熵减少的程度，用于特征选择。</p><p> $$<br> \text{Information Gain}(X, \text{feature}) &#x3D; H(X) - \sum_{v \in \text{values}(\text{feature})} \frac{|X_v|}{|X|} H(X_v)<br> $$</p><p> 其中，$H(X)$表示数据集$X$的信息熵，$X_v$表示使用特征$\text{feature}$中取值为$v$的样本子集，$\text{values}(\text{feature})$表示特征$\text{feature}$的所有取值。</p></li><li><p><strong>基尼不纯度（Gini Impurity）</strong>：另一种衡量数据集混乱程度的方法，用于特征选择。</p><p> $$<br> \text{Gini}(X) &#x3D; 1 - \sum_{i&#x3D;1}^{n} p(x_i)^2<br> $$</p><p> 其中，$\text{Gini}(X)$表示数据集$X$的基尼不纯度，$p(x_i)$是数据集$X$中类别为$x_i$的样本占比。</p></li><li><p><strong>回归树的均方误差（Mean Squared Error，MSE）</strong>：回归树使用的损失函数，用于衡量预测值与实际值之间的差异。<br> $$<br> \text{MSE}(X) &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \bar{y})^2<br> $$</p><p> 其中，$\text{MSE}(X)$表示数据集$X$的均方误差，$n$是样本数量，$y_i$是第$i$个样本的实际输出值，$\bar{y}$是样本输出值的均值。</p></li><li><p><strong>决策树的预测</strong>：对于回归树，预测值为叶节点上训练样本输出值的平均值；对于分类树，预测值为叶节点上出现最频繁的类别。</p></li></ol><h3 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h3><ol><li><p><strong>数据准备</strong>：</p><ul><li>收集数据集：获取用于训练和测试的数据集。</li><li>数据清洗：处理缺失值、异常值等数据问题，确保数据质量。</li><li>数据划分：将数据集划分为训练集和测试集，用于模型的训练和评估。</li></ul></li><li><p><strong>特征选择</strong>：</p><ul><li>根据具体任务和特征的性质，选择合适的特征用于构建决策树。</li><li>使用信息增益、基尼不纯度等指标评估特征的重要性，选择最佳的划分特征。</li></ul></li><li><p><strong>构建决策树</strong>：</p><ul><li>从根节点开始，根据选定的特征选择标准进行节点分裂，生成子节点。</li><li>递归地对子节点进行分裂，直到满足停止条件，例如达到最大深度或节点样本数量过少。</li></ul></li><li><p><strong>剪枝</strong>（可选）：</p><ul><li>构建好的决策树可能对训练数据过拟合，剪枝是一种降低过拟合风险的技术。</li><li>可以采用预剪枝（在构建树的过程中进行剪枝）或后剪枝（构建完整树后再进行剪枝）。</li></ul></li><li><p><strong>预测</strong>：</p><ul><li>使用训练好的决策树对新数据进行预测。</li><li>对于分类问题，根据决策树的分支和叶节点的类别进行分类预测。</li><li>对于回归问题，根据决策树的叶节点上训练样本输出值的平均值进行回归预测。</li></ul></li><li><p><strong>模型评估</strong>：</p><ul><li>使用测试集对训练好的决策树进行性能评估，可以使用准确率（分类问题）或均方误差（回归问题）等指标。</li></ul></li><li><p><strong>优化</strong>：</p><ul><li>根据模型评估结果，可以调整决策树的参数，选择不同的特征，或尝试其他优化方法，以提高模型性能。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>将训练好的决策树应用于实际问题中，进行分类、回归等预测任务。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> decisionTreePlot <span class="keyword">as</span> dtPlot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.myTree = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcShannonEnt</span>(<span class="params">self, dataSet</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算给定数据集的香农熵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">        labelCounts = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">            currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">                labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">            labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        shannonEnt = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">            prob = <span class="built_in">float</span>(labelCounts[key]) / numEntries</span><br><span class="line">            shannonEnt -= prob * log(prob, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shannonEnt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitDataSet</span>(<span class="params">self, dataSet, index, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分数据集</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        retDataSet = []</span><br><span class="line">        <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">            <span class="keyword">if</span> featVec[index] == value:</span><br><span class="line">                reducedFeatVec = featVec[:index]</span><br><span class="line">                reducedFeatVec.extend(featVec[index + <span class="number">1</span>:])</span><br><span class="line">                retDataSet.append(reducedFeatVec)</span><br><span class="line">        <span class="keyword">return</span> retDataSet</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chooseBestFeatureToSplit</span>(<span class="params">self, dataSet</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择切分数据集的最佳特征</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        baseEntropy = self.calcShannonEnt(dataSet)</span><br><span class="line">        bestInfoGain, bestFeature = <span class="number">0.0</span>, -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">            featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">            uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">            newEntropy = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">                subDataSet = self.splitDataSet(dataSet, i, value)</span><br><span class="line">                prob = <span class="built_in">len</span>(subDataSet) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">                newEntropy += prob * self.calcShannonEnt(subDataSet)</span><br><span class="line"></span><br><span class="line">            infoGain = baseEntropy - newEntropy</span><br><span class="line">            <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">                bestInfoGain = infoGain</span><br><span class="line">                bestFeature = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bestFeature</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityCnt</span>(<span class="params">self, classList</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选择出现次数最多的一个结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        classCount = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">            <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">                classCount[vote] = <span class="number">0</span></span><br><span class="line">            classCount[vote] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">self, dataSet, labels</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        创建决策树</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">            <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.majorityCnt(classList)</span><br><span class="line"></span><br><span class="line">        bestFeat = self.chooseBestFeatureToSplit(dataSet)</span><br><span class="line">        bestFeatLabel = labels[bestFeat]</span><br><span class="line">        myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">del</span> (labels[bestFeat])</span><br><span class="line"></span><br><span class="line">        featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subLabels = labels[:]</span><br><span class="line">            myTree[bestFeatLabel][value] = self.createTree(self.splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line"></span><br><span class="line">        self.myTree = myTree</span><br><span class="line">        <span class="keyword">return</span> self.myTree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">self, inputTree, featLabels, testVec</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        对新数据进行分类</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        firstStr = <span class="built_in">list</span>(inputTree.keys())[<span class="number">0</span>]</span><br><span class="line">        secondDict = inputTree[firstStr]</span><br><span class="line">        featIndex = featLabels.index(firstStr)</span><br><span class="line">        key = testVec[featIndex]</span><br><span class="line">        valueOfFeat = secondDict[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(valueOfFeat, <span class="built_in">dict</span>):</span><br><span class="line">            classLabel = self.classify(valueOfFeat, featLabels, testVec)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            classLabel = valueOfFeat</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">storeTree</span>(<span class="params">self, inputTree, filename</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将训练好的决策树模型存储起来，使用 pickle 模块</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> pickle</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">            pickle.dump(inputTree, fw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grabTree</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将之前存储的决策树模型使用 pickle 模块还原出来</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> pickle</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fr:</span><br><span class="line">            <span class="keyword">return</span> pickle.load(fr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ContactLensesTest</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        预测隐形眼镜的测试代码，并将结果画出来</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.myTree)</span><br><span class="line">        self.createPlot()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createPlot</span>(<span class="params">self</span>):</span><br><span class="line">        fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        fig.clf()</span><br><span class="line"></span><br><span class="line">        axprops = <span class="built_in">dict</span>(xticks=[], yticks=[])</span><br><span class="line">        dtPlot.createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)</span><br><span class="line"></span><br><span class="line">        dtPlot.plotTree.totalW = <span class="built_in">float</span>(dtPlot.getNumLeafs(self.myTree))</span><br><span class="line">        dtPlot.plotTree.totalD = <span class="built_in">float</span>(dtPlot.getTreeDepth(self.myTree))</span><br><span class="line">        dtPlot.plotTree.xOff = -<span class="number">0.5</span> / dtPlot.plotTree.totalW</span><br><span class="line">        dtPlot.plotTree.yOff = <span class="number">1.0</span></span><br><span class="line">        dtPlot.plotTree(self.myTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fr = <span class="built_in">open</span>(<span class="string">&#x27;3.DecisionTree/lenses.txt&#x27;</span>)</span><br><span class="line">    lenses = [inst.strip().split(<span class="string">&#x27;\t&#x27;</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">    lensesLabels = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;prescript&#x27;</span>, <span class="string">&#x27;astigmatic&#x27;</span>, <span class="string">&#x27;tearRate&#x27;</span>]</span><br><span class="line">    dt = DecisionTree()</span><br><span class="line">    dt.createTree(lenses, lensesLabels)</span><br><span class="line">    <span class="built_in">print</span>(dt.myTree)</span><br><span class="line">    dt.createPlot()</span><br></pre></td></tr></table></figure><p>示例数据</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">youngmyopenoreducedno lenses</span><br><span class="line">youngmyopenonormalsoft</span><br><span class="line">youngmyopeyesreducedno lenses</span><br><span class="line">youngmyopeyesnormalhard</span><br><span class="line">younghypernoreducedno lenses</span><br><span class="line">younghypernonormalsoft</span><br><span class="line">younghyperyesreducedno lenses</span><br><span class="line">younghyperyesnormalhard</span><br><span class="line">premyopenoreducedno lenses</span><br><span class="line">premyopenonormalsoft</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Decision Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib简析</title>
      <link href="/2023/07/27/matplotlib%E7%AE%80%E6%9E%90/"/>
      <url>/2023/07/27/matplotlib%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib简析"><a href="#matplotlib简析" class="headerlink" title="matplotlib简析"></a>matplotlib简析</h1><p>Matplotlib是一个用于创建静态、动态和交互式图表的Python绘图库。它提供了广泛的功能，使用户能够可视化数据和结果，从简单的线条图和散点图到复杂的图形，如条形图、直方图、饼图、3D图形等。</p><p>Matplotlib是Python数据科学生态系统中最流行的绘图库之一，它支持几乎所有操作系统，并且可以与多个图形工具包和界面结合使用，如NumPy、Pandas、SciPy等。此外，Matplotlib还可以嵌入到图形用户界面（GUI）工具包中，如Tkinter、PyQt等，从而实现交互式图形应用程序的开发。</p><p>Matplotlib的主要优势包括易于使用、灵活性和功能强大。使用Matplotlib，您可以以高质量和专业的方式展示数据，这对于数据分析、科学研究、工程和其他领域都是非常有用的。</p><div class="tagLink"><a class="link-card" title="Matplotlib官网" href="https://matplotlib.org/"><span class="link-card-backdrop" style="background-image: url(https://matplotlib.org/_static/logo_light.svg)"></span><div class="left"><img src="https://matplotlib.org/_static/logo_light.svg" class="lazyload placeholder" data-srcset="https://matplotlib.org/_static/logo_light.svg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Matplotlib官网</p><p class="url">https://matplotlib.org/</p></div></a></div><h2 id="绘图类型"><a href="#绘图类型" class="headerlink" title="绘图类型"></a>绘图类型</h2><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">2</span> * np.sin(<span class="number">2</span> * x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.plot(x, y, linewidth=<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = np.linspace(0, 10, 100)</code>: 使用NumPy的<code>linspace</code>函数创建一个包含100个点的等间隔数组，从0到10。这个数组将作为x轴的值。</p></li><li><p><code>y = 4 + 2 * np.sin(2 * x)</code>: 使用NumPy的<code>sin</code>函数对<code>2 * x</code>进行正弦运算，并乘以2，然后再加上4，得到y轴的值。这个计算的结果是使y值随着x轴的增加而周期性地上下波动的一组数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.plot(x, y, linewidth=2.0)</code>: 在坐标轴<code>ax</code>上绘制折线图，使用之前生成的x和y数组作为数据，并设置线宽为2.0。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><img src="https://matplotlib.org/stable/_images/sphx_glr_plot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_plot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="plot"><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make the data</span></span><br><span class="line">np.random.seed(<span class="number">3</span>)</span><br><span class="line">x = <span class="number">4</span> + np.random.normal(<span class="number">0</span>, <span class="number">2</span>, <span class="number">24</span>)</span><br><span class="line">y = <span class="number">4</span> + np.random.normal(<span class="number">0</span>, <span class="number">2</span>, <span class="built_in">len</span>(x))</span><br><span class="line"><span class="comment"># size and color:</span></span><br><span class="line">sizes = np.random.uniform(<span class="number">15</span>, <span class="number">80</span>, <span class="built_in">len</span>(x))</span><br><span class="line">colors = np.random.uniform(<span class="number">15</span>, <span class="number">80</span>, <span class="built_in">len</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.scatter(x, y, s=sizes, c=colors, vmin=<span class="number">0</span>, vmax=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(3)</code>: 设置随机数生成器的种子，这样每次运行代码都能得到相同的随机数据。这是为了保证结果的可复现性。</p></li><li><p><code>x = 4 + np.random.normal(0, 2, 24)</code>: 使用NumPy的<code>random.normal</code>函数生成一个包含24个随机数的数组，这些随机数是从均值为0、标准差为2的正态分布中抽取的，并将每个数值都加上4。这样生成了一组带有偏移的随机数据，用作x轴的值。</p></li><li><p><code>y = 4 + np.random.normal(0, 2, len(x))</code>: 同样，使用NumPy的<code>random.normal</code>函数生成一个与x轴数据长度相同的随机数数组，并进行偏移。这样生成了一组带有偏移的随机数据，用作y轴的值。</p></li><li><p><code>sizes = np.random.uniform(15, 80, len(x))</code>: 使用NumPy的<code>random.uniform</code>函数生成一个与x轴数据长度相同的数组，其中的数值在15到80之间，用作散点的大小。</p></li><li><p><code>colors = np.random.uniform(15, 80, len(x))</code>: 使用NumPy的<code>random.uniform</code>函数生成一个与x轴数据长度相同的数组，其中的数值在15到80之间，用作散点的颜色。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.scatter(x, y, s=sizes, c=colors, vmin=0, vmax=100)</code>: 在坐标轴<code>ax</code>上绘制散点图。使用之前生成的x和y数组作为数据，并使用<code>sizes</code>数组设置散点的大小，使用<code>colors</code>数组设置散点的颜色。<code>vmin</code>和<code>vmax</code>参数用于设置颜色映射范围，这里设置为0和100，即颜色范围在15到80之间。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><img src="https://matplotlib.org/stable/_images/sphx_glr_scatter_plot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_scatter_plot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="scatter"><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">x = <span class="number">0.5</span> + np.arange(<span class="number">8</span>)</span><br><span class="line">y = [<span class="number">4.8</span>, <span class="number">5.5</span>, <span class="number">3.5</span>, <span class="number">4.6</span>, <span class="number">6.5</span>, <span class="number">6.6</span>, <span class="number">2.6</span>, <span class="number">3.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.bar(x, y, width=<span class="number">1</span>, edgecolor=<span class="string">&quot;white&quot;</span>, linewidth=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = 0.5 + np.arange(8)</code>: 使用NumPy的<code>arange</code>函数生成一个从0.5开始、间隔为1的长度为8的数组。这将作为x轴的数据。</p></li><li><p><code>y = [4.8, 5.5, 3.5, 4.6, 6.5, 6.6, 2.6, 3.0]</code>: 定义了一个包含8个数值的列表，这些数值将作为y轴的数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.bar(x, y, width=1, edgecolor=&quot;white&quot;, linewidth=0.7)</code>: 在坐标轴<code>ax</code>上绘制条形图。使用之前生成的x和y数组作为数据，<code>width=1</code>设置条形的宽度为1，<code>edgecolor=&quot;white&quot;</code>设置条形的边缘颜色为白色，<code>linewidth=0.7</code>设置条形的边缘线宽为0.7。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><img src="https://matplotlib.org/stable/_images/sphx_glr_bar_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_bar_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="bar"><h3 id="棉棒图"><a href="#棉棒图" class="headerlink" title="棉棒图"></a>棉棒图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = <span class="number">0.5</span> + np.arange(<span class="number">8</span>)</span><br><span class="line">y = [<span class="number">4.8</span>, <span class="number">5.5</span>, <span class="number">3.5</span>, <span class="number">4.6</span>, <span class="number">6.5</span>, <span class="number">6.6</span>, <span class="number">2.6</span>, <span class="number">3.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.stem(x, y)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = 0.5 + np.arange(8)</code>: 使用NumPy的<code>arange</code>函数生成一个从0.5开始、间隔为1的长度为8的数组。这将作为x轴的数据。</p></li><li><p><code>y = [4.8, 5.5, 3.5, 4.6, 6.5, 6.6, 2.6, 3.0]</code>: 定义了一个包含8个数值的列表，这些数值将作为y轴的数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.stem(x, y)</code>: 在坐标轴<code>ax</code>上绘制棉棒图（stem plot）。使用之前生成的x和y数组作为数据，棉棒图展示了每个x坐标对应的y值，并通过垂直线连接每个点到x轴。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><img src="https://matplotlib.org/stable/_images/sphx_glr_stem_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_stem_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="stem"><h3 id="阶梯图"><a href="#阶梯图" class="headerlink" title="阶梯图"></a>阶梯图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = <span class="number">0.5</span> + np.arange(<span class="number">8</span>)</span><br><span class="line">y = [<span class="number">4.8</span>, <span class="number">5.5</span>, <span class="number">3.5</span>, <span class="number">4.6</span>, <span class="number">6.5</span>, <span class="number">6.6</span>, <span class="number">2.6</span>, <span class="number">3.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.step(x, y, linewidth=<span class="number">2.5</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = 0.5 + np.arange(8)</code>: 使用NumPy的<code>arange</code>函数生成一个从0.5开始、间隔为1的长度为8的数组。这将作为x轴的数据。</p></li><li><p><code>y = [4.8, 5.5, 3.5, 4.6, 6.5, 6.6, 2.6, 3.0]</code>: 定义了一个包含8个数值的列表，这些数值将作为y轴的数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.step(x, y, linewidth=2.5)</code>: 在坐标轴<code>ax</code>上绘制阶梯图（step plot）。使用之前生成的x和y数组作为数据，阶梯图是一种连续线段连接的图形，每个点以垂直线段连接到下一个点，形成阶梯状的线条。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><img src="https://matplotlib.org/stable/_images/sphx_glr_step_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_step_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="step"><h3 id="填充区域图"><a href="#填充区域图" class="headerlink" title="填充区域图"></a>填充区域图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>)</span><br><span class="line">y1 = <span class="number">3</span> + <span class="number">4</span>*x/<span class="number">8</span> + np.random.uniform(<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="built_in">len</span>(x))</span><br><span class="line">y2 = <span class="number">1</span> + <span class="number">2</span>*x/<span class="number">8</span> + np.random.uniform(<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="built_in">len</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.fill_between(x, y1, y2, alpha=<span class="number">.5</span>, linewidth=<span class="number">0</span>)</span><br><span class="line">ax.plot(x, (y1 + y2)/<span class="number">2</span>, linewidth=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数生成器的种子，这样每次运行代码都能得到相同的随机数据。这是为了保证结果的可复现性。</p></li><li><p><code>x = np.linspace(0, 8, 16)</code>: 使用NumPy的<code>linspace</code>函数生成一个从0到8的等间隔数组，长度为16。这将作为x轴的数据。</p></li><li><p><code>y1 = 3 + 4*x/8 + np.random.uniform(0.0, 0.5, len(x))</code>: 使用NumPy的<code>random.uniform</code>函数生成一个与x轴数据长度相同的随机数数组，其中的数值在0.0到0.5之间，并将其加到3 + 4*x&#x2F;8的结果中。这将生成一组y1轴的随机数据。</p></li><li><p><code>y2 = 1 + 2*x/8 + np.random.uniform(0.0, 0.5, len(x))</code>: 同样，使用NumPy的<code>random.uniform</code>函数生成一个与x轴数据长度相同的随机数数组，其中的数值在0.0到0.5之间，并将其加到1 + 2*x&#x2F;8的结果中。这将生成一组y2轴的随机数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.fill_between(x, y1, y2, alpha=.5, linewidth=0)</code>: 在坐标轴<code>ax</code>上绘制两条曲线<code>y1</code>和<code>y2</code>之间的填充区域。<code>alpha=.5</code>设置填充区域的透明度为0.5，<code>linewidth=0</code>设置填充区域的边界线宽为0，使得填充区域没有明显的边界线。</p></li><li><p><code>ax.plot(x, (y1 + y2)/2, linewidth=2)</code>: 在坐标轴<code>ax</code>上绘制一条线，线的y值是<code>y1</code>和<code>y2</code>的平均值，即<code>(y1 + y2)/2</code>。这条线将连接<code>y1</code>和<code>y2</code>两条曲线之间填充区域的中心。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个填充区域图，其中x轴的数据是从0到8的长度为16的等间隔数组，y轴的数据是通过在两个曲线<code>y1</code>和<code>y2</code>之间填充一个随机生成的小范围来得到的。填充区域由透明度为0.5的颜色填充，而中心线由y1和y2的平均值组成。x轴范围是0到8，y轴范围是0到8，并且x和y轴都有间隔为1的刻度。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_fill_between_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_fill_between_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="fill_between"><h3 id="堆叠区域图"><a href="#堆叠区域图" class="headerlink" title="堆叠区域图"></a>堆叠区域图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">ay = [<span class="number">1</span>, <span class="number">1.25</span>, <span class="number">2</span>, <span class="number">2.75</span>, <span class="number">3</span>]</span><br><span class="line">by = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">cy = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = np.vstack([ay, by, cy])</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.stackplot(x, y)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = np.arange(0, 10, 2)</code>: 使用NumPy的<code>arange</code>函数生成一个从0开始、间隔为2的长度为5的数组。这将作为x轴的数据。</p></li><li><p><code>ay = [1, 1.25, 2, 2.75, 3]</code>: 定义了一个包含5个数值的列表，这些数值将作为第一组y轴的数据。</p></li><li><p><code>by = [1, 1, 1, 1, 1]</code>: 定义了一个包含5个数值的列表，这些数值将作为第二组y轴的数据。</p></li><li><p><code>cy = [2, 1, 2, 1, 2]</code>: 定义了一个包含5个数值的列表，这些数值将作为第三组y轴的数据。</p></li><li><p><code>y = np.vstack([ay, by, cy])</code>: 使用NumPy的<code>vstack</code>函数将三组y轴数据堆叠在一起，形成一个2维数组。这样，<code>y</code>将成为一个包含3个子数组的数组，每个子数组代表一组y轴数据。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.stackplot(x, y)</code>: 在坐标轴<code>ax</code>上绘制堆叠区域图（stacked plot）。使用之前生成的x和y数组作为数据，堆叠区域图展示了每个x坐标对应的三组y值的堆叠区域。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 设置坐标轴的范围和刻度。x轴范围设置为0到8，同时设置x轴刻度为从1到7的间隔为1的刻度。y轴范围设置为0到8，同时设置y轴刻度为从1到7的间隔为1的刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个堆叠区域图，其中x轴的数据是从0开始的长度为5的等间隔数组，y轴的数据有三组，分别是<code>ay</code>、<code>by</code>和<code>cy</code>。堆叠区域图将显示三组y轴数据在每个x坐标处的堆叠区域，形成了多个不同颜色的堆叠区域。x轴范围是0到8，y轴范围是0到8，并且x和y轴都有间隔为1的刻度。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_stackplot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_stackplot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="stackplot"><h3 id="热图"><a href="#热图" class="headerlink" title="热图"></a>热图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>), np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">16</span>))</span><br><span class="line">Z = (<span class="number">1</span> - X/<span class="number">2</span> + X**<span class="number">5</span> + Y**<span class="number">3</span>) * np.exp(-X**<span class="number">2</span> - Y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.imshow(Z)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y = np.meshgrid(np.linspace(-3, 3, 16), np.linspace(-3, 3, 16))</code>: 使用NumPy的<code>meshgrid</code>函数生成一个网格，其中X和Y分别是从-3到3的等间隔数组，长度为16。这将用于创建一个二维坐标系，其中X和Y分别表示x轴和y轴上的点。</p></li><li><p><code>Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>: 使用X和Y数组计算出一个二维数组Z，其中的数值是根据给定的函数计算得到的。这个函数是 <code>(1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.imshow(Z)</code>: 在坐标轴<code>ax</code>上显示二维数组Z，这将以图像的形式显示出来。imshow函数会根据数组中的数值来着色，较大的数值将显示为较亮的颜色，较小的数值将显示为较暗的颜色。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个基于二维数组Z的图像。Z的数值是根据给定的函数计算得到的，然后使用imshow函数将二维数组Z以图像的形式显示出来。imshow函数将根据数组中的数值自动着色，形成一个具有明暗变化的图像。在这里，Z的值由X和Y的坐标计算得到，因此图像会显示一种呈现复杂图案的分布情况。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_imshow_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_imshow_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="imshow"><h3 id="伪彩色图"><a href="#伪彩色图" class="headerlink" title="伪彩色图"></a>伪彩色图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data with uneven sampling in x</span></span><br><span class="line">x = [-<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1.6</span>, -<span class="number">1.2</span>, -<span class="number">.8</span>, -<span class="number">.5</span>, -<span class="number">.2</span>, <span class="number">.1</span>, <span class="number">.3</span>, <span class="number">.5</span>, <span class="number">.8</span>, <span class="number">1.1</span>, <span class="number">1.5</span>, <span class="number">1.9</span>, <span class="number">2.3</span>, <span class="number">3</span>]</span><br><span class="line">X, Y = np.meshgrid(x, np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>))</span><br><span class="line">Z = (<span class="number">1</span> - X/<span class="number">2</span> + X**<span class="number">5</span> + Y**<span class="number">3</span>) * np.exp(-X**<span class="number">2</span> - Y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.pcolormesh(X, Y, Z, vmin=-<span class="number">0.5</span>, vmax=<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = [-3, -2, -1.6, -1.2, -.8, -.5, -.2, .1, .3, .5, .8, 1.1, 1.5, 1.9, 2.3, 3]</code>: 定义了一个不规则的一维数组<code>x</code>，用于表示网格中的x坐标。这些x坐标是不均匀间隔的。</p></li><li><p><code>X, Y = np.meshgrid(x, np.linspace(-3, 3, 128))</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，其中<code>X</code>由不规则间隔的一维数组<code>x</code>和均匀间隔的一维数组<code>np.linspace(-3, 3, 128)</code>组成。<code>Y</code>由均匀间隔的一维数组<code>np.linspace(-3, 3, 128)</code>组成。生成的<code>X</code>和<code>Y</code>数组都是(16, 128)的形状，表示一个16行、128列的网格。</p></li><li><p><code>Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>: 这行代码计算一个二维数组<code>Z</code>，数组中的每个元素是通过对应位置的<code>X</code>和<code>Y</code>坐标值代入一个特定的函数表达式得到的。这个函数表达式是 <code>(1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>。在这里，我们使用了NumPy的广播功能，<code>X</code>和<code>Y</code>是同样大小的数组，所以它们进行元素级别的运算，从而生成一个新的二维数组<code>Z</code>。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.pcolormesh(X, Y, Z, vmin=-0.5, vmax=1.0)</code>: 使用<code>ax.pcolormesh</code>函数绘制伪彩色图。这个函数以<code>X</code>和<code>Y</code>作为网格坐标，将<code>Z</code>数组中的值作为颜色编码来填充网格，从而生成一个伪彩色图。<code>vmin=-0.5</code>和<code>vmax=1.0</code>分别设置了颜色编码的范围，这样可以将<code>Z</code>中小于-0.5的值映射为低值颜色，大于1.0的值映射为高值颜色。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个伪彩色图，其中网格的x坐标由不规则间隔的一维数组<code>x</code>表示，y坐标由均匀间隔的一维数组<code>np.linspace(-3, 3, 128)</code>表示。在伪彩色图中，颜色编码用于表示<code>Z</code>数组中的值，而<code>Z</code>数组的值是根据特定的函数计算得到的。通过颜色的变化，我们可以直观地看到<code>Z</code>随着<code>X</code>和<code>Y</code>的变化而发生的变化。</p><p>这个数学公式可以写为：</p><p>$$ Z &#x3D; (1 - \frac{X}{2} + X^5 + Y^3) \times e^{-X^2 - Y^2} $$</p><p>其中，$ X $ 和 $ Y $ 是网格坐标，$ Z $ 是根据 $ X $ 和 $ Y $ 计算的函数值。公式中包含了多项式和指数函数的运算。这个函数表达式用于生成一个二维数组 $ Z $，并在后续的代码中被用于绘制伪彩色图。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_pcolormesh_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_pcolormesh_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pcolormesh"><blockquote><p>热图（Heatmap）和伪彩色图（Pseudocolor Plot）都是用来可视化二维数据的图像表示方法，但它们在呈现数据的方式和目的上有一些区别。<br>    热图（Heatmap）：<br>    - 热图是一种常见的二维数据可视化方法，通常用于显示数据的分布、关联性或者密度。<br>      - 热图使用颜色来表示数据值的大小，其中颜色的明暗程度代表数据的相对大小。<br>      - 通常，较大的数值用较深的颜色表示，较小的数值用较浅的颜色表示，从而形成一个明暗变化的色阶。<br>      - 热图通常用于展示数据的整体结构和趋势，以及在不同位置的数据值之间的相对大小关系。<br>      - 例子：在基因表达数据分析中，热图可以用来显示不同基因在不同样本中的表达量，帮助研究基因的表达模式。<br>    伪彩色图（Pseudocolor Plot）：<br>    - 伪彩色图也是一种二维数据可视化方法，用于表示数据的变化和分布情况。<br>      - 伪彩色图使用颜色来编码数据的数值，不同颜色代表不同数值，而不仅仅是数据的大小。<br>      - 伪彩色图通常用于展示数据的细节和变化，以及在不同位置的具体数值。<br>      - 通常，可以通过设定颜色映射范围来控制颜色的分配，从而突出数据的特定范围或变化。<br>      - 例子：在物理模拟中，伪彩色图可以用来显示模拟结果的数值，例如温度分布、流速等。<br>    总体而言，热图更适合呈现数据的总体结构和相对关系，而伪彩色图更适合呈现数据的具体数值和细节变化。但在某些情况下，这两种图形方法可以相互转换或混用，具体要根据数据的特性和可视化的目的来选择适合的方法。</p></blockquote><h3 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>), np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>))</span><br><span class="line">Z = (<span class="number">1</span> - X/<span class="number">2</span> + X**<span class="number">5</span> + Y**<span class="number">3</span>) * np.exp(-X**<span class="number">2</span> - Y**<span class="number">2</span>)</span><br><span class="line">levels = np.linspace(np.<span class="built_in">min</span>(Z), np.<span class="built_in">max</span>(Z), <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.contour(X, Y, Z, levels=levels)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y = np.meshgrid(np.linspace(-3, 3, 256), np.linspace(-3, 3, 256))</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，其中<code>X</code>由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>组成，<code>Y</code>也是由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>组成。生成的<code>X</code>和<code>Y</code>数组都是(256, 256)的形状，表示一个256x256的网格。</p></li><li><p><code>Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>: 这行代码计算一个二维数组<code>Z</code>，数组中的每个元素是通过对应位置的<code>X</code>和<code>Y</code>坐标值代入一个特定的函数表达式得到的。这个函数表达式是 <code>(1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>。在这里，我们使用了NumPy的广播功能，<code>X</code>和<code>Y</code>是同样大小的数组，所以它们进行元素级别的运算，从而生成一个新的二维数组<code>Z</code>。</p></li><li><p><code>levels = np.linspace(np.min(Z), np.max(Z), 7)</code>: 创建一个包含7个元素的一维数组<code>levels</code>，其中的数值是通过等间隔方式从<code>Z</code>数组的最小值到最大值生成的。这些数值将用于设置等高线图中的轮廓线的高度值。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.contour(X, Y, Z, levels=levels)</code>: 使用<code>ax.contour</code>函数绘制等高线图。这个函数以<code>X</code>和<code>Y</code>作为网格坐标，将<code>Z</code>数组中的值作为高度值来绘制等高线。通过设置<code>levels</code>参数，等高线图将在指定的高度值处绘制轮廓线。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个等高线图，其中网格的x坐标由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>表示，y坐标也由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>表示。在等高线图中，不同高度值对应的轮廓线将呈现出数据的变化和分布情况。通过观察轮廓线的分布和形状，我们可以了解函数在二维空间中的变化和特性。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_contour_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_contour_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="contour"><h3 id="填充等高线图"><a href="#填充等高线图" class="headerlink" title="填充等高线图"></a>填充等高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>), np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>))</span><br><span class="line">Z = (<span class="number">1</span> - X/<span class="number">2</span> + X**<span class="number">5</span> + Y**<span class="number">3</span>) * np.exp(-X**<span class="number">2</span> - Y**<span class="number">2</span>)</span><br><span class="line">levels = np.linspace(Z.<span class="built_in">min</span>(), Z.<span class="built_in">max</span>(), <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.contourf(X, Y, Z, levels=levels)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y = np.meshgrid(np.linspace(-3, 3, 256), np.linspace(-3, 3, 256))</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，其中<code>X</code>由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>组成，<code>Y</code>也是由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>组成。生成的<code>X</code>和<code>Y</code>数组都是(256, 256)的形状，表示一个256x256的网格。</p></li><li><p><code>Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>: 这行代码计算一个二维数组<code>Z</code>，数组中的每个元素是通过对应位置的<code>X</code>和<code>Y</code>坐标值代入一个特定的函数表达式得到的。这个函数表达式是 <code>(1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>。在这里，我们使用了NumPy的广播功能，<code>X</code>和<code>Y</code>是同样大小的数组，所以它们进行元素级别的运算，从而生成一个新的二维数组<code>Z</code>。</p></li><li><p><code>levels = np.linspace(Z.min(), Z.max(), 7)</code>: 创建一个包含7个元素的一维数组<code>levels</code>，其中的数值是通过等间隔方式从<code>Z</code>数组的最小值到最大值生成的。这些数值将用于设置填充等高线图中的色块的高度值。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.contourf(X, Y, Z, levels=levels)</code>: 使用<code>ax.contourf</code>函数绘制填充等高线图。这个函数以<code>X</code>和<code>Y</code>作为网格坐标，将<code>Z</code>数组中的值作为高度值来绘制填充等高线图。通过设置<code>levels</code>参数，填充等高线图将在指定的高度值处绘制色块。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个填充等高线图，其中网格的x坐标由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>表示，y坐标也由均匀间隔的一维数组<code>np.linspace(-3, 3, 256)</code>表示。在填充等高线图中，不同高度值对应的色块将呈现出数据的变化和分布情况，填充等高线图比普通的等高线图更突出数据的整体结构和趋势。通过观察色块的分布和形状，我们可以直观地了解函数在二维空间中的变化和特性。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_contourf_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_contourf_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="contourf"><h3 id="风羽图"><a href="#风羽图" class="headerlink" title="风羽图"></a>风羽图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">X, Y = np.meshgrid([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">angle = np.pi / <span class="number">180</span> * np.array([[<span class="number">15.</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">45</span>],</span><br><span class="line">                                [<span class="number">25.</span>, <span class="number">40</span>, <span class="number">55</span>, <span class="number">60</span>],</span><br><span class="line">                                [<span class="number">35.</span>, <span class="number">50</span>, <span class="number">65</span>, <span class="number">75</span>],</span><br><span class="line">                                [<span class="number">45.</span>, <span class="number">60</span>, <span class="number">75</span>, <span class="number">90</span>]])</span><br><span class="line">amplitude = np.array([[<span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">50</span>],</span><br><span class="line">                      [<span class="number">10</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">60</span>],</span><br><span class="line">                      [<span class="number">15</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">70</span>],</span><br><span class="line">                      [<span class="number">20</span>, <span class="number">45</span>, <span class="number">80</span>, <span class="number">100</span>]])</span><br><span class="line">U = amplitude * np.sin(angle)</span><br><span class="line">V = amplitude * np.cos(angle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.barbs(X, Y, U, V, barbcolor=<span class="string">&#x27;C0&#x27;</span>, flagcolor=<span class="string">&#x27;C0&#x27;</span>, length=<span class="number">7</span>, linewidth=<span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">4.5</span>), ylim=(<span class="number">0</span>, <span class="number">4.5</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y = np.meshgrid([1, 2, 3, 4], [1, 2, 3, 4])</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，其中<code>X</code>由一维数组<code>[1, 2, 3, 4]</code>组成，<code>Y</code>也由一维数组<code>[1, 2, 3, 4]</code>组成。生成的<code>X</code>和<code>Y</code>数组都是(4, 4)的形状，表示一个4x4的网格，用于表示风羽图中的位置。</p></li><li><p><code>angle</code>和<code>amplitude</code>分别是两个(4, 4)的二维数组，分别表示风的角度（方向）和风速的大小。这些数据用于计算风的速度在x和y方向的分量，分别保存在<code>U</code>和<code>V</code>数组中。</p></li><li><p><code>U = amplitude * np.sin(angle)</code>: 这行代码计算风速在x方向的分量。</p></li><li><p><code>V = amplitude * np.cos(angle)</code>: 这行代码计算风速在y方向的分量。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.barbs(X, Y, U, V, barbcolor=&#39;C0&#39;, flagcolor=&#39;C0&#39;, length=7, linewidth=1.5)</code>: 使用<code>ax.barbs</code>函数绘制风羽图。这个函数以<code>X</code>和<code>Y</code>作为网格坐标，<code>U</code>和<code>V</code>分别作为风速在x和y方向的分量。<code>barbcolor</code>参数设置风羽的颜色，<code>flagcolor</code>参数设置风羽旗帜的颜色，<code>length</code>参数设置风羽的长度，<code>linewidth</code>参数设置风羽的线宽。</p></li><li><p><code>ax.set(xlim=(0, 4.5), ylim=(0, 4.5))</code>: 设置坐标轴的显示范围，以便风羽图完整显示在图形中。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个风羽图，其中风的方向和风速由<code>angle</code>和<code>amplitude</code>数组表示。风羽图中的每个风羽表示了风的方向和大小。风速越大，风羽的长度越长；风的方向由风羽的方向表示。通过观察风羽图，我们可以直观地了解风的分布和风向的变化。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_barbs_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_barbs_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="barbs"><h3 id="矢量场图"><a href="#矢量场图" class="headerlink" title="矢量场图"></a>矢量场图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = np.linspace(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">y = np.linspace(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">U = X + Y</span><br><span class="line">V = Y - X</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.quiver(X, Y, U, V, color=<span class="string">&quot;C0&quot;</span>, angles=<span class="string">&#x27;xy&#x27;</span>,</span><br><span class="line">          scale_units=<span class="string">&#x27;xy&#x27;</span>, scale=<span class="number">5</span>, width=<span class="number">.015</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">5</span>, <span class="number">5</span>), ylim=(-<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = np.linspace(-4, 4, 6)</code>: 使用<code>np.linspace</code>函数创建一个包含6个均匀分布的点的数组，范围从-4到4。这个数组用于表示x轴上的坐标点。</p></li><li><p><code>y = np.linspace(-4, 4, 6)</code>: 使用<code>np.linspace</code>函数创建一个包含6个均匀分布的点的数组，范围从-4到4。这个数组用于表示y轴上的坐标点。</p></li><li><p><code>X, Y = np.meshgrid(x, y)</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，分别表示所有x轴和y轴坐标点的组合。在这个例子中，<code>X</code>和<code>Y</code>都是(6, 6)的形状，表示一个6x6的网格。</p></li><li><p><code>U = X + Y</code>: 这行代码计算矢量场中每个点的x轴分量。在这个例子中，x轴分量 <code>U</code> 是<code>X</code>和<code>Y</code>的和。</p></li><li><p><code>V = Y - X</code>: 这行代码计算矢量场中每个点的y轴分量。在这个例子中，y轴分量 <code>V</code> 是<code>Y</code>减去<code>X</code>。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.quiver(X, Y, U, V, color=&quot;C0&quot;, angles=&#39;xy&#39;, scale_units=&#39;xy&#39;, scale=5, width=.015)</code>: 使用<code>ax.quiver</code>函数绘制矢量场图。这个函数以<code>X</code>和<code>Y</code>作为网格坐标，<code>U</code>和<code>V</code>分别作为矢量场中每个点的x轴和y轴分量。<code>color=&quot;C0&quot;</code>设置箭头的颜色为蓝色，<code>angles=&#39;xy&#39;</code>表示箭头是使用x和y坐标轴来表示角度，<code>scale_units=&#39;xy&#39;</code>表示箭头的比例尺是相对于x和y坐标轴的单位，<code>scale=5</code>设置箭头的比例尺为5，<code>width=.015</code>设置箭头的宽度为0.015。</p></li><li><p><code>ax.set(xlim=(-5, 5), ylim=(-5, 5))</code>: 设置坐标轴的显示范围，以便矢量场图完整显示在图形中。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个矢量场图，其中每个箭头表示矢量场中的一个点。箭头的位置由<code>X</code>和<code>Y</code>数组确定，箭头的方向和大小由<code>U</code>和<code>V</code>数组决定。箭头的方向表示在每个点的x和y方向上的分量，箭头的长度和宽度则决定了箭头的大小。通过观察矢量场图，我们可以直观地了解矢量场在不同位置的方向和大小。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_quiver_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_quiver_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="quiver"><h3 id="流线图"><a href="#流线图" class="headerlink" title="流线图"></a>流线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make a stream function:</span></span><br><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>), np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>))</span><br><span class="line">Z = (<span class="number">1</span> - X/<span class="number">2</span> + X**<span class="number">5</span> + Y**<span class="number">3</span>) * np.exp(-X**<span class="number">2</span> - Y**<span class="number">2</span>)</span><br><span class="line"><span class="comment"># make U and V out of the streamfunction:</span></span><br><span class="line">V = np.diff(Z[<span class="number">1</span>:, :], axis=<span class="number">1</span>)</span><br><span class="line">U = -np.diff(Z[:, <span class="number">1</span>:], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.streamplot(X[<span class="number">1</span>:, <span class="number">1</span>:], Y[<span class="number">1</span>:, <span class="number">1</span>:], U, V)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y = np.meshgrid(np.linspace(-3, 3, 256), np.linspace(-3, 3, 256))</code>: 使用<code>np.meshgrid</code>函数生成两个二维数组<code>X</code>和<code>Y</code>，分别表示从-3到3范围内均匀分布的256个点的网格。这些数组将用于表示流场中的坐标点。</p></li><li><p><code>Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)</code>: 这行代码计算流函数 <code>Z</code>。流函数是一个标量场函数，它通常用于描述流体流动的速度分布。在这个例子中，<code>Z</code> 是根据给定的公式计算得到的，它是关于 <code>X</code> 和 <code>Y</code> 的函数。</p></li><li><p><code>V = np.diff(Z[1:, :], axis=1)</code>: 这行代码计算速度场中每个点的y轴分量。在这个例子中，y轴分量 <code>V</code> 是 <code>Z</code> 数组在y方向上的差分。</p></li><li><p><code>U = -np.diff(Z[:, 1:], axis=0)</code>: 这行代码计算速度场中每个点的x轴分量。在这个例子中，x轴分量 <code>U</code> 是 <code>Z</code> 数组在x方向上的差分，注意差分得到的结果要取负号。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.streamplot(X[1:, 1:], Y[1:, 1:], U, V)</code>: 使用<code>ax.streamplot</code>函数绘制流线图。这个函数以 <code>X[1:, 1:]</code> 和 <code>Y[1:, 1:]</code> 作为网格坐标，<code>U</code> 和 <code>V</code> 作为速度场中每个点的x轴和y轴分量。<code>streamplot</code>函数会根据速度场的信息绘制出流线，并展示流体在给定流场中的运动。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个流线图，其中流线表示在给定的流场中流体的运动情况。流线的分布和形态展示了流体在该流场中的运动轨迹和速度分布。通过观察流线图，我们可以了解流体在不同位置的运动方向和速度。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_streamplot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_streamplot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="streamplot"><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = <span class="number">4</span> + np.random.normal(<span class="number">0</span>, <span class="number">1.5</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.hist(x, bins=<span class="number">8</span>, linewidth=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">56</span>), yticks=np.linspace(<span class="number">0</span>, <span class="number">56</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = 4 + np.random.normal(0, 1.5, 200)</code>: 使用<code>np.random.normal</code>生成一个包含200个随机数的数据集 <code>x</code>。这些随机数是从均值为4、标准差为1.5的正态分布中随机抽取的。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.hist(x, bins=8, linewidth=0.5, edgecolor=&quot;white&quot;)</code>: 使用<code>ax.hist</code>函数绘制直方图。该函数以数据集 <code>x</code> 为输入，<code>bins=8</code>指定了直方图的箱数为8，即直方图将被分成8个箱子，<code>linewidth=0.5</code>设置直方图边界线的宽度为0.5，<code>edgecolor=&quot;white&quot;</code>设置直方图边界线的颜色为白色。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 56), yticks=np.linspace(0, 56, 9))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴刻度为从1到7的整数刻度，<code>ylim=(0, 56)</code>设置y轴显示范围为0到56，<code>yticks=np.linspace(0, 56, 9)</code>设置y轴刻度为0到56之间等间距的9个刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个直方图，其中每个箱子表示数据集 <code>x</code> 在相应范围内的数据个数。通过观察直方图，我们可以了解数据集 <code>x</code> 的分布情况，以及数据在不同区间的频次分布。直方图是一种常用的数据可视化方法，用于对数据进行初步的统计和分布分析。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_hist_plot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_hist_plot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="hist"><h3 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">D = np.random.normal((<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="number">1.25</span>, <span class="number">1.00</span>, <span class="number">1.25</span>), (<span class="number">100</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">VP = ax.boxplot(D, positions=[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], widths=<span class="number">1.5</span>, patch_artist=<span class="literal">True</span>,</span><br><span class="line">                showmeans=<span class="literal">False</span>, showfliers=<span class="literal">False</span>,</span><br><span class="line">                medianprops=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;white&quot;</span>, <span class="string">&quot;linewidth&quot;</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">                boxprops=&#123;<span class="string">&quot;facecolor&quot;</span>: <span class="string">&quot;C0&quot;</span>, <span class="string">&quot;edgecolor&quot;</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;linewidth&quot;</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">                whiskerprops=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;C0&quot;</span>, <span class="string">&quot;linewidth&quot;</span>: <span class="number">1.5</span>&#125;,</span><br><span class="line">                capprops=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;C0&quot;</span>, <span class="string">&quot;linewidth&quot;</span>: <span class="number">1.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(10)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>D = np.random.normal((3, 5, 4), (1.25, 1.00, 1.25), (100, 3))</code>: 使用<code>np.random.normal</code>生成三个包含100个随机数的数据集，每个数据集对应一个正态分布。其中 <code>(3, 5, 4)</code> 是均值，<code>(1.25, 1.00, 1.25)</code> 是标准差，<code>(100, 3)</code> 是生成的数据集的形状。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.boxplot(D, positions=[2, 4, 6], widths=1.5, patch_artist=True, ...)</code>：使用<code>ax.boxplot</code>函数绘制箱线图。<code>D</code> 是要绘制的数据集，<code>positions=[2, 4, 6]</code> 设置了每个箱线图的位置，即将三个数据集绘制在x轴上的位置为2、4和6。<code>widths=1.5</code> 设置了每个箱线图的宽度为1.5。<code>patch_artist=True</code> 设置箱体用填充方式绘制。<code>showmeans=False</code> 和 <code>showfliers=False</code> 分别设置不显示均值和离群值。<code>medianprops</code>、<code>boxprops</code>、<code>whiskerprops</code> 和 <code>capprops</code> 参数用于设置箱线图中各个部分的属性，例如箱体、中位数线、箱须线和箱顶线的颜色和宽度。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴刻度为从1到7的整数刻度，<code>ylim=(0, 8)</code>设置y轴显示范围为0到8，<code>yticks=np.arange(1, 8)</code>设置y轴刻度为从1到7的整数刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个箱线图，其中每个箱线图表示一个数据集的分布情况。箱线图展示了数据的中位数、上下四分位数和离群值等统计特征，可以帮助我们快速了解数据的分布和异常值情况。</p><p>箱线图是一种常用的数据可视化工具，用于展示数据的分布情况和离群值。通过观察箱线图，你可以了解数据的中位数、四分位数、离群值等统计信息，从而更好地理解数据的整体分布和异常情况。</p><p>以下是如何看箱线图的一些方法：</p><ol><li><p><strong>箱体：</strong> 箱线图的主要部分是箱体，它表示数据的四分位数范围。箱体的底边界和顶边界分别对应第一四分位数（Q1）和第三四分位数（Q3）。箱体的中间线表示中位数（Q2），即数据的中值。箱体的高度反映了数据的离散程度，越高表示数据的变异性越大。</p></li><li><p><strong>箱须线：</strong> 箱线图的箱须线延伸出箱体，表示数据的范围。上边的箱须线通常表示数据中的最大值（除去离群值），下边的箱须线表示数据中的最小值（除去离群值）。箱须线可以帮助你了解数据的整体范围。</p></li><li><p><strong>离群值：</strong> 离群值是指数据中明显偏离其他数据的值。在箱线图中，通常将离群值单独表示为散点或小圆圈。离群值可能是数据中的异常值，也可能表示了数据的特殊情况。通过观察离群值，你可以判断数据中是否存在异常或特殊的观测值。</p></li><li><p><strong>比较箱线图：</strong> 如果有多个数据集的箱线图在同一张图中显示，你可以通过比较它们来观察数据的差异和共性。比较不同箱线图可以帮助你发现数据之间的异同，以及是否存在某种趋势或模式。</p></li><li><p><strong>偏态和尾重：</strong> 箱线图也可以用来观察数据的偏态（Skewness）和尾重（Heavy Tails）。偏态表示数据分布的不对称程度，正偏态表示数据右侧较长，负偏态表示数据左侧较长。尾重表示数据分布的尾部概率密度较大，尾部的概率分布比较重。</p></li><li><p><strong>异常检测：</strong> 箱线图可以用于识别数据中的异常值。通常，超出箱须线的数据点可能是离群值或异常值，值得注意和进一步调查。</p></li></ol><p>通过合理观察和解释箱线图的各个元素，你可以得到关于数据分布、偏态、异常值等方面的直观认识，并从中获取对数据的洞察和见解。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_boxplot_plot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_boxplot_plot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="boxplot"><h3 id="误差线图"><a href="#误差线图" class="headerlink" title="误差线图"></a>误差线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">y = [<span class="number">3.6</span>, <span class="number">5</span>, <span class="number">4.2</span>]</span><br><span class="line">yerr = [<span class="number">0.9</span>, <span class="number">1.2</span>, <span class="number">0.5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.errorbar(x, y, yerr, fmt=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">2</span>, capsize=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = [2, 4, 6]</code>: 定义一个包含3个x坐标的列表。</p></li><li><p><code>y = [3.6, 5, 4.2]</code>: 定义一个包含3个y坐标的列表，这些y坐标表示在相应x位置上的测量值。</p></li><li><p><code>yerr = [0.9, 1.2, 0.5]</code>: 定义一个包含3个y误差的列表，表示在相应x位置上的测量值的误差范围。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.errorbar(x, y, yerr, fmt=&#39;o&#39;, linewidth=2, capsize=6)</code>: 使用<code>ax.errorbar</code>函数绘制带有误差线的散点图。<code>x</code>和<code>y</code>是散点的横纵坐标数据，<code>yerr</code>是y方向的误差范围。<code>fmt=&#39;o&#39;</code>指定散点的形状为圆点，<code>linewidth=2</code>设置误差线的宽度为2，<code>capsize=6</code>设置误差线两端的横线长度为6。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴刻度为从1到7的整数刻度，<code>ylim=(0, 8)</code>设置y轴显示范围为0到8，<code>yticks=np.arange(1, 8)</code>设置y轴刻度为从1到7的整数刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个带有误差线的散点图，其中每个散点表示在相应x位置上的测量值，误差线表示了在相应x位置上的测量值的误差范围。带误差线的散点图可以帮助我们了解数据的可靠性和测量误差。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_errorbar_plot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_errorbar_plot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="errorbar"><h3 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">D = np.random.normal((<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="number">0.75</span>, <span class="number">1.00</span>, <span class="number">0.75</span>), (<span class="number">200</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">vp = ax.violinplot(D, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], widths=<span class="number">2</span>,</span><br><span class="line">                   showmeans=<span class="literal">False</span>, showmedians=<span class="literal">False</span>, showextrema=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># styling:</span></span><br><span class="line"><span class="keyword">for</span> body <span class="keyword">in</span> vp[<span class="string">&#x27;bodies&#x27;</span>]:</span><br><span class="line">    body.set_alpha(<span class="number">0.9</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(10)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>D = np.random.normal((3, 5, 4), (0.75, 1.00, 0.75), (200, 3))</code>: 使用<code>np.random.normal</code>生成三组包含200个随机数的数据集，每组数据集对应一个正态分布。其中 <code>(3, 5, 4)</code> 是均值，<code>(0.75, 1.00, 0.75)</code> 是标准差，<code>(200, 3)</code> 是生成的数据集的形状。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>vp = ax.violinplot(D, [2, 4, 6], widths=2, showmeans=False, showmedians=False, showextrema=False)</code>: 使用<code>ax.violinplot</code>函数绘制小提琴图。<code>D</code> 是要绘制的数据集，<code>[2, 4, 6]</code> 设置了每个小提琴图的位置，即将三个数据集绘制在x轴上的位置为2、4和6。<code>widths=2</code> 设置了小提琴图的宽度为2。<code>showmeans=False</code>、<code>showmedians=False</code> 和 <code>showextrema=False</code> 分别设置不显示均值、中位数和极值线。小提琴图通过核密度估计展示了数据的分布情况。</p></li><li><p><code>for body in vp[&#39;bodies&#39;]: body.set_alpha(0.9)</code>: 对小提琴图的主体进行样式设置，将其透明度设置为0.9。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴刻度为从1到7的整数刻度，<code>ylim=(0, 8)</code>设置y轴显示范围为0到8，<code>yticks=np.arange(1, 8)</code>设置y轴刻度为从1到7的整数刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制三个小提琴图，每个小提琴图代表一个数据集的分布情况。小提琴图可以帮助我们直观地了解数据的分布及其密度，从而更好地理解数据集的特征和统计属性。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_violin_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_violin_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="violinplot"><h3 id="事件图"><a href="#事件图" class="headerlink" title="事件图"></a>事件图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">D = np.random.gamma(<span class="number">4</span>, size=(<span class="number">3</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.eventplot(D, orientation=<span class="string">&quot;vertical&quot;</span>, lineoffsets=x, linewidth=<span class="number">0.75</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = [2, 4, 6]</code>: 定义一个包含3个x坐标的列表。</p></li><li><p><code>D = np.random.gamma(4, size=(3, 50))</code>: 使用<code>np.random.gamma</code>生成三个数据集，每个数据集包含50个从Gamma分布中随机生成的值。Gamma分布是一种常见的概率分布，它在许多领域中都有应用。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.eventplot(D, orientation=&quot;vertical&quot;, lineoffsets=x, linewidth=0.75)</code>: 使用<code>ax.eventplot</code>函数绘制事件图。<code>D</code> 是要绘制的数据集，<code>orientation=&quot;vertical&quot;</code> 指定事件图的方向为垂直方向。<code>lineoffsets=x</code> 设置了事件图的x坐标位置，即将三个数据集绘制在x轴上的位置为2、4和6。<code>linewidth=0.75</code> 设置事件图的线宽为0.75。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴刻度为从1到7的整数刻度，<code>ylim=(0, 8)</code>设置y轴显示范围为0到8，<code>yticks=np.arange(1, 8)</code>设置y轴刻度为从1到7的整数刻度。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制三个事件图，每个事件图代表一个数据集的事件发生情况。事件图可以用于可视化数据中的事件发生次数或发生时间，帮助我们了解数据的分布和事件之间的关联性。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_eventplot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_eventplot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="eventplot"><h3 id="二维直方图"><a href="#二维直方图" class="headerlink" title="二维直方图"></a>二维直方图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data: correlated + noise</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.randn(<span class="number">5000</span>)</span><br><span class="line">y = <span class="number">1.2</span> * x + np.random.randn(<span class="number">5000</span>) / <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.hist2d(x, y, bins=(np.arange(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">0.1</span>), np.arange(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">0.1</span>)))</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">2</span>, <span class="number">2</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.randn(5000)</code>: 生成一个包含5000个随机数的数组x，这些随机数是从标准正态分布（均值为0，标准差为1）中生成的。</p></li><li><p><code>y = 1.2 * x + np.random.randn(5000) / 3</code>: 生成一个包含5000个随机数的数组y，其中y与x具有一定的线性相关性，并添加了一些噪声。具体地，y是由x线性变换得到，并加上了从标准正态分布中随机生成的噪声，噪声的标准差为1&#x2F;3。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.hist2d(x, y, bins=(np.arange(-3, 3, 0.1), np.arange(-3, 3, 0.1)))</code>: 使用<code>ax.hist2d</code>函数绘制二维直方图。<code>x</code>和<code>y</code>是要绘制的二维数据，<code>bins</code>设置了直方图的区间范围和分箱数目。在这里，x和y的区间范围都是从-3到3，分箱数目为60（(3-(-3)) &#x2F; 0.1 &#x3D; 60）。</p></li><li><p><code>ax.set(xlim=(-2, 2), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-2, 2)</code>设置x轴显示范围为-2到2，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个二维直方图，用于展示两个变量x和y之间的相关性和分布情况。二维直方图可以帮助我们直观地了解两个变量之间的关系和分布特征，尤其适用于观察大量数据点的情况。在直方图中，颜色越深表示数据点越密集，颜色越浅表示数据点较少。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_hist2d_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_hist2d_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="hist2d"><h3 id="六边形图"><a href="#六边形图" class="headerlink" title="六边形图"></a>六边形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data: correlated + noise</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.randn(<span class="number">5000</span>)</span><br><span class="line">y = <span class="number">1.2</span> * x + np.random.randn(<span class="number">5000</span>) / <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.hexbin(x, y, gridsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">2</span>, <span class="number">2</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.randn(5000)</code>: 生成一个包含5000个随机数的数组x，这些随机数是从标准正态分布（均值为0，标准差为1）中生成的。</p></li><li><p><code>y = 1.2 * x + np.random.randn(5000) / 3</code>: 生成一个包含5000个随机数的数组y，其中y与x具有一定的线性相关性，并添加了一些噪声。具体地，y是由x线性变换得到，并加上了从标准正态分布中随机生成的噪声，噪声的标准差为1&#x2F;3。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.hexbin(x, y, gridsize=20)</code>: 使用<code>ax.hexbin</code>函数绘制六边形图。<code>x</code>和<code>y</code>是要绘制的二维数据，<code>gridsize=20</code>设置了六边形的网格大小。该参数控制了六边形的大小和密度，数值越大，表示六边形的大小越小、密度越大。</p></li><li><p><code>ax.set(xlim=(-2, 2), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-2, 2)</code>设置x轴显示范围为-2到2，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个六边形图，用于展示两个变量x和y之间的相关性和分布情况。六边形图在处理大量数据点时有着较好的可视化效果，可以帮助我们更好地理解两个变量之间的关系和分布特征。在图中，六边形的颜色深浅表示数据点的密集程度，颜色越深表示数据点越密集。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_hexbin_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_hexbin_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="hexbin"><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># make data</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">colors = plt.get_cmap(<span class="string">&#x27;Blues&#x27;</span>)(np.linspace(<span class="number">0.2</span>, <span class="number">0.7</span>, <span class="built_in">len</span>(x)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.pie(x, colors=colors, radius=<span class="number">3</span>, center=(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">       wedgeprops=&#123;<span class="string">&quot;linewidth&quot;</span>: <span class="number">1</span>, <span class="string">&quot;edgecolor&quot;</span>: <span class="string">&quot;white&quot;</span>&#125;, frame=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">8</span>), xticks=np.arange(<span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">       ylim=(<span class="number">0</span>, <span class="number">8</span>), yticks=np.arange(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x = [1, 2, 3, 4]</code>: 定义了一个包含4个数据点的列表x，每个数据点表示饼图中的一个扇区。</p></li><li><p><code>colors = plt.get_cmap(&#39;Blues&#39;)(np.linspace(0.2, 0.7, len(x)))</code>: 使用<code>plt.get_cmap(&#39;Blues&#39;)</code>函数获取一个蓝色调色板，<code>np.linspace(0.2, 0.7, len(x))</code>用于生成一个0.2到0.7的等差数列，长度与数据点个数相同。这些数值用于定义扇区的颜色，颜色逐渐从浅蓝到深蓝。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.pie(x, colors=colors, radius=3, center=(4, 4), wedgeprops=&#123;&quot;linewidth&quot;: 1, &quot;edgecolor&quot;: &quot;white&quot;&#125;, frame=True)</code>: 使用<code>ax.pie</code>函数绘制饼图。<code>x</code>是要绘制的数据，<code>colors=colors</code>用于设置扇区的颜色，<code>radius=3</code>设置饼图的半径为3个单位，<code>center=(4, 4)</code>设置饼图的中心位置为坐标(4, 4)处，<code>wedgeprops=&#123;&quot;linewidth&quot;: 1, &quot;edgecolor&quot;: &quot;white&quot;&#125;</code>用于设置扇区边界的线宽和颜色，<code>frame=True</code>表示显示饼图的边框。</p></li><li><p><code>ax.set(xlim=(0, 8), xticks=np.arange(1, 8), ylim=(0, 8), yticks=np.arange(1, 8))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围和刻度位置。<code>xlim=(0, 8)</code>设置x轴显示范围为0到8，<code>xticks=np.arange(1, 8)</code>设置x轴的刻度位置为1到7，<code>ylim=(0, 8)</code>设置y轴显示范围为0到8，<code>yticks=np.arange(1, 8)</code>设置y轴的刻度位置为1到7。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个饼图，用于展示一组数据的占比情况。每个数据点对应饼图中的一个扇区，扇区的面积表示该数据点在总体中的占比。颜色从浅蓝到深蓝逐渐变化，用于区分不同的数据点。饼图是一种常用的可视化方式，适用于展示不同类别在总体中的比例关系。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_pie_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_pie_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="pie"><h3 id="三角剖分等高线图"><a href="#三角剖分等高线图" class="headerlink" title="三角剖分等高线图"></a>三角剖分等高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">y = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">levels = np.linspace(z.<span class="built_in">min</span>(), z.<span class="built_in">max</span>(), <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;o&#x27;</span>, markersize=<span class="number">2</span>, color=<span class="string">&#x27;lightgrey&#x27;</span>)</span><br><span class="line">ax.tricontour(x, y, z, levels=levels)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">3</span>, <span class="number">3</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组x，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>y = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组y，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)</code>: 生成一个包含256个随机数的数组z，其中z是通过对x、y进行一系列数学运算得到的。具体地，z是通过以下公式计算得到的：z &#x3D; (1 - x&#x2F;2 + x<strong>5 + y</strong>3) * np.exp(-x<strong>2 - y</strong>2)。</p></li><li><p><code>levels = np.linspace(z.min(), z.max(), 7)</code>: 使用<code>np.linspace</code>函数生成一个包含7个数值的等差数列，这些数值在z的最小值和最大值之间。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.plot(x, y, &#39;o&#39;, markersize=2, color=&#39;lightgrey&#39;)</code>: 使用<code>ax.plot</code>函数绘制原始数据点。在这里，将x、y作为散点图绘制在图中，并使用<code>&#39;o&#39;</code>表示散点形状为圆圈，<code>markersize=2</code>设置散点的大小为2个单位，<code>color=&#39;lightgrey&#39;</code>设置散点的颜色为浅灰色。</p></li><li><p><code>ax.tricontour(x, y, z, levels=levels)</code>: 使用<code>ax.tricontour</code>函数绘制三角剖分等高线图。<code>x</code>、<code>y</code>是原始数据点的坐标，<code>z</code>是对应的高度值，<code>levels=levels</code>用于设置等高线的数值。</p></li><li><p><code>ax.set(xlim=(-3, 3), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-3, 3)</code>设置x轴显示范围为-3到3，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个三角剖分等高线图，用于展示二维数据在三维空间中的等高线分布情况。三角剖分等高线图适用于处理在不规则网格上的数据点，可以更准确地表示数据的分布情况，并帮助我们理解数据的变化趋势。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_tricontour_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_tricontour_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="tricontour"><h3 id="填充三角剖分等高线图"><a href="#填充三角剖分等高线图" class="headerlink" title="填充三角剖分等高线图"></a>填充三角剖分等高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">y = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line">levels = np.linspace(z.<span class="built_in">min</span>(), z.<span class="built_in">max</span>(), <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;o&#x27;</span>, markersize=<span class="number">2</span>, color=<span class="string">&#x27;grey&#x27;</span>)</span><br><span class="line">ax.tricontourf(x, y, z, levels=levels)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">3</span>, <span class="number">3</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组x，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>y = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组y，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)</code>: 生成一个包含256个随机数的数组z，其中z是通过对x、y进行一系列数学运算得到的。具体地，z是通过以下公式计算得到的：z &#x3D; (1 - x&#x2F;2 + x<strong>5 + y</strong>3) * np.exp(-x<strong>2 - y</strong>2)。</p></li><li><p><code>levels = np.linspace(z.min(), z.max(), 7)</code>: 使用<code>np.linspace</code>函数生成一个包含7个数值的等差数列，这些数值在z的最小值和最大值之间。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.plot(x, y, &#39;o&#39;, markersize=2, color=&#39;grey&#39;)</code>: 使用<code>ax.plot</code>函数绘制原始数据点。在这里，将x、y作为散点图绘制在图中，并使用<code>&#39;o&#39;</code>表示散点形状为圆圈，<code>markersize=2</code>设置散点的大小为2个单位，<code>color=&#39;grey&#39;</code>设置散点的颜色为灰色。</p></li><li><p><code>ax.tricontourf(x, y, z, levels=levels)</code>: 使用<code>ax.tricontourf</code>函数绘制填充三角剖分等高线图。<code>x</code>、<code>y</code>是原始数据点的坐标，<code>z</code>是对应的高度值，<code>levels=levels</code>用于设置等高线的数值，并且使用填充颜色表示等高线区域。</p></li><li><p><code>ax.set(xlim=(-3, 3), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-3, 3)</code>设置x轴显示范围为-3到3，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个填充三角剖分等高线图，用于展示二维数据在三维空间中的等高线分布情况，并通过填充颜色来强调不同高度区域的差异。填充三角剖分等高线图适用于处理在不规则网格上的数据点，并且通过填充颜色可以更直观地表示数据的变化趋势。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_tricontourf_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_tricontourf_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="tricontourf"><h3 id="三角剖分彩色图"><a href="#三角剖分彩色图" class="headerlink" title="三角剖分彩色图"></a>三角剖分彩色图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">y = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;o&#x27;</span>, markersize=<span class="number">2</span>, color=<span class="string">&#x27;grey&#x27;</span>)</span><br><span class="line">ax.tripcolor(x, y, z)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">3</span>, <span class="number">3</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组x，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>y = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组y，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)</code>: 生成一个包含256个随机数的数组z，其中z是通过对x、y进行一系列数学运算得到的。具体地，z是通过以下公式计算得到的：z &#x3D; (1 - x&#x2F;2 + x<strong>5 + y</strong>3) * np.exp(-x<strong>2 - y</strong>2)。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.plot(x, y, &#39;o&#39;, markersize=2, color=&#39;grey&#39;)</code>: 使用<code>ax.plot</code>函数绘制原始数据点。在这里，将x、y作为散点图绘制在图中，并使用<code>&#39;o&#39;</code>表示散点形状为圆圈，<code>markersize=2</code>设置散点的大小为2个单位，<code>color=&#39;grey&#39;</code>设置散点的颜色为灰色。</p></li><li><p><code>ax.tripcolor(x, y, z)</code>: 使用<code>ax.tripcolor</code>函数绘制三角剖分彩色图。<code>x</code>、<code>y</code>是原始数据点的坐标，<code>z</code>是对应的高度值，函数将根据数据点的三角剖分情况来着色，形成彩色的三角区域。</p></li><li><p><code>ax.set(xlim=(-3, 3), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-3, 3)</code>设置x轴显示范围为-3到3，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个三角剖分彩色图，用于展示二维数据在三维空间中的变化情况，并通过彩色表示不同高度区域的差异。三角剖分彩色图适用于处理在不规则网格上的数据点，并且通过彩色能够更直观地表示数据的变化趋势。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_tripcolor_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_tripcolor_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="tripcolor"><h3 id="三角剖分图"><a href="#三角剖分图" class="headerlink" title="三角剖分图"></a>三角剖分图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery-nogrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data:</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">y = np.random.uniform(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">z = (<span class="number">1</span> - x/<span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> - y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot:</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">ax.triplot(x, y)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xlim=(-<span class="number">3</span>, <span class="number">3</span>), ylim=(-<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery-nogrid&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery-nogrid&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(1)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>x = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组x，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>y = np.random.uniform(-3, 3, 256)</code>: 生成一个包含256个随机数的数组y，这些随机数是从-3到3的均匀分布中生成的。</p></li><li><p><code>z = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)</code>: 生成一个包含256个随机数的数组z，其中z是通过对x、y进行一系列数学运算得到的。具体地，z是通过以下公式计算得到的：z &#x3D; (1 - x&#x2F;2 + x<strong>5 + y</strong>3) * np.exp(-x<strong>2 - y</strong>2)。</p></li><li><p><code>fig, ax = plt.subplots()</code>: 创建一个图形对象和一个坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的坐标轴。</p></li><li><p><code>ax.triplot(x, y)</code>: 使用<code>ax.triplot</code>函数绘制三角剖分图。<code>x</code>、<code>y</code>是原始数据点的坐标，函数会根据这些数据点之间的三角剖分关系绘制三角网格。</p></li><li><p><code>ax.set(xlim=(-3, 3), ylim=(-3, 3))</code>: 使用<code>ax.set</code>方法设置坐标轴的显示范围。<code>xlim=(-3, 3)</code>设置x轴显示范围为-3到3，<code>ylim=(-3, 3)</code>设置y轴显示范围为-3到3。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码将绘制一个三角剖分图，用于展示二维数据在三维空间中的数据点之间的三角剖分关系。三角剖分图适用于处理在不规则网格上的数据点，并且通过三角网格可以更直观地表示数据点之间的连接关系。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_triplot_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_triplot_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="triplot"><h3 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make data</span></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">rng = np.random.default_rng()</span><br><span class="line">xs = rng.uniform(<span class="number">23</span>, <span class="number">32</span>, n)</span><br><span class="line">ys = rng.uniform(<span class="number">0</span>, <span class="number">100</span>, n)</span><br><span class="line">zs = rng.uniform(-<span class="number">50</span>, -<span class="number">25</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>: <span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.scatter(xs, ys, zs)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xticklabels=[],</span><br><span class="line">       yticklabels=[],</span><br><span class="line">       zticklabels=[])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>import numpy as np</code>: 导入NumPy库，并将其简化为<code>np</code>，NumPy是用于数值计算的Python库。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>np.random.seed(19680801)</code>: 设置随机数种子，保证每次运行代码生成的随机数据都是一样的，便于复现结果。</p></li><li><p><code>n = 100</code>: 定义数据点的数量。</p></li><li><p><code>rng = np.random.default_rng()</code>: 创建一个随机数生成器对象。</p></li><li><p><code>xs = rng.uniform(23, 32, n)</code>: 用随机数生成器生成包含100个随机数的数组<code>xs</code>，这些随机数是从23到32的均匀分布中生成的。</p></li><li><p><code>ys = rng.uniform(0, 100, n)</code>: 用随机数生成器生成包含100个随机数的数组<code>ys</code>，这些随机数是从0到100的均匀分布中生成的。</p></li><li><p><code>zs = rng.uniform(-50, -25, n)</code>: 用随机数生成器生成包含100个随机数的数组<code>zs</code>，这些随机数是从-50到-25的均匀分布中生成的。</p></li><li><p><code>fig, ax = plt.subplots(subplot_kw=&#123;&quot;projection&quot;: &quot;3d&quot;&#125;)</code>: 创建一个带有三维坐标轴的图形对象和一个三维坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的三维坐标轴。</p></li><li><p><code>ax.scatter(xs, ys, zs)</code>: 使用<code>ax.scatter</code>函数绘制三维散点图。<code>xs</code>、<code>ys</code>、<code>zs</code>是数据点的x、y、z坐标，函数会在三维坐标轴上绘制这些数据点。</p></li><li><p><code>ax.set(xticklabels=[], yticklabels=[], zticklabels=[])</code>: 设置三维坐标轴的刻度标签为空，这样就隐藏了x、y、z轴的刻度标签。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码绘制了一个简单的三维散点图，其中包含了100个随机生成的数据点，用于展示数据在三维空间中的分布情况。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_scatter3d_simple_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_scatter3d_simple_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="scatter"><h3 id="三维曲面图"><a href="#三维曲面图" class="headerlink" title="三维曲面图"></a>三维曲面图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make data</span></span><br><span class="line">X = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.25</span>)</span><br><span class="line">Y = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.25</span>)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">R = np.sqrt(X**<span class="number">2</span> + Y**<span class="number">2</span>)</span><br><span class="line">Z = np.sin(R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the surface</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>: <span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_surface(X, Y, Z, vmin=Z.<span class="built_in">min</span>() * <span class="number">2</span>, cmap=cm.Blues)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xticklabels=[],</span><br><span class="line">       yticklabels=[],</span><br><span class="line">       zticklabels=[])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>from matplotlib import cm</code>: 从Matplotlib库中导入<code>cm</code>，用于获取颜色映射(colormap)。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X = np.arange(-5, 5, 0.25)</code>: 创建一个包含从-5到5的间隔为0.25的一维数组<code>X</code>。</p></li><li><p><code>Y = np.arange(-5, 5, 0.25)</code>: 创建一个包含从-5到5的间隔为0.25的一维数组<code>Y</code>。</p></li><li><p><code>X, Y = np.meshgrid(X, Y)</code>: 将<code>X</code>和<code>Y</code>组合成一个二维网格，生成<code>X</code>和<code>Y</code>的二维数组，分别表示X和Y坐标的网格。</p></li><li><p><code>R = np.sqrt(X**2 + Y**2)</code>: 计算每个点到原点(0,0)的距离，得到一个二维数组<code>R</code>。</p></li><li><p><code>Z = np.sin(R)</code>: 计算每个点的正弦值，得到一个二维数组<code>Z</code>。</p></li><li><p><code>fig, ax = plt.subplots(subplot_kw=&#123;&quot;projection&quot;: &quot;3d&quot;&#125;)</code>: 创建一个带有三维坐标轴的图形对象和一个三维坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的三维坐标轴。</p></li><li><p><code>ax.plot_surface(X, Y, Z, vmin=Z.min() * 2, cmap=cm.Blues)</code>: 使用<code>ax.plot_surface</code>函数绘制三维曲面图。<code>X</code>、<code>Y</code>、<code>Z</code>分别表示数据点的x、y、z坐标，函数会根据这些坐标在三维坐标轴上绘制曲面。<code>vmin</code>参数设置颜色映射的最小值，这里将其设置为<code>Z.min() * 2</code>，即z值的最小值的两倍。<code>cmap=cm.Blues</code>设置颜色映射为蓝色调。</p></li><li><p><code>ax.set(xticklabels=[], yticklabels=[], zticklabels=[])</code>: 设置三维坐标轴的刻度标签为空，这样就隐藏了x、y、z轴的刻度标签。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码绘制了一个包含正弦函数在二维平面上的三维曲面图，颜色随着z值的变化而变化，呈现出蓝色调的效果。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_surface3d_simple_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_surface3d_simple_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="plot_surface"><h3 id="三维三角网面图"><a href="#三维三角网面图" class="headerlink" title="三维三角网面图"></a>三维三角网面图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line">n_radii = <span class="number">8</span></span><br><span class="line">n_angles = <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make radii and angles spaces</span></span><br><span class="line">radii = np.linspace(<span class="number">0.125</span>, <span class="number">1.0</span>, n_radii)</span><br><span class="line">angles = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, n_angles, endpoint=<span class="literal">False</span>)[..., np.newaxis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert polar (radii, angles) coords to cartesian (x, y) coords.</span></span><br><span class="line">x = np.append(<span class="number">0</span>, (radii*np.cos(angles)).flatten())</span><br><span class="line">y = np.append(<span class="number">0</span>, (radii*np.sin(angles)).flatten())</span><br><span class="line">z = np.sin(-x*y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=&#123;<span class="string">&#x27;projection&#x27;</span>: <span class="string">&#x27;3d&#x27;</span>&#125;)</span><br><span class="line">ax.plot_trisurf(x, y, z, vmin=z.<span class="built_in">min</span>() * <span class="number">2</span>, cmap=cm.Blues)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xticklabels=[],</span><br><span class="line">       yticklabels=[],</span><br><span class="line">       zticklabels=[])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>from matplotlib import cm</code>: 从Matplotlib库中导入<code>cm</code>，用于获取颜色映射(colormap)。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>n_radii = 8</code>: 定义半径的数量。</p></li><li><p><code>n_angles = 36</code>: 定义角度的数量。</p></li><li><p><code>radii = np.linspace(0.125, 1.0, n_radii)</code>: 创建一个包含8个均匀间隔的半径值的一维数组<code>radii</code>，范围从0.125到1.0。</p></li><li><p><code>angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]</code>: 创建一个包含36个均匀间隔的角度值的一维数组<code>angles</code>，范围从0到2π，每个角度值都用一个维度表示。</p></li><li><p><code>x = np.append(0, (radii*np.cos(angles)).flatten())</code>: 计算x坐标值，<code>radii*np.cos(angles)</code>将极坐标转换为直角坐标，并使用<code>flatten()</code>将二维数组展平成一维数组。然后通过<code>np.append()</code>函数在数组的开头插入0，以使得曲面图在原点处闭合。</p></li><li><p><code>y = np.append(0, (radii*np.sin(angles)).flatten())</code>: 计算y坐标值，<code>radii*np.sin(angles)</code>将极坐标转换为直角坐标，并使用<code>flatten()</code>将二维数组展平成一维数组。然后通过<code>np.append()</code>函数在数组的开头插入0，以使得曲面图在原点处闭合。</p></li><li><p><code>z = np.sin(-x*y)</code>: 计算z坐标值，根据x和y的值计算z的值，这里使用了正弦函数。</p></li><li><p><code>fig, ax = plt.subplots(subplot_kw=&#123;&#39;projection&#39;: &#39;3d&#39;&#125;)</code>: 创建一个带有三维坐标轴的图形对象和一个三维坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的三维坐标轴。</p></li><li><p><code>ax.plot_trisurf(x, y, z, vmin=z.min() * 2, cmap=cm.Blues)</code>: 使用<code>ax.plot_trisurf</code>函数绘制三维三角网面图。<code>x</code>、<code>y</code>、<code>z</code>分别表示数据点的x、y、z坐标，函数会根据这些坐标在三维坐标轴上绘制三角网面图。<code>vmin</code>参数设置颜色映射的最小值，这里将其设置为<code>z.min() * 2</code>，即z值的最小值的两倍。<code>cmap=cm.Blues</code>设置颜色映射为蓝色调。</p></li><li><p><code>ax.set(xticklabels=[], yticklabels=[], zticklabels=[])</code>: 设置三维坐标轴的刻度标签为空，这样就隐藏了x、y、z轴的刻度标签。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码绘制了一个在极坐标系下的三维三角网面图，颜色随着z值的变化而变化，呈现出蓝色调的效果。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_trisurf3d_simple_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_trisurf3d_simple_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="plot_trisurf"><h3 id="三维体素图"><a href="#三维体素图" class="headerlink" title="三维体素图"></a>三维体素图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare some coordinates</span></span><br><span class="line">x, y, z = np.indices((<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw cuboids in the top left and bottom right corners</span></span><br><span class="line">cube1 = (x &lt; <span class="number">3</span>) &amp; (y &lt; <span class="number">3</span>) &amp; (z &lt; <span class="number">3</span>)</span><br><span class="line">cube2 = (x &gt;= <span class="number">5</span>) &amp; (y &gt;= <span class="number">5</span>) &amp; (z &gt;= <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Combine the objects into a single boolean array</span></span><br><span class="line">voxelarray = cube1 | cube2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>: <span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.voxels(voxelarray, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xticklabels=[],</span><br><span class="line">       yticklabels=[],</span><br><span class="line">       zticklabels=[])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>x, y, z = np.indices((8, 8, 8))</code>: 创建了一个3D坐标网格，其中x、y和z坐标都取值范围为0到7。这样可以得到一个8x8x8的三维网格。</p></li><li><p><code>cube1 = (x &lt; 3) &amp; (y &lt; 3) &amp; (z &lt; 3)</code>: 创建了一个立方体1，它包含了坐标点(x, y, z)满足x &lt; 3、y &lt; 3和z &lt; 3的所有点。</p></li><li><p><code>cube2 = (x &gt;= 5) &amp; (y &gt;= 5) &amp; (z &gt;= 5)</code>: 创建了一个立方体2，它包含了坐标点(x, y, z)满足x &gt;&#x3D; 5、y &gt;&#x3D; 5和z &gt;&#x3D; 5的所有点。</p></li><li><p><code>voxelarray = cube1 | cube2</code>: 将立方体1和立方体2组合成一个单一的布尔数组voxelarray。在这个数组中，值为True的元素表示在立方体内，值为False的元素表示在立方体外。</p></li><li><p><code>fig, ax = plt.subplots(subplot_kw=&#123;&quot;projection&quot;: &quot;3d&quot;&#125;)</code>: 创建一个带有三维坐标轴的图形对象和一个三维坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的三维坐标轴。</p></li><li><p><code>ax.voxels(voxelarray, edgecolor=&#39;k&#39;)</code>: 使用<code>ax.voxels</code>函数绘制三维体素图。<code>voxelarray</code>表示要绘制的体素的布尔数组，<code>edgecolor=&#39;k&#39;</code>设置体素的边缘颜色为黑色。</p></li><li><p><code>ax.set(xticklabels=[], yticklabels=[], zticklabels=[])</code>: 设置三维坐标轴的刻度标签为空，这样就隐藏了x、y、z轴的刻度标签。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码绘制了一个简单的三维体素图，其中包含两个立方体。其中一个立方体位于三维空间的左上角，另一个立方体位于右下角。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_voxels_simple_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_voxels_simple_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="voxels"><h3 id="三维线框图"><a href="#三维线框图" class="headerlink" title="三维线框图"></a>三维线框图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> axes3d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;_mpl-gallery&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make data</span></span><br><span class="line">X, Y, Z = axes3d.get_test_data(<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=&#123;<span class="string">&quot;projection&quot;</span>: <span class="string">&quot;3d&quot;</span>&#125;)</span><br><span class="line">ax.plot_wireframe(X, Y, Z, rstride=<span class="number">10</span>, cstride=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ax.<span class="built_in">set</span>(xticklabels=[],</span><br><span class="line">       yticklabels=[],</span><br><span class="line">       zticklabels=[])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><p><code>from mpl_toolkits.mplot3d import axes3d</code>: 导入Matplotlib中的<code>axes3d</code>模块，这个模块包含了用于绘制三维图形的函数和工具。</p></li><li><p><code>import matplotlib.pyplot as plt</code>: 导入Matplotlib库，并将其简化为<code>plt</code>，这是Matplotlib中常用的惯例。</p></li><li><p><code>plt.style.use(&#39;_mpl-gallery&#39;)</code>: 这里使用了一个自定义的Matplotlib样式<code>&#39;_mpl-gallery&#39;</code>。Matplotlib样式用于设置图形的外观和风格。在此之前可能有一个自定义的样式定义，但代码片段中没有显示出来。</p></li><li><p><code>X, Y, Z = axes3d.get_test_data(0.05)</code>: 使用<code>axes3d.get_test_data()</code>函数获取测试数据。这个函数返回了一个包含X、Y、Z坐标数据的三维网格，用于绘制一个三维曲面。<code>0.05</code>是步长参数，控制数据的稠密程度。</p></li><li><p><code>fig, ax = plt.subplots(subplot_kw=&#123;&quot;projection&quot;: &quot;3d&quot;&#125;)</code>: 创建一个带有三维坐标轴的图形对象和一个三维坐标轴对象。<code>fig</code>代表整个图形窗口，<code>ax</code>代表图形中的三维坐标轴。</p></li><li><p><code>ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)</code>: 使用<code>ax.plot_wireframe()</code>函数绘制三维线框图。<code>X</code>、<code>Y</code>、<code>Z</code>是三维曲面的坐标数据，<code>rstride</code>和<code>cstride</code>分别控制行和列的采样步长，用于控制曲面的稠密程度。</p></li><li><p><code>ax.set(xticklabels=[], yticklabels=[], zticklabels=[])</code>: 设置三维坐标轴的刻度标签为空，这样就隐藏了x、y、z轴的刻度标签。</p></li><li><p><code>plt.show()</code>: 显示绘制的图形。</p></li></ol><p>这段代码绘制了一个三维线框图，该图显示了一个曲面的结构，曲面的形状基于获取的测试数据。三维线框图通过连接数据点之间的线条来表示曲面的形状，使得可以更好地了解曲面的结构和特征。</p><img src="https://matplotlib.org/stable/_images/sphx_glr_wire3d_simple_001_2_00x.png" class="lazyload placeholder" data-srcset="https://matplotlib.org/stable/_images/sphx_glr_wire3d_simple_001_2_00x.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="plot_wireframe">]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN算法简析</title>
      <link href="/2023/07/27/KNN%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/"/>
      <url>/2023/07/27/KNN%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="KNN算法简析"><a href="#KNN算法简析" class="headerlink" title="KNN算法简析"></a>KNN算法简析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>K最近邻算法（K-Nearest Neighbors，KNN）是一种常用的监督学习算法，用于分类和回归问题。它是一种简单而有效的算法，在实践中广泛应用。KNN算法基于实例之间的相似性来进行分类或回归预测。</p><p>以下是KNN算法的概述：</p><ol><li><p>算法原理：</p><ul><li>对于分类问题，KNN算法通过测量新样本点与训练数据集中已标记样本点之间的距离来进行分类。它选择与新样本点距离最近的K个已标记样本点，并根据这K个点中占多数的类别来对新样本进行分类。</li><li>对于回归问题，KNN算法计算新样本点与训练数据集中已标记样本点之间的距离，然后选择距离最近的K个样本点，并使用这K个样本点的平均值（或加权平均值）作为新样本点的预测值。</li></ul></li><li><p>距离度量：</p><ul><li>在KNN算法中，常用的距离度量方法包括欧氏距离（Euclidean distance）、曼哈顿距离（Manhattan distance）和闵可夫斯基距离（Minkowski distance）。欧氏距离在连续特征空间中广泛使用，而曼哈顿距离对于具有稀疏特征的数据集更为适用。</li></ul></li><li><p>确定K值：</p><ul><li>K值是KNN算法中的一个重要参数。它表示选择多少个最近邻来进行分类或回归。较小的K值可能会导致模型复杂，容易受到噪声的影响，而较大的K值可能会导致模型过于简单，忽略了局部的数据模式。通常，K值的选择通过交叉验证等技术来进行调优。</li></ul></li><li><p>优缺点：</p><ul><li>优点：KNN算法简单易懂，易于实现，对于多类别问题表现良好。它不需要对数据进行假设，适用于非线性数据。</li><li>缺点：KNN算法计算复杂度较高，特别是在大规模数据集上。对于高维数据，容易受到维度灾难的影响。此外，KNN算法对于不平衡数据集的处理效果可能较差。</li></ul></li><li><p>实现步骤：</p><ul><li>加载数据集。</li><li>选择距离度量方法。</li><li>选择K值。</li><li>对于分类问题，计算新样本与训练样本的距离，选择最近的K个样本进行投票得出分类结果。</li><li>对于回归问题，计算新样本与训练样本的距离，选择最近的K个样本进行平均（或加权平均）得出预测值。</li></ul></li></ol><p>总结：KNN算法是一种简单而强大的算法，适用于许多分类和回归问题。它的实现简单，但在大规模数据集上计算效率较低。合理选择K值以及适当的距离度量方法是使用KNN算法时需要注意的要点。</p><h2 id="涉及到的数学公式"><a href="#涉及到的数学公式" class="headerlink" title="涉及到的数学公式"></a>涉及到的数学公式</h2><ol><li><p>欧氏距离（Euclidean distance）：<br>$$ d(A, B) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n}(x_i - y_i)^2} $$</p></li><li><p>曼哈顿距离（Manhattan distance）：<br>$$ d(A, B) &#x3D; \sum_{i&#x3D;1}^{n}|x_i - y_i| $$</p></li><li><p>KNN分类公式：<br>$$ \text{Class}(\text{new_sample}) &#x3D; \text{argmax}\left(\sum_{i}{\mathbb{I}(label_i &#x3D; c) \text{ for } i \text{ in neighbors}}\right) $$</p><p> 其中，$\text{Class}(\text{new_sample})$ 表示新样本点的预测类别，$label_i$ 是第 $i$ 个邻居样本的类别，$c$ 表示所有可能的类别，$\mathbb{I}(condition)$ 是指示函数，如果 $condition$ 为真，则 $\mathbb{I}(condition) &#x3D; 1$，否则为 0。 $\text{argmax}$ 函数返回使括号内表达式最大的类别 $c$。</p></li><li><p>KNN回归公式：<br>$$ \text{Prediction}(\text{new_sample}) &#x3D; \frac{1}{K}\sum_{i}{label_i \text{ for } i \text{ in neighbors}} $$</p></li></ol><p>其中，$\text{Prediction}(\text{new_sample})$ 表示新样本点的回归预测值，$label_i$ 是第 $i$ 个邻居样本的回归标签。</p><h3 id="欧式距离与曼哈顿距离"><a href="#欧式距离与曼哈顿距离" class="headerlink" title="欧式距离与曼哈顿距离"></a>欧式距离与曼哈顿距离</h3><p>欧式距离（Euclidean distance）和曼哈顿距离（Manhattan distance）是两种常用的距离度量方法，用于衡量在n维空间中两个点之间的距离。它们在计算方法和性质上有一些异同：</p><p>异同点如下：</p><ol><li><p>计算方法：</p><ul><li><p>欧式距离：欧式距离是两点之间直线距离的度量，也称为直线距离。在n维空间中，欧式距离计算公式为：<br>$$ d_{\text{euclidean}}(A, B) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n}(x_i - y_i)^2} $$</p></li><li><p>曼哈顿距离：曼哈顿距离是两点之间沿坐标轴方向的距离之和，也称为城市街区距离。在n维空间中，曼哈顿距离计算公式为：<br>$$ d_{\text{manhattan}}(A, B) &#x3D; \sum_{i&#x3D;1}^{n}|x_i - y_i| $$</p></li></ul></li><li><p>距离形状：</p><ul><li>欧式距离：欧式距离在几何上对应于直线的长度，因此在n维空间中呈现圆形等距离轮廓。</li><li>曼哈顿距离：曼哈顿距离在几何上对应于沿坐标轴方向的步行距离，因此在n维空间中呈现方形等距离轮廓。</li></ul></li><li><p>敏感度：</p><ul><li>欧式距离：欧式距离对各个维度的差异比较敏感，当特征维度之间的差异很大时，欧式距离可能会受到影响。</li><li>曼哈顿距离：曼哈顿距离对各个维度的差异不那么敏感，因为它只考虑了沿坐标轴方向的距离。</li></ul></li><li><p>计算效率：</p><ul><li>欧式距离：计算欧式距离需要进行平方和开方的运算，计算相对较慢。</li><li>曼哈顿距离：计算曼哈顿距离只需要进行绝对值和求和运算，计算相对较快。</li></ul></li></ol><p>在实际应用中，选择使用欧式距离还是曼哈顿距离取决于数据的特点和具体问题。通常情况下，欧式距离更适合用于连续特征空间，而曼哈顿距离更适合用于具有稀疏特征或特征之间具有明显分隔的数据。在KNN算法中，我们可以根据实际情况选择合适的距离度量方法来获得更好的分类或回归结果。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KNNClassifier</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k=<span class="number">3</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize the KNNClassifier.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            k (int): Number of nearest neighbors to consider for classification. Default is 3.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.X_train = <span class="literal">None</span></span><br><span class="line">        self.y_train = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X_train, y_train</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Train the KNN classifier.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            X_train (numpy.ndarray): Training feature matrix.</span></span><br><span class="line"><span class="string">            y_train (numpy.ndarray): Labels for the training data.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.X_train = X_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_euclidean_distance</span>(<span class="params">self, point1, point2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calculate the Euclidean distance between two points.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            point1 (numpy.ndarray): First data point.</span></span><br><span class="line"><span class="string">            point2 (numpy.ndarray): Second data point.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            float: The Euclidean distance between the two points.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.sqrt(np.<span class="built_in">sum</span>((point1 - point2) ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X_test, predict_type=<span class="string">&quot;classify&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Predict class labels or regression values for the given input data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            X_test (numpy.ndarray): Input feature matrix for prediction.</span></span><br><span class="line"><span class="string">            predict_type (str): Type of prediction, either &quot;classify&quot; or &quot;regress&quot;. Default is &quot;classify&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            numpy.ndarray: Predicted class labels or regression values.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> predict_type == <span class="string">&quot;classify&quot;</span>:</span><br><span class="line">            y_pred = [self._predict_single_classify(x) <span class="keyword">for</span> x <span class="keyword">in</span> X_test]</span><br><span class="line">            <span class="keyword">return</span> np.array(y_pred)</span><br><span class="line">        <span class="keyword">if</span> predict_type == <span class="string">&quot;regress&quot;</span>:</span><br><span class="line">            y_pred = [self._predict_single_regress(x) <span class="keyword">for</span> x <span class="keyword">in</span> X_test]</span><br><span class="line">            <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_predict_single_classify</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Classify a single data point.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            x (numpy.ndarray): Input data point for classification.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            int: Predicted class label for the input data point.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        distances = [self._euclidean_distance(x, x_train) <span class="keyword">for</span> x_train <span class="keyword">in</span> self.X_train]</span><br><span class="line">        k_indices = np.argsort(distances)[:self.k]  <span class="comment"># Get indices of k nearest neighbors</span></span><br><span class="line">        k_nearest_labels = [self.y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> k_indices]  <span class="comment"># Get class labels of k nearest neighbors</span></span><br><span class="line">        most_common = Counter(k_nearest_labels).most_common(</span><br><span class="line">            <span class="number">1</span>)  <span class="comment"># Find the most common class label among k nearest neighbors</span></span><br><span class="line">        <span class="keyword">return</span> most_common[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_predict_single_regress</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Make a regression prediction for a single data point.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            x (numpy.ndarray): Input data point for regression prediction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            float: Predicted regression value for the input data point.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        distances = [self._euclidean_distance(x, x_train) <span class="keyword">for</span> x_train <span class="keyword">in</span> self.X_train]</span><br><span class="line">        k_indices = np.argsort(distances)[:self.k]  <span class="comment"># Get indices of k nearest neighbors</span></span><br><span class="line">        k_nearest_y = [self.y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> k_indices]  <span class="comment"># Get target values of k nearest neighbors</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(k_nearest_y)  <span class="comment"># Use the mean of nearest target values as the prediction</span></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>类的使用方式</p><ol><li>导入该类：<code>from knn_classifier import KNNClassifier</code> (假设该类的定义保存在名为 <code>knn_classifier.py</code> 的文件中)</li><li>创建KNN分类器对象：<code>knn = KNNClassifier(k=k_value)</code>，其中 <code>k_value</code> 是最近邻居的数量，可以选择性地指定，默认为 3。</li><li>使用训练数据对分类器进行训练：<code>knn.fit(X_train, y_train)</code>，其中 <code>X_train</code> 是训练数据的特征矩阵，<code>y_train</code> 是对应的类标签。</li><li>对新数据进行预测：<code>predictions = knn.predict(X_test, predict_type=&quot;classify&quot;)</code>，其中 <code>X_test</code> 是包含新数据点的特征矩阵，<code>predict_type</code> 可以选择 “classify” 或 “regress”，分别用于分类和回归预测。</li></ol><p>方法说明</p><ol><li><code>__init__(self, k=3)</code>: 构造函数，初始化 KNN 分类器对象，可以传入最近邻居的数量 <code>k</code>，默认为 3。</li><li><code>fit(self, X_train, y_train)</code>: 训练 KNN 分类器，将特征矩阵 <code>X_train</code> 和对应的类标签 <code>y_train</code> 用于模型训练。</li><li><code>predict(self, X_test, predict_type=&quot;classify&quot;)</code>: 预测给定输入数据的类标签或回归值，根据 <code>predict_type</code> 参数选择分类预测或回归预测。</li><li><code>_euclidean_distance(self, point1, point2)</code>: 计算两个数据点之间的欧几里得距离。</li><li><code>_predict_single_classify(self, x)</code>: 对单个数据点进行分类预测，返回预测的类标签。</li><li><code>_predict_single_regress(self, x)</code>: 对单个数据点进行回归预测，返回预测的回归值。</li></ol><p>属性说明</p><ol><li><code>k</code>: 最近邻居的数量，在构造函数中初始化，用于 KNN 算法中指定最近的邻居数目。</li><li><code>X_train</code>: 训练数据的特征矩阵，用于存储训练过程中的输入特征。</li><li><code>y_train</code>: 训练数据的类标签，用于存储训练过程中的目标标签。</li></ol><h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一些示例数据</span></span><br><span class="line">X_train = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">2</span>], [<span class="number">7</span>, <span class="number">3</span>]])</span><br><span class="line">y_train = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">knn = KNNClassifier(k=<span class="number">3</span>)  <span class="comment"># 创建KNN分类器对象</span></span><br><span class="line">knn.fit(X_train, y_train)  <span class="comment"># 使用示例数据进行训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测新数据点</span></span><br><span class="line">X_test = np.array([[<span class="number">2</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">4</span>]])</span><br><span class="line">predictions = knn.predict(X_test, predict_type=<span class="string">&quot;classify&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测结果:&quot;</span>, predictions)</span><br></pre></td></tr></table></figure><p>以上代码展示了使用 <code>KNNClassifier</code> 类的示例用法。首先，我们创建一个包含两个类的示例数据集 <code>X_train</code> 和 <code>y_train</code>，然后创建了一个 <code>KNNClassifier</code> 对象，并使用示例数据进行训练。接着，我们使用新数据 <code>X_test</code> 对模型进行分类预测，并打印预测结果。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p><strong>特征缩放</strong>：KNN算法基于距离度量来进行分类或回归，因此特征的尺度会影响距离计算的结果。如果特征具有不同的尺度范围，建议进行特征缩放，确保各个特征对距离计算的影响相对均衡。常用的特征缩放方法包括标准化（z-score标准化）和归一化（min-max缩放）。</p></li><li><p><strong>K值的选择</strong>：KNN算法中的K值决定了用于分类或回归的最近邻样本的数量。选择适当的K值对算法的性能至关重要。较小的K值可能会导致模型过拟合，过于敏感，容易受到噪声的影响。较大的K值可能会导致模型过于简单，忽略了局部的数据模式。通常，K值的选择通过交叉验证等技术来进行调优。</p></li><li><p><strong>距离度量方法的选择</strong>：KNN算法需要选择适当的距离度量方法，例如欧氏距离、曼哈顿距离或其他距离度量方法。不同的距离度量方法适用于不同的数据类型和特征空间，因此在选择时需要根据数据的特点进行合理选择。</p></li><li><p><strong>数据量和计算复杂度</strong>：KNN算法在大规模数据集上的计算复杂度较高，因为它需要计算新样本与所有训练样本之间的距离。在处理大规模数据时，需要考虑使用更高效的数据结构和算法来加速计算过程。</p></li><li><p><strong>处理不平衡数据集</strong>：对于不平衡的数据集（某些类别样本数量较少），KNN算法可能会偏向于占主导地位的类别。这时可以考虑采用过采样、欠采样或合成新样本的方法来平衡数据集，以获得更好的分类结果。</p></li><li><p><strong>避免数据泄露</strong>：在使用KNN算法时，应确保测试集和训练集的样本是独立的，避免数据泄露。数据泄露可能导致模型在测试集上的表现过于乐观，无法真实地评估算法的性能。</p></li><li><p><strong>模型的解释性</strong>：KNN算法是一种基于实例的学习方法，它不生成显式的模型，因此模型的解释性较差。在某些应用场景中，模型的解释性可能是非常重要的，此时需要考虑其他类型的算法。</p></li></ol><p>综上所述，KNN算法是一种简单而强大的分类和回归算法，在实践中有广泛的应用。但要获得好的性能，需要合理选择K值、距离度量方法，并注意数据预处理等注意事项。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> K- Nearest Neighbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark与Scala</title>
      <link href="/2023/07/27/Spark%E4%B8%8EScala/"/>
      <url>/2023/07/27/Spark%E4%B8%8EScala/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark与Scala"><a href="#Spark与Scala" class="headerlink" title="Spark与Scala"></a>Spark与Scala</h1><p>Scala是一种通用的编程语言，旨在融合面向对象编程和函数式编程的特性。它运行在Java虚拟机（JVM）上，因此可以与Java库和框架无缝交互，并且可以利用Java生态系统中的各种工具和库。Scala的设计目标之一是让编程更具表现力和简洁，同时提供强大的类型系统和静态类型检查。</p><p>Apache Spark是一个开源的大数据处理框架，它旨在处理大规模数据集的分布式计算。Spark提供了许多用于处理数据的高级API，例如批处理（Spark Core）和流处理（Spark Streaming），还支持SQL查询（Spark SQL）、图处理（GraphX）和机器学习（MLlib）等功能。Spark的一个关键特点是其内存计算能力，它允许在内存中进行数据处理，从而大大提高了性能。</p><p>Scala与Spark之间有着密切的关系。事实上，Spark最初是用Scala编写的，并且Scala一直是Spark主要的编程语言。这是因为Scala语言具有与Spark的分布式计算模型和函数式编程特性非常契合的特点。Scala的函数式编程范式特性使得Spark的代码可以更具表现力和易读性，从而更容易编写和维护复杂的分布式计算任务。</p><p>Spark提供了Scala API以及其他语言（如Java、Python和R）的API，但Scala API通常被认为是最原生和最灵活的。许多Spark的核心开发人员和社区成员都喜欢使用Scala来编写Spark应用程序，因为Scala的语法和功能可以更好地利用Spark提供的高级特性，使得开发更加高效。</p><p>总结：Scala是Spark的主要编程语言，它与Spark之间有着紧密的关系，Scala的设计特点与Spark的分布式计算模型和函数式编程特性非常契合，使得使用Scala编写Spark应用程序更加方便和高效。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><div class="tagLink"><a class="link-card" title="Scala官网" href="https://www.scala-lang.org/"><span class="link-card-backdrop" style="background-image: url(https://www.scala-lang.org/resources/img/frontpage/scala-spiral.png)"></span><div class="left"><img src="https://www.scala-lang.org/resources/img/frontpage/scala-spiral.png" class="lazyload placeholder" data-srcset="https://www.scala-lang.org/resources/img/frontpage/scala-spiral.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Scala官网</p><p class="url">https://www.scala-lang.org/</p></div></a></div><div class="tagLink"><a class="link-card" title="Spark官网" href="https://spark.apache.org/"><span class="link-card-backdrop" style="background-image: url(https://spark.apache.org/images/spark-logo-rev.svg)"></span><div class="left"><img src="https://spark.apache.org/images/spark-logo-rev.svg" class="lazyload placeholder" data-srcset="https://spark.apache.org/images/spark-logo-rev.svg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">Spark官网</p><p class="url">https://spark.apache.org/</p></div></a></div><h2 id="使用IDEA构建一个Spark-Scala项目"><a href="#使用IDEA构建一个Spark-Scala项目" class="headerlink" title="使用IDEA构建一个Spark Scala项目"></a>使用IDEA构建一个Spark Scala项目</h2><ol><li><p>下载Scala</p></li><li><p>在IDEA中设置使用Scala语言<br>添加maven依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-sql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将Scala添加到全局库中</p></li><li><p>下载插件Scala并重启IDEA</p></li></ol><h2 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hankcs.hanlp.<span class="type">HanLP</span></span><br><span class="line"><span class="keyword">import</span> com.hankcs.hanlp.seg.common.<span class="type">Term</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SearchEngineLogAnalysis</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="type">Logger</span></span><br><span class="line">     .getLogger(<span class="string">&quot;org.apache.spark&quot;</span>)</span><br><span class="line">     .setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">   <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">     .setAppName(<span class="string">&quot;SearchEngineLogAnalysis&quot;</span>)</span><br><span class="line">     .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">   <span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(config = conf)</span><br><span class="line">   <span class="keyword">val</span> file = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/reduced.txt&quot;</span></span><br><span class="line">   <span class="keyword">val</span> outputPath1 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/queryWordsWordCountRDD&quot;</span></span><br><span class="line">   <span class="keyword">val</span> outputPath2 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/userQueryAnalysisRDD&quot;</span></span><br><span class="line">   <span class="keyword">val</span> outputPath3 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/timeQueryCountAnalysisRDD&quot;</span></span><br><span class="line">   <span class="keyword">val</span> rddSougouRecord = sparkContext.textFile(file)</span><br><span class="line">     .filter(line =&gt; line != <span class="literal">null</span> &amp;&amp; line.trim.split(<span class="string">&quot;\\s+&quot;</span>).length == <span class="number">6</span>)</span><br><span class="line">     .mapPartitions(it =&gt; &#123;</span><br><span class="line">       it.map(line =&gt; &#123;</span><br><span class="line">         <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">         <span class="type">SogouRecord</span>(</span><br><span class="line">           contents(<span class="number">0</span>),</span><br><span class="line">           contents(<span class="number">1</span>),</span><br><span class="line">           contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">           contents(<span class="number">3</span>).toInt,</span><br><span class="line">           contents(<span class="number">4</span>).toInt,</span><br><span class="line">           contents(<span class="number">5</span>)</span><br><span class="line">         )</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">   rddSougouRecord.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>).count()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> queryWordsWordCountRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">     it.flatMap(record =&gt; &#123;</span><br><span class="line">       <span class="keyword">val</span> terms: util.<span class="type">List</span>[<span class="type">Term</span>] = <span class="type">HanLP</span>.segment(record.queryWords.trim)</span><br><span class="line">       <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">       terms.asScala.map(_.word)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;).map((_, <span class="number">1</span>)).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">   queryWordsWordCountRDD.coalesce(numPartitions = <span class="number">1</span>).saveAsTextFile(outputPath1)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> userQueryAnalysisRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">     it.map(record =&gt; &#123;</span><br><span class="line">       ((record.userId, record.queryWords), <span class="number">1</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">   userQueryAnalysisRDD.coalesce(<span class="number">1</span>).saveAsTextFile(outputPath2)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> timeQueryCountAnalysisRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">     it.map(record =&gt; &#123;</span><br><span class="line">       (record.queryTime.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">   timeQueryCountAnalysisRDD.coalesce(<span class="number">1</span>).saveAsTextFile(outputPath3)</span><br><span class="line"></span><br><span class="line">   rddSougouRecord.unpersist()</span><br><span class="line">   sparkContext.stop()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐步分析"><a href="#逐步分析" class="headerlink" title="逐步分析"></a>逐步分析</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span></span><br><span class="line">  .getLogger(<span class="string">&quot;org.apache.spark&quot;</span>)</span><br><span class="line">  .setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br></pre></td></tr></table></figure><p>设置<code>org.apache.spark</code>的日志输出级别，可以在测试阶段更加方便的观察控制台的输出结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">  .setAppName(<span class="string">&quot;SearchEngineLogAnalysis&quot;</span>)</span><br><span class="line">  .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码是使用Scala语言创建一个Spark应用程序的配置对象（SparkConf），并对其进行一些设置。</p><ol><li><p><code>val conf = new SparkConf()</code>: 首先，创建了一个名为<code>conf</code>的不可变（val）变量，并通过<code>new SparkConf()</code>来实例化一个新的SparkConf对象。SparkConf是用于配置Spark应用程序的类。</p></li><li><p><code>.setAppName(&quot;SearchEngineLogAnalysis&quot;)</code>: 使用<code>.setAppName()</code>方法为Spark应用程序设置一个名称，这里将应用程序的名称设置为”SearchEngineLogAnalysis”。应用程序的名称将在Spark集群中显示，用于标识不同的应用程序。</p></li><li><p><code>.setMaster(&quot;local[*]&quot;)</code>: 使用<code>.setMaster()</code>方法设置Spark应用程序的主节点URL或本地模式。在这里，将主节点URL设置为”local[*]”，表示在本地模式下运行Spark应用程序，并使用所有可用的CPU内核。</p></li></ol><p>综合起来，这段代码的作用是创建一个Spark应用程序的配置对象，设置了应用程序的名称为<code>SearchEngineLogAnalysis</code>，并将其配置为在本地模式下运行，并使用所有可用的CPU内核进行并行处理。请注意，在本地模式下运行的Spark应用程序将不会连接到Spark集群，而是在本地计算机上以单机模式运行，适用于开发和测试阶段。在实际生产环境中，你需要将<code>.setMaster()</code>方法的参数设置为连接到Spark集群的主节点URL，以便在集群上分布式运行你的Spark应用程序。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(config = conf)</span><br></pre></td></tr></table></figure><p>这段代码用于创建一个SparkContext对象，它是Spark应用程序与Spark集群之间的主要接口。</p><ol><li><p><code>val sparkContext</code>: 这是一个不可变（val）变量，用于存储SparkContext对象。</p></li><li><p><code>new SparkContext(config = conf)</code>: 这是创建SparkContext对象的语句。通过<code>new SparkContext()</code>来实例化一个新的SparkContext对象，并通过<code>config = conf</code>参数将之前创建的SparkConf对象<code>conf</code>传递给SparkContext构造函数。</p></li></ol><p>在这里，我们使用之前配置好的SparkConf对象<code>conf</code>来初始化SparkContext。SparkConf对象包含了应用程序的各种配置设置，而SparkContext则使用这些配置在Spark集群上执行任务。</p><p>需要注意的是，创建SparkContext对象是Spark早期版本（2.x及之前）的做法。从Spark 2.0版本开始，推荐使用SparkSession来代替SparkContext。SparkSession是一个更高级的接口，它封装了SparkContext和SQLContext，并且提供了更方便的功能，例如对DataFrame和Dataset的支持。</p><p>如果在使用Spark 2.x及之后版本，建议改用SparkSession来初始化Spark应用程序，示例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder()</span><br><span class="line">  .appName(<span class="string">&quot;SearchEngineLogAnalysis&quot;</span>)</span><br><span class="line">  .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">  .getOrCreate()</span><br></pre></td></tr></table></figure><p>使用<code>SparkSession.builder()</code>来构建SparkSession对象，并使用<code>.appName()</code>方法设置应用程序名称，<code>.master()</code>方法设置主节点URL或本地模式。最后，通过<code>.getOrCreate()</code>方法来获取或创建一个SparkSession对象。使用SparkSession之后，可以通过<code>.sparkContext</code>属性来访问底层的SparkContext对象，以便进行一些底层操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rddSougouRecord = sparkContext.textFile(file)</span><br><span class="line">  .filter(line =&gt; line != <span class="literal">null</span> &amp;&amp; line.trim.split(<span class="string">&quot;\\s+&quot;</span>).length == <span class="number">6</span>)</span><br><span class="line">  .mapPartitions(it =&gt; &#123;</span><br><span class="line">    it.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">      <span class="type">SogouRecord</span>(</span><br><span class="line">        contents(<span class="number">0</span>),</span><br><span class="line">        contents(<span class="number">1</span>),</span><br><span class="line">        contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        contents(<span class="number">3</span>).toInt,</span><br><span class="line">        contents(<span class="number">4</span>).toInt,</span><br><span class="line">        contents(<span class="number">5</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这段代码是使用Spark的RDD（Resilient Distributed Dataset） API来读取一个文本文件，并根据特定的规则将每行数据转换为自定义的SogouRecord对象。</p><ol><li><p><code>val rddSougouRecord = sparkContext.textFile(file)</code>: 这行代码读取文本文件并创建了一个RDD（Resilient Distributed Dataset）。<code>file</code>是指定的文件路径。<code>textFile</code>方法将文件的每一行作为RDD的一个元素。</p></li><li><p><code>.filter(line =&gt; line != null &amp;&amp; line.trim.split(&quot;\\s+&quot;).length == 6)</code>: 在上一步创建的RDD上调用<code>filter</code>方法，过滤掉一些不符合条件的行。<code>filter</code>方法接受一个函数作为参数，这里使用了一个Lambda表达式。Lambda表达式中的条件<code>line != null &amp;&amp; line.trim.split(&quot;\\s+&quot;).length == 6</code>判断是否满足过滤条件：行不为null且按空格拆分后有6个元素。</p></li><li><p><code>.mapPartitions(it =&gt; &#123; ... &#125;)</code>: 这是一个转换操作，使用<code>mapPartitions</code>方法对每个分区（partition）中的数据进行转换。<code>mapPartitions</code>方法也接受一个函数作为参数，该函数的输入是每个分区的迭代器（iterator），输出是转换后的迭代器。</p></li><li><p><code>it.map(line =&gt; &#123; ... &#125;)</code>: 在<code>mapPartitions</code>方法的函数体内，对每个分区的数据（即每行文本）进行转换。使用<code>map</code>方法对每行文本应用一个函数，将文本按空格拆分，并根据自定义的规则构造<code>SogouRecord</code>对象。</p></li><li><p><code>val contents = line.trim.split(&quot;\\s+&quot;)</code>: 将当前行去除首尾空格后按空格进行拆分，将结果保存在<code>contents</code>数组中。</p></li><li><p><code>SogouRecord(...)</code>：根据拆分后的<code>contents</code>数组的内容构造<code>SogouRecord</code>对象。<code>SogouRecord</code>是一个自定义的类，它包含了6个字段，对应着每行文本中拆分后的6个元素。</p></li></ol><p>最后，整个代码的作用是从给定的文件中读取数据，根据特定的条件过滤掉无效的行，然后按照自定义的规则将每行文本转换为<code>SogouRecord</code>对象，并最终得到一个包含<code>SogouRecord</code>对象的RDD <code>rddSougouRecord</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rddSougouRecord.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>).count()</span><br></pre></td></tr></table></figure><p>这行代码对之前的RDD <code>rddSougouRecord</code> 进行了持久化（缓存）操作，并计算了RDD中元素的数量。</p><ol><li><p><code>rddSougouRecord.persist(StorageLevel.MEMORY_AND_DISK)</code>: 这部分代码对RDD <code>rddSougouRecord</code> 进行了持久化操作。在Spark中，RDD是一个不可变的分布式数据集，当对一个RDD执行一系列的转换操作时，每个转换都会生成一个新的RDD，而原始RDD则不会受到影响。持久化（缓存）操作的目的是将RDD的数据缓存在内存或磁盘中，这样可以避免在后续的操作中重复计算，提高计算效率。</p><p><code>persist</code>方法接受一个参数，即存储级别（StorageLevel）。在这里，使用了<code>StorageLevel.MEMORY_AND_DISK</code>存储级别，表示将数据缓存在内存中，如果内存空间不足，则溢写到磁盘。这样可以在内存充足时快速访问数据，并在内存不足时保留数据在磁盘上，以便后续使用。</p></li><li><p><code>.count()</code>: 这部分代码对持久化后的RDD执行了<code>count</code>操作，用于计算RDD中元素的数量。<code>count</code>是一个动作（action）操作，会触发实际的计算并返回RDD中元素的数量。</p></li></ol><p>综合起来，这行代码的作用是对RDD <code>rddSougouRecord</code> 进行持久化操作，将数据缓存在内存或磁盘中，然后计算RDD中元素的数量。持久化操作使得在后续对<code>rddSougouRecord</code>执行其他转换或动作操作时，可以从缓存中快速访问数据，而不必每次都重新计算。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queryWordsWordCountRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">  it.flatMap(record =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> terms: util.<span class="type">List</span>[<span class="type">Term</span>] = <span class="type">HanLP</span>.segment(record.queryWords.trim)</span><br><span class="line">    <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">    terms.asScala.map(_.word)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).map((_, <span class="number">1</span>)).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这段代码是对之前持久化的RDD <code>rddSougouRecord</code> 进行一系列转换操作，最终得到一个包含查询词（queryWords）及其出现频率的RDD <code>queryWordsWordCountRDD</code>。</p><ol><li><p><code>val queryWordsWordCountRDD = rddSougouRecord.mapPartitions(it =&gt; &#123; ... &#125;)</code>: 这行代码首先对持久化的RDD <code>rddSougouRecord</code> 进行了 <code>mapPartitions</code> 转换操作。<code>mapPartitions</code> 方法对 RDD 的每个分区进行操作，并返回一个新的 RDD，它的每个元素都是转换后的结果。这里使用了一个 Lambda 表达式来处理每个分区的数据。</p></li><li><p><code>it.flatMap(record =&gt; &#123; ... &#125;)</code>: 在 <code>mapPartitions</code> 中，对每个分区的元素进行 <code>flatMap</code> 转换操作。<code>flatMap</code> 方法类似于 <code>map</code> 方法，但是它可以将每个输入元素映射为零个或多个输出元素。在这里，<code>flatMap</code> 用于将每个 <code>SogouRecord</code> 对象的 <code>queryWords</code> 字段拆分为单个词语。</p></li><li><p><code>val terms: util.List[Term] = HanLP.segment(record.queryWords.trim)</code>: 这行代码使用了 HanLP 中文分词库对每个 <code>queryWords</code> 进行中文分词，并将结果保存在 <code>terms</code> 变量中。<code>HanLP.segment</code> 方法返回一个 <code>util.List[Term]</code> 对象，其中包含了分词后的词语。</p></li><li><p><code>import scala.collection.JavaConverters._</code>: 这行代码导入了 Scala 与 Java 集合之间的转换工具，用于将 Java 集合转换为 Scala 集合，方便后续的处理。</p></li><li><p><code>terms.asScala.map(_.word)</code>: 在前面的步骤中，将 <code>queryWords</code> 分词后得到的结果是一个 Java 集合，这里使用 <code>asScala</code> 方法将其转换为 Scala 集合，并使用 <code>map</code> 方法提取每个 <code>Term</code> 对象的 <code>word</code> 字段，即每个词语，形成一个包含所有词语的新的 Scala 集合。</p></li><li><p><code>.map((_, 1))</code>: 这一步是对每个词语添加一个计数值 1，将每个词语映射为一个二元组 <code>(词语, 1)</code>。</p></li><li><p><code>.reduceByKey(_ + _)</code>: 接着使用 <code>reduceByKey</code> 方法，将相同的词语进行分组并求和。即将相同词语的计数值相加，得到每个词语的出现频率。</p></li><li><p><code>.sortBy(_._2, ascending = false)</code>: 最后使用 <code>sortBy</code> 方法，按照词语出现频率（即二元组的第二个元素）进行降序排序，得到包含查询词及其出现频率的 RDD <code>queryWordsWordCountRDD</code>。</p></li></ol><p>综合起来，这段代码的作用是将每个 <code>SogouRecord</code> 对象的 <code>queryWords</code> 字段进行中文分词，统计查询词的出现频率，并按频率降序排列，得到一个包含查询词及其出现频率的 RDD <code>queryWordsWordCountRDD</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryWordsWordCountRDD.coalesce(numPartitions = <span class="number">1</span>).saveAsTextFile(outputPath1)</span><br></pre></td></tr></table></figure><p>这段代码是将之前得到的RDD <code>queryWordsWordCountRDD</code> 进行一系列操作，并将结果保存为文本文件。</p><ol><li><p><code>queryWordsWordCountRDD.coalesce(numPartitions = 1)</code>: 这部分代码使用了 <code>coalesce</code> 方法对RDD进行重新分区。<code>coalesce</code> 方法可以将RDD的分区数量减少到指定的数量。在这里，<code>numPartitions = 1</code> 表示将RDD合并为一个分区，也就是将所有数据合并到一个分区中。</p></li><li><p><code>.saveAsTextFile(outputPath1)</code>: 接着使用 <code>saveAsTextFile</code> 方法将RDD保存为文本文件。<code>saveAsTextFile</code> 方法将RDD中的每个元素（每行文本）写入到文本文件中。<code>outputPath1</code> 是保存文本文件的输出路径。</p></li></ol><p>综合起来，这段代码的作用是将之前计算得到的 <code>queryWordsWordCountRDD</code> 重新分区为一个分区，并将结果保存为文本文件。在文本文件中，每个查询词及其出现频率将以文本行的形式存储。注意，由于使用了 <code>coalesce(1)</code>，结果文件将只有一个分区，并且所有数据都会写入同一个文件中。如果数据量很大，可能会造成单个文件过大的问题。如果想要分多个文件保存，可以调整 <code>coalesce</code> 方法中的分区数为需要的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rddSougouRecord.unpersist()</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure><p>这段代码是对之前持久化的RDD <code>rddSougouRecord</code> 进行解除持久化，并停止SparkContext对象，从而终止Spark应用程序的执行。</p><ol><li><p><code>rddSougouRecord.unpersist()</code>: 这行代码调用了 <code>unpersist</code> 方法，用于解除RDD的持久化。在之前的代码中，我们对 <code>rddSougouRecord</code> 进行了持久化（缓存）操作，将数据缓存到内存或磁盘中，以便后续的操作可以快速访问数据。而 <code>unpersist</code> 方法的作用就是解除持久化，即释放RDD的缓存，从而释放内存或磁盘空间。在某些情况下，当RDD不再被频繁使用时，可以手动调用 <code>unpersist</code> 方法来释放资源，以避免占用过多的存储空间。</p></li><li><p><code>sparkContext.stop()</code>: 这行代码调用了 <code>stop</code> 方法，用于停止SparkContext对象，从而终止Spark应用程序的执行。<code>SparkContext</code> 是Spark应用程序与Spark集群之间的主要接口，调用 <code>stop</code> 方法将会关闭与集群的连接，并释放资源。在应用程序执行完成后，通常会调用 <code>stop</code> 方法来优雅地终止Spark应用程序，释放集群资源，避免资源浪费。</p></li></ol><p>综合起来，这段代码的作用是解除之前对RDD的持久化，释放缓存的资源，并停止SparkContext对象，从而正常终止Spark应用程序的执行。</p><h2 id="使用Spark-SQL案例解析"><a href="#使用Spark-SQL案例解析" class="headerlink" title="使用Spark SQL案例解析"></a>使用Spark SQL案例解析</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">Row</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">IntegerType</span>, <span class="type">StringType</span>, <span class="type">StructField</span>, <span class="type">StructType</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SogouAnalysisSQL</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 设置输出的日志级别</span></span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder()</span><br><span class="line">      .appName(<span class="string">&quot;SogouAnalysisSQL&quot;</span>)</span><br><span class="line">      .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/reduced.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = spark.sparkContext.textFile(file)</span><br><span class="line">      .filter(line =&gt; line != <span class="literal">null</span> &amp;&amp; line.trim.split(<span class="string">&quot;\\s+&quot;</span>).length == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> schema = <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;queryTime&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;userId&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;queryWords&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;resultRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;clickRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;clickUrl&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rddRow = fileRDD.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 封装的字段的时候，顺序要与定义的schema顺序完全一致</span></span><br><span class="line">          <span class="type">Row</span>(</span><br><span class="line">            contents(<span class="number">0</span>),</span><br><span class="line">            contents(<span class="number">1</span>),</span><br><span class="line">            contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">            contents(<span class="number">3</span>).toInt,</span><br><span class="line">            contents(<span class="number">4</span>).toInt,</span><br><span class="line">            contents(<span class="number">5</span>)</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; <span class="type">Row</span>(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> df = spark.createDataFrame(rddRow, schema)</span><br><span class="line"></span><br><span class="line">    df.createOrReplaceTempView(<span class="string">&quot;sogou_view&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sql =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select * from sogou_view where clickUrl like &#x27;www%&#x27;</span></span><br><span class="line"><span class="string">        |limit 3</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sqlResult = spark.sql(sql)</span><br><span class="line">    <span class="comment">//    sqlResult.show(truncate = false)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> querySQL =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select userId,queryWords,count(*) as query_count from sogou_view</span></span><br><span class="line"><span class="string">        |group by userId,queryWords</span></span><br><span class="line"><span class="string">        |order by userid,query_count desc</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryResult = spark.sql(querySQL)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    queryResult.show(truncate = false)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeSQL =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select substring(queryTime,0,5) as query_time,count(*) as query_count from sogou_view</span></span><br><span class="line"><span class="string">        |group by substring(queryTime,0,5)</span></span><br><span class="line"><span class="string">        |order by query_time,query_count desc</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeResult = spark.sql(timeSQL)</span><br><span class="line">    timeResult.show(truncate = <span class="literal">false</span>)</span><br><span class="line">    timeResult.rdd.coalesce(<span class="number">1</span>).saveAsTextFile(<span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/timeResult&quot;</span>)</span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> schema = <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;queryTime&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;userId&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;queryWords&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;resultRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;clickRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">  <span class="type">StructField</span>(<span class="string">&quot;clickUrl&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>这段代码定义了一个Spark SQL的Schema，用于描述数据的结构和字段类型。Spark SQL是Spark的模块，它提供了用于处理结构化数据的高级数据处理接口。</p><ol><li><p><code>val schema = StructType(Array(...))</code>: 这行代码创建了一个<code>StructType</code>对象，该对象表示了数据的结构。<code>StructType</code>是Spark SQL中用于表示数据结构的类，它包含一个包含了多个<code>StructField</code>的数组。</p></li><li><p><code>StructField(&quot;queryTime&quot;, StringType, false)</code>: 这行代码创建了一个<code>StructField</code>对象，表示数据的一个字段。<code>StructField</code>接受三个参数：字段名称（”queryTime”）、字段类型（StringType）和是否可空（false）。</p></li><li><p><code>StructField(&quot;userId&quot;, StringType, false)</code>: 同上，创建了一个表示”userId”字段的<code>StructField</code>对象。</p></li><li><p><code>StructField(&quot;queryWords&quot;, StringType, false)</code>: 同上，创建了一个表示”queryWords”字段的<code>StructField</code>对象。</p></li><li><p><code>StructField(&quot;resultRank&quot;, IntegerType, false)</code>: 同上，创建了一个表示”resultRank”字段的<code>StructField</code>对象。这里字段类型是<code>IntegerType</code>，表示整数类型。</p></li><li><p><code>StructField(&quot;clickRank&quot;, IntegerType, false)</code>: 同上，创建了一个表示”clickRank”字段的<code>StructField</code>对象。</p></li><li><p><code>StructField(&quot;clickUrl&quot;, StringType, false)</code>: 同上，创建了一个表示”clickUrl”字段的<code>StructField</code>对象。</p></li></ol><p>综合起来，这段代码定义了一个包含六个字段的Schema，每个字段都有一个名称、一个字段类型和一个是否可空的标志。这个Schema描述了一个数据集，其中包含了查询时间（queryTime）、用户ID（userId）、查询词（queryWords）、结果排名（resultRank）、点击排名（clickRank）和点击URL（clickUrl）等六个字段。通过定义Schema，我们可以将RDD转换为DataFrame，从而利用Spark SQL的高级功能进行数据处理和查询。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rddRow = fileRDD.mapPartitions(it =&gt; &#123;</span><br><span class="line">  it.map(line =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 封装的字段的时候，顺序要与定义的schema顺序完全一致</span></span><br><span class="line">      <span class="type">Row</span>(</span><br><span class="line">        contents(<span class="number">0</span>),</span><br><span class="line">        contents(<span class="number">1</span>),</span><br><span class="line">        contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        contents(<span class="number">3</span>).toInt,</span><br><span class="line">        contents(<span class="number">4</span>).toInt,</span><br><span class="line">        contents(<span class="number">5</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; <span class="type">Row</span>(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码对之前的RDD <code>fileRDD</code> 进行了一系列转换操作，将每行文本数据转换为Spark SQL的<code>Row</code>对象，并得到一个新的RDD <code>rddRow</code>。</p><ol><li><p><code>val rddRow = fileRDD.mapPartitions(it =&gt; &#123; ... &#125;)</code>: 这行代码首先对RDD <code>fileRDD</code> 进行了 <code>mapPartitions</code> 转换操作。<code>mapPartitions</code> 方法对RDD的每个分区进行操作，并返回一个新的RDD，它的每个元素都是转换后的结果。这里使用了一个 Lambda 表达式来处理每个分区的数据。</p></li><li><p><code>it.map(line =&gt; &#123; ... &#125;)</code>: 在 <code>mapPartitions</code> 中，对每个分区的元素（即每行文本）进行转换操作。</p></li><li><p><code>val contents = line.trim.split(&quot;\\s+&quot;)</code>: 将当前行去除首尾空格后按空格进行拆分，将结果保存在 <code>contents</code> 数组中。</p></li><li><p><code>try &#123; ... &#125; catch &#123; ... &#125;</code>: 这是一个异常处理结构，用于捕获可能的异常。在这里，代码尝试根据之前定义的Schema封装每行数据为<code>Row</code>对象。如果成功封装，则返回封装好的<code>Row</code>对象；如果出现异常（例如数组越界或类型转换失败），则将异常捕获，并返回一个包含错误信息的<code>Row</code>对象。</p></li><li><p><code>Row(...)</code>: 在 <code>try</code> 块中，根据之前定义的Schema构造<code>Row</code>对象。<code>Row</code>对象是Spark SQL中的一种数据结构，它用于表示一行数据，其中的参数按照之前定义的Schema的顺序对应各个字段。</p></li><li><p><code>contents(2).replaceAll(&quot;[\\[|\\]]&quot;, &quot;&quot;)</code>: 这行代码对第三个字段（contents(2)）进行处理，去除其中的方括号 “[ ]”。</p></li><li><p><code>contents(3).toInt, contents(4).toInt</code>: 这行代码将第四个字段（contents(3)）和第五个字段（contents(4)）转换为整数类型。</p></li><li><p><code>case e: Exception =&gt; Row(&quot;error&quot;, &quot;error&quot;, &quot;error&quot;, 0, 0, &quot;error&quot;)</code>: 在 <code>catch</code> 块中，捕获异常，并返回一个包含错误信息的<code>Row</code>对象。如果出现异常，则用”error”字符串代替无法解析的字段，并将数值类型字段设为0。</p></li></ol><p>综合起来，这段代码的作用是将每行文本数据转换为Spark SQL的<code>Row</code>对象，并根据之前定义的Schema对字段进行类型转换和处理。如果能成功转换，则得到一个包含正确数据的<code>Row</code>对象；如果出现异常，则返回一个包含错误信息的<code>Row</code>对象。最终得到的RDD <code>rddRow</code> 包含了经过处理的<code>Row</code>对象，可以用于构建DataFrame并使用Spark SQL的高级功能进行数据处理和查询。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> df = spark.createDataFrame(rddRow, schema)</span><br></pre></td></tr></table></figure><p>这段代码使用之前得到的RDD <code>rddRow</code> 和之前定义的Schema <code>schema</code> 来创建一个DataFrame。DataFrame是Spark SQL中的一个分布式数据表，它可以使用结构化的数据和Schema进行处理和查询。</p><ol><li><p><code>val df = spark.createDataFrame(rddRow, schema)</code>: 这行代码调用了SparkSession对象的 <code>createDataFrame</code> 方法，用于创建一个DataFrame。<code>createDataFrame</code> 方法接受两个参数：第一个参数是之前创建的RDD <code>rddRow</code>，第二个参数是之前定义的Schema <code>schema</code>。</p></li><li><p><code>rddRow</code>: 这是之前转换得到的RDD，其中的每个元素都是一个Spark SQL的<code>Row</code>对象。该RDD包含了处理后的数据，每个<code>Row</code>对象按照之前定义的Schema的顺序对应各个字段。</p></li><li><p><code>schema</code>: 这是之前定义的Schema，它描述了DataFrame中每个字段的名称和类型。</p></li></ol><p>综合起来，这段代码的作用是利用之前处理得到的<code>rddRow</code> 和定义好的 <code>schema</code>，创建一个DataFrame <code>df</code>。DataFrame是一个结构化的、可分布式处理的数据表，现在我们可以使用<code>df</code> 来使用Spark SQL的高级功能进行数据处理和查询。DataFrame提供了更方便的数据处理接口，可以使用SQL语句或DataFrame API来进行数据分析、过滤、聚合、连接等操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.createOrReplaceTempView(<span class="string">&quot;sogou_view&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码在Spark SQL中将DataFrame <code>df</code> 注册为一个临时视图（Temporary View），使其可以在当前SparkSession中被查询。临时视图是一种临时的数据表，仅在当前SparkSession的生命周期内有效，通常用于执行SQL查询。</p><ol><li><p><code>df.createOrReplaceTempView(&quot;sogou_view&quot;)</code>: 这行代码调用了DataFrame <code>df</code> 的 <code>createOrReplaceTempView</code> 方法，用于创建或替换一个临时视图。<code>createOrReplaceTempView</code> 方法接受一个字符串参数，表示视图的名称。在这里，视图名称被设置为”sogou_view”。</p></li><li><p>“sogou_view”: 这是临时视图的名称。通过此名称，可以在当前SparkSession中使用SQL语句查询DataFrame <code>df</code> 的数据。</p></li></ol><p>综合起来，这段代码的作用是在当前SparkSession中将DataFrame <code>df</code> 注册为一个临时视图，使得我们可以在后续的操作中使用SQL语句查询临时视图的数据。通过创建临时视图，我们可以使用更熟悉的SQL语法来进行数据查询和分析。视图只在当前SparkSession的生命周期内有效，不会被持久化到存储系统中。如果需要在不同的SparkSession中访问相同的视图，可以使用<code>createGlobalTempView</code>方法，创建一个全局临时视图。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> timeSQL =</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    |select substring(queryTime,0,5) as query_time,count(*) as query_count from sogou_view</span></span><br><span class="line"><span class="string">    |group by substring(queryTime,0,5)</span></span><br><span class="line"><span class="string">    |order by query_time,query_count desc</span></span><br><span class="line"><span class="string">    |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timeResult = spark.sql(timeSQL)</span><br><span class="line">timeResult.show(truncate = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这段代码使用Spark SQL查询之前创建的临时视图 <code>sogou_view</code>，并统计查询时间（<code>queryTime</code>字段）的每年月份（截取前5个字符）的查询次数。然后按照查询时间（年月份）进行分组，并按查询次数降序排序，最后将查询结果打印输出。</p><ol><li><p><code>val timeSQL = &quot;&quot;&quot; ... &quot;&quot;&quot;</code>: 这是一个包含SQL查询语句的多行字符串。在Scala中，可以使用三个双引号 <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code> 来定义多行字符串，其中的换行符和缩进都会被保留。这个SQL查询语句用于统计查询时间（<code>queryTime</code>字段）的每年月份的查询次数，并按照年月份进行分组和排序。</p></li><li><p><code>select substring(queryTime,0,5) as query_time, count(*) as query_count from sogou_view group by substring(queryTime,0,5) order by query_time, query_count desc</code>: 这是SQL查询语句的主体部分。在这里，使用<code>substring</code>函数截取<code>queryTime</code>字段的前5个字符（即年月份），并将其命名为<code>query_time</code>。然后使用<code>count(*)</code>函数对查询结果进行计数，得到每个年月份的查询次数。接着使用<code>group by</code>子句对结果按照年月份进行分组，最后使用<code>order by</code>子句按照年月份和查询次数降序排序。</p></li><li><p><code>val timeResult = spark.sql(timeSQL)</code>: 这行代码使用<code>spark.sql</code>方法执行之前定义的SQL查询语句，并将结果保存在<code>timeResult</code>中。<code>spark.sql</code>方法接受一个SQL查询字符串作为参数，并返回一个DataFrame，其中包含了查询结果的数据。</p></li><li><p><code>timeResult.show(truncate = false)</code>: 最后，使用<code>show</code>方法打印输出查询结果。<code>show</code>方法用于显示DataFrame的内容，默认显示前20行，并且截断字段内容以便于显示。通过设置<code>truncate = false</code>，可以禁用字段内容的截断，以便完整显示字段的内容。</p></li></ol><p>综合起来，这段代码的作用是执行SQL查询，统计每个查询时间（年月份）的查询次数，并按照年月份进行分组和降序排序，然后将查询结果打印输出。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.13-7.16技术培训实记</title>
      <link href="/2023/07/12/7-13-7-16%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD%E5%AE%9E%E8%AE%B0/"/>
      <url>/2023/07/12/7-13-7-16%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD%E5%AE%9E%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="培训报告"><a href="#培训报告" class="headerlink" title="培训报告"></a>培训报告</h1><p><strong>[学院组织]</strong></p><p><strong>[7.13-7.16]</strong></p><h2 id="培训目的"><a href="#培训目的" class="headerlink" title="培训目的"></a>培训目的</h2><p>本次技术培训的目的是提升参与人员在特定技术领域的知识和技能，以应对公司在该领域面临的挑战和需求。通过培训，参与人员将能够掌握相关技术，并将其应用于日常工作中，从而提高工作效率和质量。</p><h2 id="07-13-基础环境搭建"><a href="#07-13-基础环境搭建" class="headerlink" title="07-13 基础环境搭建"></a>07-13 基础环境搭建</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><p><strong>搭建步骤</strong></p><ol><li><p>修改主机名，便于识别节点；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 修改主机名</span></span><br><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新</span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure></li><li><p>修改hosts文件，添加集群节点映射，按照给出的节点IP和对应的主机名进行设置；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改hosts文件内容</span></span><br><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 【局域网ip】 【主机名】</span><br><span class="line">[ip] [hostname]</span><br></pre></td></tr></table></figure></li><li><p>要求各节点时区修改为中国时区（ 中国标准时间CST+8）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为中国时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></li><li><p>安装ntp服务，要求主节点master为本地时钟源，从节点设置定时任务同步本地时间；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改master节点NTP配置</span></span><br><span class="line">vim /etc/ntp.conf</span><br></pre></td></tr></table></figure><p>设置master为本地时间服务器，屏蔽默认server，服务器层级设为10</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># server &lt;默认服务器&gt;</span><br><span class="line">server 127.127.1.0</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure><p>启动ntp服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ntp</span><br><span class="line">systemctl restart ntpd.service</span><br></pre></td></tr></table></figure><p>添加定时任务–在早十-晚五时间段内每隔半个小时同步一次本地服务器时间（24小时制、使用用户root任务调度crontab，服务器地址使用主机名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/30 10-17 * * * /usr/sbin/ntpdate -u &lt;主机名&gt;</span><br></pre></td></tr></table></figure></li><li><p>集群中数据传输需要节点之间免密访问，要求设置主节点之间到从节点的免密访问；<br>主节点生成公钥文件id_rsa.pub(数字签名RSA，用户root，主机名master)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>建⽴master⾃身使⽤root⽤户ssh访问localhost免密登录<br>若没有authorized_keys则使用下面命令创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>建⽴master使⽤root⽤户到slave的ssh免密登录访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@&lt;从节点IP或主机名&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@&lt;从节点IP或主机名&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置Java环境<br>解压下载的java JDK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf [jdk]</span><br></pre></td></tr></table></figure><p>添加系统环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=&lt;you_java_jdk_path&gt;</span><br><span class="line">export PATH=&quot;$JAVA_HOME/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>分发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /etc/profile root@slave:/etc/</span><br><span class="line">scp -r /usr/java root@slave:/usr/</span><br></pre></td></tr></table></figure></li></ol><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p><strong>概念</strong></p><p>ZooKeeper是一个开源的分布式协调服务，它为分布式应用程序提供了高度可靠的协调功能。它旨在解决分布式系统中的一些常见问题，如配置管理、命名服务、分布式锁、分布式协调等。</p><p>ZooKeeper的设计目标是提供一个简单而高效的分布式协调服务，它采用了基于观察者模式的数据模型。在ZooKeeper中，数据被组织为一个分层的命名空间（类似于文件系统的目录结构），称为ZooKeeper树（ZooKeeper<br>tree）或ZooKeeper命名空间（ZooKeeper namespace）。每个节点在树中都有一个唯一的路径标识，并可以存储一个小的数据块。</p><p>ZooKeeper提供了临时节点、顺序节点、观察者机制等特性，可以用于实现分布式锁、选主（Leader<br>Election）、集群管理、分布式队列等场景。它的核心是一个高可用的、基于主从架构的协调服务器集群，通过选举机制确保了服务的高可用性和可靠性。</p><p>在分布式系统中，ZooKeeper被广泛应用于各种场景，如大数据、分布式数据库、消息队列、分布式应用程序等。它为分布式应用程序提供了一个可靠的、高性能的基础设施，帮助开发人员简化了分布式系统的设计和实现。</p><p>Zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。<br>预装的配置文件zoo_sample.cfg下面默认有五个属性，分别是：</p><ol><li><p>tickTime<br>心跳间隔，单位是毫秒，系统默认是2000毫秒，也就是间隔两秒心跳一次。<br>tickTime的意义：客户端与服务器或者服务器与服务器之间维持心跳，也就是每个tickTime时间就会发送一次心跳。通过心跳不仅能够用来监听机器的工作状态，还可以通过心跳来控制Flower跟Leader的通信时间，默认情况下FL的会话时常是心跳间隔的两倍。</p></li><li><p>initLimit<br>集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</p></li><li><p>syncLimit<br>集群中flower服务器（F）跟leader（L）服务器之间的请求和答应最多能容忍的心跳数。</p></li><li><p>clientPort<br>客户端连接的接口，客户端连接zookeeper服务器的端口，zookeeper会监听这个端口，接收客户端的请求访问，端口默认是2181。</p></li><li><p>dataDir<br>该属性对应的目录是用来存放myid信息跟一些版本，日志，跟服务器唯一的ID信息等。<br>在集群Zookeeper服务在启动的时候，会回去读取zoo.cfg这个文件，从这个文件中找到这个属性然后获取它的值也就是dataDir<br>的路径，它会从这个路径下面读取myid这个文件，从这个文件中获取要启动的当前服务器的地址。</p></li></ol><p>集群信息的配置：<br>在配置文件中，配置集群信息是存在一定的格式：service.N &#x3D;YYY： A：B<br>N：代表服务器编号（准确对应对应服务器中myid里面的值）<br>YYY：服务器地址<br>A：表示 Flower 跟 Leader的通信端口，简称服务端内部通信的端口（默认2888）<br>B：表示是选举端口（默认是3888）</p><p>参考配置文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">clientPort=2181</span><br><span class="line"># 配置数据存储路径</span><br><span class="line">????</span><br><span class="line"># 配置日志文件路径</span><br><span class="line">????</span><br><span class="line"># 配置集群列表</span><br><span class="line">server.1=????</span><br><span class="line">server.2=????</span><br><span class="line">server.3=????</span><br></pre></td></tr></table></figure><p><strong>搭建步骤</strong></p><ol><li><p>将zookeeper安装包解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf [zookeeper]</span><br></pre></td></tr></table></figure></li><li><p>配置系统变量ZOOKEEPER_HOME，同时将Zookeeper安装路径中bin目录加入PATH系统变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># zookeeper</span><br><span class="line">export ZOOKEEPER_HOME=/usr/zookeeper/zookeeper-3.4.14</span><br><span class="line">export PATH=&quot;$ZOOKEEPER_HOME/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>Zookeeper的默认配置文件为Zookeeper安装路径下conf&#x2F;zoo_sample.cfg，将其修改为zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper/zookeeper-3.4.14/conf/</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li><li><p>设置数据存储路径(dataDir)为&#x2F;usr&#x2F;zookeeper&#x2F;zookeeper-3.4.14&#x2F;zkdata</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/usr/zookeeper/zookeeper-3.4.14/zkdata</span><br></pre></td></tr></table></figure></li><li><p>设置日志文件路径(dataLogDir)为&#x2F;usr&#x2F;zookeeper&#x2F;zookeeper-3.4.14&#x2F;zkdatalog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataLogDir=/usr/zookeeper/zookeeper-3.4.14/zkdatalog</span><br></pre></td></tr></table></figure></li><li><p>设置集群列表（要求master为1号服务器，slave1为2号服务器，slave2为3号服务器）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=master:2888:3888</span><br><span class="line">server.2=slave1:2888:3888</span><br><span class="line">server.3=slave2:2888:3888</span><br></pre></td></tr></table></figure></li><li><p>创建所需数据存储文件夹、日志存储文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/zookeeper/zookeeper-3.4.14/&#123;zkdata,zkdatalog&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据存储路径下创建myid，写入对应的标识主机服务器序号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/zookeeper/zookeeper-3.4.14/zkdata</span><br><span class="line">vim myid</span><br></pre></td></tr></table></figure><p>server.1 中的 1 就是主机服务器的序号</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>分发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/zookeeper/ root@slave:/usr</span><br><span class="line">scp /etc/profile root@slave:/etc</span><br></pre></td></tr></table></figure></li><li><p>启动服务，查看进程QuorumPeerMain是否存在</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>查看各节点服务器角色是否正常(leader&#x2F;follower)</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure></li></ol><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p><strong>概述</strong></p><p>Hadoop是一个开源的分布式计算框架，旨在处理大规模数据集的存储和处理。它提供了可靠性、可扩展性和容错性，适用于在集群中并行处理大量数据的场景。</p><p>Hadoop的核心组件包括：</p><ol><li><p>Hadoop Distributed File System (HDFS)：这是一个分布式文件系统，用于存储大规模数据集。它将数据分散存储在集群中的多个节点上，并提供高容错性和高可靠性，以支持大规模数据的存储和处理。</p></li><li><p>MapReduce：这是一个分布式数据处理模型，用于在Hadoop集群上并行处理大规模数据。MapReduce将计算任务分解为可并行执行的“映射”（Map）和“归约”（Reduce）阶段，允许在分布式环境中处理海量数据。</p></li></ol><p>除了核心组件之外，Hadoop生态系统还包括许多其他工具和组件，如：</p><ul><li>YARN (Yet Another Resource Negotiator)：作为Hadoop的资源管理器，负责集群资源的管理和任务调度。</li><li>Hive：一个基于Hadoop的数据仓库和查询工具，提供类似于SQL的查询语言，用于分析和处理存储在Hadoop上的数据。</li><li>Spark：一个快速、通用的大数据处理引擎，提供高级别的API，支持内存计算和更复杂的数据处理模式。</li><li>HBase：一个分布式、可扩展的列式数据库，用于存储和访问结构化数据。</li><li>Pig：一种高级数据流脚本语言，用于编写复杂的数据转换和分析任务。</li><li>ZooKeeper：一个分布式协调服务，用于管理和协调分布式系统中的各种任务。</li></ul><p>Hadoop被广泛应用于大数据领域，它可以处理海量数据并提供可靠的数据存储和分析能力。它的设计理念和架构使得它适用于构建可扩展的分布式系统，以满足日益增长的大数据需求。</p><p>Hadoop是由Java语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架，其核心部件是HDFS与MapReduce。</p><ol><li>HDFS是一个分布式文件系统：引入存放文件元数据信息的服务器Namenode和实际存放数据的服务器Datanode，对数据进行分布式储存和读取。</li><li>MapReduce是一个计算框架：MapReduce的核心思想是把计算任务分配给集群内的服务器里执行。通过对计算任务的拆分（Map计算&#x2F;Reduce计算）再根据任务调度器（JobTracker）对任务进行分布式计算。</li></ol><table><thead><tr><th>配置文件</th><th>配置对象</th><th>主要内容</th></tr></thead><tbody><tr><td>hadoop-env.sh</td><td>hadoop运行环境</td><td>用来定义Hadoop运行环境相关的配置信息；</td></tr><tr><td>core-site.xml</td><td>集群全局参数</td><td>定义系统级别的参数，包括HDFS URL、Hadoop临时目录等；</td></tr><tr><td>hdfs-site.xml</td><td>HDFS参数</td><td>定义名称节点、数据节点的存放位置、文本副本的个数、文件读取权限等；</td></tr><tr><td>mapred-site.xml</td><td>MapReduce参数</td><td>包括JobHistory Server 和应用程序参数两部分，如reduce任务的默认个数、任务所能够使用内存的默认上下限等；</td></tr><tr><td>yarn-site.xml</td><td>集群资源管理系统参数</td><td>配置ResourceManager ，nodeManager的通信端口，web监控端口等；</td></tr></tbody></table><p>Hadoop的配置类是由资源指定的，资源可以由一个String或Path来指定,资源以XML形式的数据表示，由一系列的键值对组成。资源可以用String或path命名（示例如下），</p><ol><li>String:指示hadoop在classpath中查找该资源；</li><li>Path:指示hadoop在本地文件系统中查找该资源。</li></ol><p><strong>配置示例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>????<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>core-site.xml</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td>fs.default.name</td><td>用于指定NameNode的地址</td></tr><tr><td>hadoop.tmp.dir</td><td>Hadoop运行时产生文件的临时存储目录</td></tr></tbody></table></li><li><p>hdfs-site.xml</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td>dfs.replication</td><td>指定备份数</td></tr><tr><td>dfs.namenode.name.dir</td><td>NameNode在本地文件系统中持久存储命名空间和事务日志的路径</td></tr><tr><td>dfs.datanode.data.dir</td><td>DataNode在本地文件系统中存放块的路径</td></tr><tr><td>dfs.permissions</td><td>集群权限系统校验</td></tr><tr><td>dfs.datanode.use.datanode.hostname</td><td>datanode之间通过域名方式通信</td></tr></tbody></table><blockquote><p>注意：外域机器通信需要用外网IP，未配置hostname访问会访问异常。可以在Java api客户端使用conf.set(“<br>fs.client.use.datanode.hostname”,”true”);。</p></blockquote></li><li><p>mapreduce-site.xml</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td>mapreduce.framework.name</td><td>指定执行MapReduce作业的运行时框架。属性值可以是local，classic或yarn</td></tr></tbody></table></li><li><p>yarn-site.xml</p><table><thead><tr><th>配置参数</th><th>说明</th></tr></thead><tbody><tr><td>yarn.resourcemanager.admin.address</td><td>用于指定RM管理界面的地址（主机:端口）</td></tr><tr><td>yarn.nodemanager.aux-services</td><td>mapreduce 获取数据的方式，指定在进行mapreduce作业时，yarn使用mapreduce_shuffle混洗技术。这个混洗技术是hadoop的一个核心技术，非常重要。</td></tr><tr><td>yarn.nodemanager.auxservices.mapreduce.shuffle.class</td><td>用于指定混洗技术对应的字节码文件，值为org.apache.hadoop.mapred.ShuffleHandler</td></tr></tbody></table></li></ol><p><strong>配置步骤</strong></p><ol><li><p>Hadoop安装包解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf [hadoop]</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量HADOOP_HOME，将Hadoop安装路径中bin目录和sbin目录加入PATH系统变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># hadoop</span><br><span class="line">export HADOOP_HOME=/usr/hadoop/hadoop-2.7.7</span><br><span class="line">export PATH=&quot;$HADOOP_HOME/sbin:$HADOOP_HOME/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置Hadoop运行环境JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/hadoop/hadoop-2.7.7/etc/hadoop</span><br><span class="line">vim hadoop-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_221</span><br></pre></td></tr></table></figure></li><li><p>设置全局参数，指定HDFS上NameNode地址为master,端口默认为9000；指定临时存储目录为本地&#x2F;root&#x2F;hadoopData&#x2F;tmp(要求为绝对路径，下同)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置HDFS参数，指定备份文本数量为2；设置HDFS参数，指定NN存放元数据信息路径为本地&#x2F;root&#x2F;hadoopData&#x2F;name；指定DN存放元数据信息路径为本地&#x2F;root&#x2F;hadoopData&#x2F;data(要求为绝对路径)；设置HDFS参数，关闭hadoop集群权限校验（安全配置），允许其他用户连接集群；指定datanode之间通过域名方式进行通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/hadoopData/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.use.datanode.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置YARN运行环境$JAVA_HOME参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim yarn-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_221</span><br></pre></td></tr></table></figure></li><li><p>设置YARN核心参数，指定ResourceManager进程所在主机为master，端口为18141;指定mapreduce 获取数据的方式为mapreduce_shuffle</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim yarn-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:18141<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.auxservices.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.shuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置计算框架参数，指定MR运行在yarn上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br><span class="line">vim mapred-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置节点文件，要求master为主节点； slave1、slave2为子节点<br>这里填入从节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim slaves</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave</span><br></pre></td></tr></table></figure><p>这里填入主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim master</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master</span><br></pre></td></tr></table></figure></li><li><p>分发</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/hadoop/ root@slave:/usr/</span><br><span class="line">scp /etc/profile root@slave:/etc/</span><br></pre></td></tr></table></figure></li><li><p>对文件系统进行格式化</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure><p>   出现一下内容就是成功了</p>   <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO common.Storage: Storage directory /root/hadoopData/name has been successfully formatted.</span><br></pre></td></tr></table></figure></li><li><p>启动Hadoop集群查看各节点服务</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh </span><br><span class="line">hadoop-daemon.sh start datanode</span><br><span class="line">jps</span><br></pre></td></tr></table></figure></li><li><p>查看集群运行状态是否正常</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop dfsadmin -report</span><br></pre></td></tr></table></figure></li></ol><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p><strong>概念</strong></p><p>Hive是基于Hadoop的数据仓库基础架构，它提供了一种类似于SQL的查询语言（HiveQL）和用于处理大规模数据集的数据处理能力。Hive使得用户可以使用SQL语言进行数据查询、转换和分析，而无需编写复杂的MapReduce程序。</p><p>Hive的核心思想是将结构化查询语言（SQL）映射到Hadoop分布式文件系统（HDFS）上的大规模数据集。它将SQL查询转换为一系列MapReduce作业，从而能够在Hadoop集群上并行处理数据。</p><p>Hive的特性包括：</p><ol><li><p>数据模型：Hive提供了类似于关系型数据库的表结构，支持基于模式的数据存储和查询。它可以将数据映射到表和分区，并支持复杂的数据类型和数据模型。</p></li><li><p>查询语言：Hive的查询语言HiveQL类似于SQL，允许用户使用SQL语句来查询和分析数据。HiveQL支持常见的查询操作，如SELECT、JOIN、GROUP<br>BY、ORDER BY等。</p></li><li><p>数据转换和ETL：Hive支持数据转换和ETL（抽取、转换、加载）操作，可以通过HiveQL进行数据清洗、转换和提取。</p></li><li><p>扩展性和集成：Hive可以与其他Hadoop生态系统组件集成，如HDFS、HBase、Spark等。它还支持自定义函数（UDF）和扩展插件，允许用户编写自定义逻辑和扩展功能。</p></li><li><p>元数据管理：Hive维护表和分区的元数据信息，包括表的结构、存储位置、分区信息等。这使得Hive能够提供更高级别的查询优化和查询计划生成。</p></li></ol><p>Hive广泛应用于大数据领域，特别是数据仓库、数据分析和数据处理场景。它提供了一种简化的方式来使用SQL语言进行大数据查询和处理，使得更多的人可以轻松地利用Hadoop集群进行数据分析和数据挖掘。</p><ol><li><p>环境中已经安装mysql-community-server，注意mysql5.7默认安装后为root用户随机生成一个密码；<br>直接查看密码：grep “temporary password” &#x2F;var&#x2F;log&#x2F;mysqld.log<br>登入数据库：mysql -uroot -p<br>输入随机密码即可登录</p></li><li><p>根据要求设置密码，注意对应的安全策略修改；<br>设置密码强度为低级：set global validate_password_policy&#x3D;????;<br>设置密码长度：set global validate_password_length&#x3D;????;<br>修改本地密码：alter user ‘root‘@’localhost’ identified by ‘????’;</p></li><li><p>根据要求满足任意主机节点root的远程访问权限(否则后续hive无法连接mysql)；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;????&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;????&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>注意刷新权限；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>参考命令</p><ol><li>启动mysql服务：systemctl start mysqld.service</li><li>关闭mysql服务：systemctl stop mysqld.service</li><li>查看mysql服务：systemctl status mysqld.service</li></ol></li></ol><p><strong>配置步骤</strong></p><ol><li><p>环境中已经安装mysql-community-server，关闭mysql开机自启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable mysqld</span><br></pre></td></tr></table></figure></li><li><p>开启MySQL服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></li><li><p>判断mysqld.log日志下是否生成初临时密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;temporary password&quot; /var/log/mysqld.log </span><br></pre></td></tr></table></figure><p>观察初始密码并复制下来</p></li><li><p>设置mysql数据库本地root用户密码为123456<br>登录mysql，使用临时密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>sql中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> root<span class="variable">@localhost</span> identified <span class="keyword">by</span> ‘<span class="number">123456</span>’;</span><br></pre></td></tr></table></figure><p>退出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure></li><li><p>Hive安装包解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf [hive]</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量HIVE_HOME,将Hive安装路径中的bin目录加入PATH系统变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HIVE_HOME=/usr/hive/apache-hive-2.3.4-bin</span><br><span class="line">export PATH=PATH : PATH:PATH:HIVE_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>修改HIVE运行环境，配置Hadoop安装路径HADOOP_HOME；修改HIVE运行环境，配置Hive配置文件存放路径HIVE_CONF_DIR；修改HIVE运行环境，配置Hive运行资源库路径HIVE_AUX_JARS_PATH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/hive/apache-hive-2.3.4-bin/conf/</span><br><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">vim hive-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/hadoop/hadoop-2.7.7</span><br><span class="line">export HIVE_CONF_DIR=/usr/hive/apache-hive-2.3.4-bin/conf</span><br><span class="line">export HIVE_AUX_JARS_PATH=/usr/hive/apache-hive-2.3.4-bin/lib</span><br></pre></td></tr></table></figure></li><li><p>解决jline的版本冲突，将$HIVE_HOME&#x2F;lib&#x2F;jline-2.12.jar同步至$HADOOP_HOME&#x2F;share&#x2F;hadoop&#x2F;yarn&#x2F;lib&#x2F;下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/package277/mysql-connector-java-5.1.47-bin.jar /usr/hive/apache-hive-2.3.4-bin/lib/</span><br></pre></td></tr></table></figure></li><li><p>分发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/hive root@slave:/usr</span><br><span class="line">scp /etc/profile root@slave:/etc</span><br></pre></td></tr></table></figure><div class="note info"><p>接下来的操作请选择刚才进行分发的slave从节点进行操作</p></div></li><li><p>驱动JDBC拷贝至hive安装目录对应lib下（依赖包存放于&#x2F;usr&#x2F;package277&#x2F;）</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/package277/mysql-connector-java-5.1.47-bin.jar /usr/hive/apache-hive-2.3.4-bin/lib/</span><br></pre></td></tr></table></figure></li><li><p>配置元数据数据存储位置为&#x2F;user&#x2F;hive_remote&#x2F;warehouse；配置连接JDBC的URL地址主机名及默认端口号3306，数据库为hive，如不存在自行创建，ssl连接方式为false；配置数据库连接用户；配置数据库连接密码</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/hive/apache-hive-2.3.4-bin/conf/hive-site.xml</span><br></pre></td></tr></table></figure>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Hive产生的元数据存放位置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive_remote/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据库连接driver，即MySQL驱动--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据库连接JDBC的URL地址--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://slave2:3306/hive?createDatabaseIfNotExist=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- MySQL数据库用户名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- MySQL数据库密码--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>   <div class="note info"><p>接下来的操作请选择master节点进行操作</p></div></li><li><p>配置元数据存储位置为&#x2F;user&#x2F;hive_remote&#x2F;warehouse；关闭本地metastore模式；配置指向metastore服务的主机为slave1，端口为9083</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/hive/apache-hive-2.3.4-bin/conf/hive-site.xml</span><br></pre></td></tr></table></figure>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Hive产生的元数据存放位置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive_remote/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--- 使用本地服务连接Hive,默认为true--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.local<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 连接服务器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://slave1:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务器端初始化数据库，并启动metastore服务;</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br><span class="line">hive --service metastore</span><br></pre></td></tr></table></figure></li><li><p>客户端开启进入hive，创建hive数据库</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database hive;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>Hive是基于Hadoop的数据仓库基础架构，它提供了一种类似于SQL的查询语言（HiveQL）和用于处理大规模数据集的数据处理能力。Hive使得用户可以使用SQL语言进行数据查询、转换和分析，而无需编写复杂的MapReduce程序。</p><p>Hive的核心思想是将结构化查询语言（SQL）映射到Hadoop分布式文件系统（HDFS）上的大规模数据集。它将SQL查询转换为一系列MapReduce作业，从而能够在Hadoop集群上并行处理数据。</p><p>Hive的特性包括：</p><ol><li><p>数据模型：Hive提供了类似于关系型数据库的表结构，支持基于模式的数据存储和查询。它可以将数据映射到表和分区，并支持复杂的数据类型和数据模型。</p></li><li><p>查询语言：Hive的查询语言HiveQL类似于SQL，允许用户使用SQL语句来查询和分析数据。HiveQL支持常见的查询操作，如SELECT、JOIN、GROUP<br>BY、ORDER BY等。</p></li><li><p>数据转换和ETL：Hive支持数据转换和ETL（抽取、转换、加载）操作，可以通过HiveQL进行数据清洗、转换和提取。</p></li><li><p>扩展性和集成：Hive可以与其他Hadoop生态系统组件集成，如HDFS、HBase、Spark等。它还支持自定义函数（UDF）和扩展插件，允许用户编写自定义逻辑和扩展功能。</p></li><li><p>元数据管理：Hive维护表和分区的元数据信息，包括表的结构、存储位置、分区信息等。这使得Hive能够提供更高级别的查询优化和查询计划生成。</p></li></ol><p>Hive广泛应用于大数据领域，特别是数据仓库、数据分析和数据处理场景。它提供了一种简化的方式来使用SQL语言进行大数据查询和处理，使得更多的人可以轻松地利用Hadoop集群进行数据分析和数据挖掘。</p><p>Spark是Hadoop的子项目。 环境中将Spark安装到基于Linux的系统中。</p><p>相关配置变量如下：</p><ol><li>JAVA_HOME：Java安装目录</li><li>HADOOP_HOME：Hadoop安装目录</li><li>HADOOP_CONF_DIR：Hadoop集群的配置文件的目录</li><li>SPARK_MASTER_IP：Spark集群的Master节点的ip地址</li><li>SPARK_WORKER_MEMORY：每个worker节点能够最大分配给exectors的内存大小</li></ol><p><strong>配置步骤</strong></p><ol><li><p>将Spark安装包解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf [spark]</span><br></pre></td></tr></table></figure></li><li><p>文件&#x2F;etc&#x2F;profile中配置环境变量SPARK_HOME，将Spark安装路径中的bin目录加入PATH系统变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/usr/spark/spark-2.4.3-bin-hadoop2.7</span><br><span class="line">export PATH=$SPARK_HOME/bin:$SPARK_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件spark-env.sh，设置主机节点为master，设置java安装路径，设置节点内存为8g，设置hadoop安装目录、hadoop集群的配置文件的目录，添加spark从节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/spark/spark-2.4.3-bin-hadoop2.7/conf</span><br><span class="line">cp spark-defaults.sh.template spark-env.sh</span><br><span class="line"></span><br><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_221</span><br><span class="line">export SPARK_MASTER_IP=master</span><br><span class="line">export HADOOP_CONF_DIR=/usr/hadoop/hadoop-2.7.7/etc/hadoop</span><br><span class="line">export HADOOP_HOME=/usr/hadoop/hadoop-2.7.7</span><br><span class="line">export SPARK_WORKER_MEMORY=8g</span><br></pre></td></tr></table></figure><p>添加从节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp slaves.template slaves</span><br><span class="line">vim slaves</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave</span><br></pre></td></tr></table></figure></li><li><p>分发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/spark root@slave:/usr</span><br><span class="line">scp /etc/profile root@slave:/etc</span><br></pre></td></tr></table></figure></li><li><p>开启集群，查看各节点进程(主节点进程为Master，子节点进程为Worker)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/spark/spark-2.4.3-bin-hadoop2.7/sbin</span><br><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="07-14-Hadoop-MapReduce"><a href="#07-14-Hadoop-MapReduce" class="headerlink" title="07-14 Hadoop MapReduce"></a>07-14 Hadoop MapReduce</h2><p><strong>概念</strong><br>Hadoop MapReduce是Hadoop生态系统中的一个计算模型和编程框架，用于处理大规模数据集的分布式计算任务。</p><p>MapReduce模型旨在解决大规模数据处理的并行化和分布式计算问题。它将计算任务分解为两个主要阶段：Map阶段和Reduce阶段。</p><p>在Map阶段，数据被分割成小的数据块，并由多个Map任务并行处理。每个Map任务将输入数据块转换为一系列键值对，其中键表示中间结果的标识，值表示相关数据。</p><p>在Reduce阶段，通过对Map阶段输出的中间结果进行整理和归并，将具有相同键的值聚合在一起。这样，Reduce任务可以对每个键的值进行处理，生成最终的计算结果。</p><p>Hadoop<br>MapReduce提供了一个编程模型和框架，使开发人员能够编写并行计算任务，并将其自动分布到Hadoop集群中的多个节点上执行。开发人员可以使用Java等编程语言编写MapReduce作业，利用Hadoop框架提供的API来处理输入数据、定义Map和Reduce函数，并设置作业的配置参数。</p><p>通过利用Hadoop MapReduce的分布式计算能力，可以有效地处理大规模数据集，实现数据处理、数据挖掘、日志分析等各种应用场景。</p><h3 id="WordCount程序"><a href="#WordCount程序" class="headerlink" title="WordCount程序"></a>WordCount程序</h3><p><strong>数据说明</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shakespeare Sonnet</span><br><span class="line">Shall I compare thee to a summer&#x27;s day?</span><br><span class="line">Thou art more lovely and more temperate:</span><br><span class="line">Rough winds do shake the darling buds of May,</span><br><span class="line">And summer&#x27;s lease hath all too short a date:</span><br><span class="line">Sometime too hot the eye of heaven shines,</span><br><span class="line">And often is his gold complexion dimm&#x27;d;</span><br><span class="line">And every fair from fair sometime declines,</span><br><span class="line">By chance or nature&#x27;s changing course untrimm&#x27;d</span><br><span class="line">But thy eternal summer shall not fade</span><br><span class="line">Nor lose possession of that fair thou owest;</span><br><span class="line">Nor shall Death brag thou wander&#x27;st in his shade,</span><br><span class="line">When in eternal lines to time thou growest:</span><br><span class="line">So long as men can breathe or eyes can see,</span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure><p><strong>程序实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountDriver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1、获取Job</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf);</span><br><span class="line">        <span class="comment">//设置jar包路径</span></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line">        <span class="comment">//3、关联map和reducer</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line">        <span class="comment">//4、设置map的输出kv类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//5、设置最终输出的kv类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//6、设置输入输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//7、提交job</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">k</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> value.toString();</span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            k.set(word);</span><br><span class="line">            context.write(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        v.set(sum);</span><br><span class="line">        context.write(key, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="07-15-Hive数据分析"><a href="#07-15-Hive数据分析" class="headerlink" title="07-15 Hive数据分析"></a>07-15 Hive数据分析</h2><p><strong>概述</strong></p><p>Hive是基于Hadoop的数据仓库基础设施，它提供了一种类SQL的查询语言（HiveQL）来进行数据分析。Hive使得使用类似于传统关系型数据库的查询语言进行大规模数据处理和分析变得更加容易。</p><p>以下是使用Hive进行数据分析的一般步骤：</p><ol><li><p>创建数据表：首先，你需要在Hive中创建适合你数据的表。使用Hive的数据定义语言（DDL），你可以定义表的结构、字段和数据类型。你可以选择将数据加载到表中，或者使用外部表引用现有的数据。</p></li><li><p>导入数据：如果你的数据尚未在Hive中可用，你可以使用Hive的数据导入功能将数据加载到表中。Hive支持从各种数据源导入数据，如文本文件、CSV文件、Parquet文件、HBase等。</p></li><li><p>执行查询：使用HiveQL编写查询语句来执行数据分析操作。HiveQL类似于传统的SQL语言，你可以使用SELECT语句、WHERE子句、GROUP BY子句、JOIN操作等来进行数据查询、过滤、聚合等操作。</p></li><li><p>存储结果：根据需要，你可以将查询结果存储到新的表中，以供后续分析使用。Hive支持将查询结果存储为新表或以其他格式导出到文件系统中。</p></li><li><p>优化查询性能：为了提高查询性能，你可以使用Hive的优化技术，如分区、分桶、索引等。这些技术可以减少数据扫描量和提高查询效率。</p></li><li><p>定期维护和管理：作为数据仓库，你需要定期维护和管理Hive环境。这包括数据清理、分区维护、表结构变更等。</p></li></ol><p>请注意，Hive适用于批处理和离线分析场景，对于实时查询和低延迟要求较高的场景，可能需要考虑其他技术或框架。</p><p>使用Hive进行数据分析需要一定的学习和了解，特别是HiveQL查询语言和Hive的表现行为。根据你的具体需求和数据情况，你可能需要深入学习和使用Hive的高级功能和技术。</p><h3 id="案例：房屋数据分析"><a href="#案例：房屋数据分析" class="headerlink" title="案例：房屋数据分析"></a>案例：房屋数据分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"># 标题                                           ,户型               ,区县,商圈,小区        ,房租,地铁,亮点1,亮点2,亮点3</span><br><span class="line"># 绿地 精装套二 随时看房 实图拍摄 临千盛 欧尚 优博 穿巷子,整租|2室2厅|84㎡|朝南,武侯,簇桥,绿地圣路易名邸,2400,,家电齐全,,</span><br><span class="line"># 警官公寓 合租 次卧103平米2室1厅1卫限女生,合租次卧|2户合租|103㎡,高新区,中和镇,警官公寓,860,,交通便利,合租女生,</span><br><span class="line"># 高新区大源嘉祥瑞庭南城 35平米1室1厅1卫,整租|1室1厅|35㎡|朝南北,高新区,大源,嘉祥瑞庭南城,2300,,采光好,,</span><br><span class="line"># 国光一环大厦1室1厅1卫,整租|1室1厅|60㎡|朝南,成华,建设路伊藤,国光一环大厦,1300,红星桥站,随时入住,,</span><br><span class="line"># 双流蛟龙港世纪华都高层 93平米3室1厅1卫,整租|3室1厅|93㎡|朝南北,双流,蛟龙港,世纪华都高层,1400,,家电齐全,,</span><br><span class="line"># 浣花苑1室1厅1卫,整租|1室1厅|64㎡|朝南,青羊,杜甫草堂,浣花苑,600,草堂北路站,随时入住,,</span><br><span class="line"># 华宇阳光水岸 合租 次卧80平米2室1厅1卫性别不限,合租次卧|2户合租|80㎡|朝南,成华,驷马桥,华宇阳光水岸,700,昭觉寺南路站,性别不限,随时入住,</span><br><span class="line"># 润扬川大河畔一期1室1厅1卫,整租|1室1厅|60㎡|朝南,双流,航空港,润扬川大河畔一期,1300,,交通便利,随时入住,</span><br><span class="line"># 东立光华杏林 整租 1室1厅1卫 50平米(个人),整租|1室1厅|50㎡|朝南,青羊,万家湾,东立光华杏林,1600,中坝站,精装修,,</span><br><span class="line"></span><br><span class="line"># 在hive数据库下构建数据表house</span><br><span class="line">create table if not exists house</span><br><span class="line">(</span><br><span class="line">    title string comment &#x27;标题&#x27;,</span><br><span class="line">    layout string comment &#x27;户型&#x27;,</span><br><span class="line">    district string comment &#x27;区县&#x27;,</span><br><span class="line">    area string comment &#x27;商圈&#x27;,</span><br><span class="line">    estate string comment &#x27;楼盘&#x27;,</span><br><span class="line">    rent int comment &#x27;房租&#x27;,</span><br><span class="line">    station string comment &#x27;地铁&#x27;,</span><br><span class="line">    merit1 string comment &#x27;亮点1&#x27;,</span><br><span class="line">    merit2 string comment &#x27;亮点2&#x27;,</span><br><span class="line">    merit3 string comment &#x27;亮点3&#x27;</span><br><span class="line">) row format delimited</span><br><span class="line">fields terminated by &#x27;,&#x27;</span><br><span class="line">tblproperties(&#x27;skip.header.line.count&#x27;=&#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line"># 导入数据house.csv</span><br><span class="line">load data local inpath &#x27;/root/house/house.csv&#x27;overwrite into table house;</span><br><span class="line"></span><br><span class="line"># 计算房屋出租量前十的楼盘排名，结果写入本地/college2020/01/000000_0 （二维数组：楼盘 数量,不计入空值）</span><br><span class="line">insert overwrite local directory &#x27;/college2020/01&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select estate, count(*) as row_count</span><br><span class="line">from house</span><br><span class="line">where estate is not null</span><br><span class="line">group by estate</span><br><span class="line">order by row_count desc, estate</span><br><span class="line">limit 10;</span><br><span class="line"></span><br><span class="line"># 计算房屋出租量前十的商圈排名，结果写入本地/college2020/02/000000_0 （二维数组：商圈 数量,不计入空值）</span><br><span class="line">insert overwrite local directory &#x27;/college2020/02&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select area, count(*) as area_count</span><br><span class="line">from house</span><br><span class="line">where area is not null</span><br><span class="line">group by area</span><br><span class="line">order by area_count desc, area</span><br><span class="line">limit 10;</span><br><span class="line"></span><br><span class="line"># 整理双流区整租三室一厅不同楼盘价格，结果写入本地/college2020/03/000000_0 (二维数组：楼盘 价格，为均价降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/03&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select estate, avg(rent) as avg_rent</span><br><span class="line">from house</span><br><span class="line">where district like &#x27;%双流%&#x27;</span><br><span class="line">  and split(layout, &#x27;\\|&#x27;)[0] = &#x27;整租&#x27;</span><br><span class="line">  and split(layout, &#x27;\\|&#x27;)[1] = &#x27;3室1厅&#x27;</span><br><span class="line">group by estate</span><br><span class="line">order by avg_rent desc;</span><br><span class="line"></span><br><span class="line"># 现想在中坝站万家湾附近进行合租，试给出户型及房租信息进行参考，结果写入本地/college2020/04/000000_0 (二维数组：户型 价格降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/04&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select layout, rent</span><br><span class="line">from house</span><br><span class="line">where station = &#x27;中坝站&#x27;</span><br><span class="line">  and area = &#x27;万家湾&#x27;</span><br><span class="line">  and split(layout, &#x27;\\|&#x27;)[0] like &#x27;%合租%&#x27;</span><br><span class="line">order by rent desc;</span><br><span class="line"></span><br><span class="line"># 现想在保利星座进行租房，预算为1000-1500，试给出参考户型信息，结果写入本地/college2020/05/000000_0 (二维数组：户型 价格降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/05&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select layout, rent</span><br><span class="line">from house</span><br><span class="line">where estate like &#x27;%保利星座%&#x27;</span><br><span class="line">  and rent between 1000 and 1500</span><br><span class="line">order by rent desc;</span><br><span class="line"></span><br><span class="line"># 试列出不同商圈整租1室1厅的价格TOP3，结果写入本地/college2020/06/000000_0 (二维数组：商圈 价格，均值降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/06&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select area, avg(rent) as avg_rent</span><br><span class="line">from house</span><br><span class="line">where split(layout, &#x27;\\|&#x27;)[0] = &#x27;整租&#x27;</span><br><span class="line">  and split(layout, &#x27;\\|&#x27;)[1] = &#x27;1室1厅&#x27;</span><br><span class="line">group by area</span><br><span class="line">order by avg_rent desc</span><br><span class="line">limit 3;</span><br><span class="line"></span><br><span class="line"># 试列出高新区不同户型的整租价格清单，结果写入本地/college2020/07/000000_0 (二维数组示例：3室2厅 4000，均值向下取整降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/07&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select split(layout, &#x27;\\|&#x27;)[1], floor(avg(rent)) as avg_rent</span><br><span class="line">from house</span><br><span class="line">where district like &#x27;%高新区%&#x27;</span><br><span class="line">  and split(layout, &#x27;\\|&#x27;)[0] like &#x27;%整租%&#x27;</span><br><span class="line">group by split(layout, &#x27;\\|&#x27;)[1]</span><br><span class="line">order by avg_rent desc;</span><br><span class="line"></span><br><span class="line"># 合并房屋出租亮点(特点),给出常用亮点TOP5,结果写入本地/college2020/08/000000_0 (二维数组:亮点 数量，不计入空值，降序)</span><br><span class="line">insert overwrite local directory &#x27;/college2020/08&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select merit, count(*) as merit_count</span><br><span class="line">from (select merit1 as merit</span><br><span class="line">      from house</span><br><span class="line">      union all</span><br><span class="line">      select merit2 as merit</span><br><span class="line">      from house</span><br><span class="line">      union all</span><br><span class="line">      select merit3 as merit</span><br><span class="line">      from house) t</span><br><span class="line">group by merit</span><br><span class="line">order by merit_count desc</span><br><span class="line">limit 5;</span><br></pre></td></tr></table></figure><h2 id="07-16-Spark数据分析"><a href="#07-16-Spark数据分析" class="headerlink" title="07-16 Spark数据分析"></a>07-16 Spark数据分析</h2><h3 id="案例：WordCount"><a href="#案例：WordCount" class="headerlink" title="案例：WordCount"></a>案例：WordCount</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span></span><br><span class="line">      .getLogger(<span class="string">&quot;org.apache.spark&quot;</span>)</span><br><span class="line">      .setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="comment">// 新建SparkConf对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">      .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    <span class="comment">// 创建SparkContext对象</span></span><br><span class="line">    <span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(config = conf)</span><br><span class="line">    <span class="comment">// 定义打开的文件</span></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sparkContext.textFile(<span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/words.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 按行分割单词</span></span><br><span class="line">    <span class="keyword">var</span> wordCountResultRDD = fileRDD.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.flatMap(_.split(<span class="string">&quot; &quot;</span>).map((_, <span class="number">1</span>)))</span><br><span class="line">    &#125;)</span><br><span class="line">      <span class="comment">// (word1,3) (word2, 2) (word3, 5)</span></span><br><span class="line">      .reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    wordCountResultRDD.collect().foreach(println)</span><br><span class="line">    wordCountResultRDD.saveAsTextFile(<span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/WordCountResult&quot;</span>)</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    sparkContext.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例：搜索引擎日志分析"><a href="#案例：搜索引擎日志分析" class="headerlink" title="案例：搜索引擎日志分析"></a>案例：搜索引擎日志分析</h3><ol><li><p>封装数据</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">queryTime  访问时间，格式为：HH:mm:ss</span></span><br><span class="line"><span class="comment">userId     用户ID</span></span><br><span class="line"><span class="comment">queryWords 查询词</span></span><br><span class="line"><span class="comment">resultRank 该URL在返回结果中的排名</span></span><br><span class="line"><span class="comment">clickRank  用户点击的顺序号</span></span><br><span class="line"><span class="comment">clickUrl   用户点击的URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SogouRecord</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                        queryTime:<span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        userId:<span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        queryWords:<span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        resultRank:<span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        clickRank:<span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        clickUrl:<span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="class">                      </span>)</span></span><br></pre></td></tr></table></figure></li><li><p>使用case class反射，适用于简单分析</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hankcs.hanlp.<span class="type">HanLP</span></span><br><span class="line"><span class="keyword">import</span> com.hankcs.hanlp.seg.common.<span class="type">Term</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SearchEngineLogAnalysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span></span><br><span class="line">      .getLogger(<span class="string">&quot;org.apache.spark&quot;</span>)</span><br><span class="line">      .setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="comment">// 新建SparkConf对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setAppName(<span class="string">&quot;SearchEngineLogAnalysis&quot;</span>)</span><br><span class="line">      .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    <span class="comment">// 创建SparkContext对象</span></span><br><span class="line">    <span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(config = conf)</span><br><span class="line">    <span class="keyword">val</span> file = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/reduced.txt&quot;</span></span><br><span class="line">    <span class="keyword">val</span> outputPath1 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/queryWordsWordCountRDD&quot;</span></span><br><span class="line">    <span class="keyword">val</span> outputPath2 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/userQueryAnalysisRDD&quot;</span></span><br><span class="line">    <span class="keyword">val</span> outputPath3 = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/timeQueryCountAnalysisRDD&quot;</span></span><br><span class="line">    <span class="keyword">val</span> rddSougouRecord = sparkContext.textFile(file)</span><br><span class="line">      <span class="comment">// 过滤空行数据、过滤字段数量不等于6</span></span><br><span class="line">      .filter(line =&gt; line != <span class="literal">null</span> &amp;&amp; line.trim.split(<span class="string">&quot;\\s+&quot;</span>).length == <span class="number">6</span>)</span><br><span class="line">      <span class="comment">// 将RDD[String]=&gt;RDD[SogouRecord]</span></span><br><span class="line">      .mapPartitions(it =&gt; &#123;</span><br><span class="line">        it.map(line =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">          <span class="comment">// 注意字段格式</span></span><br><span class="line">          <span class="type">SogouRecord</span>(</span><br><span class="line">            contents(<span class="number">0</span>),</span><br><span class="line">            contents(<span class="number">1</span>),</span><br><span class="line">            <span class="comment">// [360安全卫士]</span></span><br><span class="line">            contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">            contents(<span class="number">3</span>).toInt,</span><br><span class="line">            contents(<span class="number">4</span>).toInt,</span><br><span class="line">            contents(<span class="number">5</span>)</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    rddSougouRecord.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>).count()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryWordsWordCountRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.flatMap(record =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> terms: util.<span class="type">List</span>[<span class="type">Term</span>] = <span class="type">HanLP</span>.segment(record.queryWords.trim)</span><br><span class="line">        <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">        terms.asScala.map(_.word)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).map((_, <span class="number">1</span>)).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    queryWordsWordCountRDD.coalesce(numPartitions = <span class="number">1</span>).saveAsTextFile(outputPath1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userQueryAnalysisRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(record =&gt; &#123;</span><br><span class="line">        ((record.userId, record.queryWords), <span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">    userQueryAnalysisRDD.coalesce(<span class="number">1</span>).saveAsTextFile(outputPath2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeQueryCountAnalysisRDD = rddSougouRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(record =&gt; &#123;</span><br><span class="line">        (record.queryTime.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">    timeQueryCountAnalysisRDD.coalesce(<span class="number">1</span>).saveAsTextFile(outputPath3)</span><br><span class="line"></span><br><span class="line">    rddSougouRecord.unpersist()</span><br><span class="line">    sparkContext.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用StructType编程，适用于复杂分析</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">Row</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">IntegerType</span>, <span class="type">StringType</span>, <span class="type">StructField</span>, <span class="type">StructType</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SogouAnalysisSQL</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 设置输出的日志级别</span></span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder()</span><br><span class="line">      .appName(<span class="string">&quot;SogouAnalysisSQL&quot;</span>)</span><br><span class="line">      .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/reduced.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = spark.sparkContext.textFile(file)</span><br><span class="line">      .filter(line =&gt; line != <span class="literal">null</span> &amp;&amp; line.trim.split(<span class="string">&quot;\\s+&quot;</span>).length == <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> schema = <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;queryTime&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;userId&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;queryWords&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;resultRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;clickRank&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">false</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;clickUrl&quot;</span>, <span class="type">StringType</span>, <span class="literal">false</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RDD[String] =&gt; RDD[Row]</span></span><br><span class="line">    <span class="keyword">val</span> rddRow = fileRDD.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;\\s+&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 封装的字段的时候，顺序要与定义的schema顺序完全一致</span></span><br><span class="line">          <span class="type">Row</span>(</span><br><span class="line">            contents(<span class="number">0</span>),</span><br><span class="line">            contents(<span class="number">1</span>),</span><br><span class="line">            contents(<span class="number">2</span>).replaceAll(<span class="string">&quot;[\\[|\\]]&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">            contents(<span class="number">3</span>).toInt,</span><br><span class="line">            contents(<span class="number">4</span>).toInt,</span><br><span class="line">            contents(<span class="number">5</span>)</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; <span class="type">Row</span>(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RDD[Row] ==&gt; DataFrame</span></span><br><span class="line">    <span class="keyword">val</span> df = spark.createDataFrame(rddRow, schema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将DataFrame注册为临时视图</span></span><br><span class="line">    df.createOrReplaceTempView(<span class="string">&quot;sogou_view&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义查询的sql</span></span><br><span class="line">    <span class="keyword">val</span> sql =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select * from sogou_view where clickUrl like &#x27;www%&#x27;</span></span><br><span class="line"><span class="string">        |limit 3</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    <span class="keyword">val</span> sqlResult = spark.sql(sql)</span><br><span class="line">    <span class="comment">//    sqlResult.show(truncate = false)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> querySQL =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select userId,queryWords,count(*) as query_count from sogou_view</span></span><br><span class="line"><span class="string">        |group by userId,queryWords</span></span><br><span class="line"><span class="string">        |order by userid,query_count desc</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queryResult = spark.sql(querySQL)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    queryResult.show(truncate = false)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeSQL =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |select substring(queryTime,0,5) as query_time,count(*) as query_count from sogou_view</span></span><br><span class="line"><span class="string">        |group by substring(queryTime,0,5)</span></span><br><span class="line"><span class="string">        |order by query_time,query_count desc</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeResult = spark.sql(timeSQL)</span><br><span class="line">    timeResult.show(truncate = <span class="literal">false</span>)</span><br><span class="line">    timeResult.rdd.coalesce(<span class="number">1</span>).saveAsTextFile(<span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/timeResult&quot;</span>)</span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例数据</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00:00:002982199073774412[360安全卫士]8 3download.it.com.cn/softweb/software/firewall/antivirus/20067/17938.html</span><br><span class="line">00:00:0007594220010824798[哄抢救灾物资]1 1news.21cn.com/social/daqian/2008/05/29/4777194_1.shtml</span><br><span class="line">00:00:005228056822071097[75810部队]14 5www.greatoo.com/greatoo_cn/list.asp?link_id=276&amp;title=%BE%DE%C2%D6%D0%C2%CE%C5</span><br><span class="line">00:00:006140463203615646[绳艺]62 36www.jd-cd.com/jd_opus/xx/200607/706.html</span><br><span class="line">00:00:008561366108033201[汶川地震原因]3 2www.big38.net/</span><br><span class="line">00:00:0023908140386148713[莫衷一是的意思]1 2www.chinabaike.com/article/81/82/110/2007/2007020724490.html</span><br><span class="line">00:00:001797943298449139[星梦缘全集在线观看]8 5www.6wei.net/dianshiju/????\xa1\xe9|????do=index</span><br></pre></td></tr></table></figure></li></ol><h3 id="案例：手机基站日志分析"><a href="#案例：手机基站日志分析" class="headerlink" title="案例：手机基站日志分析"></a>案例：手机基站日志分析</h3><ol><li><p>示例数据<br><strong>基站信息数据（基站ID 经度 纬度 信号辐射类型）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9F36407EAD0629FC166F14DDE7970F68,116.304864,40.050645,6</span><br><span class="line">CC0710CC94ECC657A8561DE549D940E0,116.303955,40.041935,6</span><br><span class="line">16030401EAFB68F1E3CDF819735E1C66,116.296302,40.032296,6</span><br></pre></td></tr></table></figure><p><strong>用户信息数据（手机号 时间(时间戳) 基站ID 连接状态（“1”为连接，“0”为断开））</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">13554756349,20211202082000,16030401EAFB68F1E3CDF819735E1C66,1</span><br><span class="line">13236723613,20211202082500,16030401EAFB68F1E3CDF819735E1C66,1</span><br><span class="line">13554756349,20211202180000,16030401EAFB68F1E3CDF819735E1C66,0</span><br><span class="line">13236723613,20211202180000,16030401EAFB68F1E3CDF819735E1C66,0</span><br><span class="line">13236723613,20211202075000,9F36407EAD0629FC166F14DDE7970F68,1</span><br><span class="line">13554756349,20211202075100,9F36407EAD0629FC166F14DDE7970F68,1</span><br><span class="line">13236723613,20211202081000,9F36407EAD0629FC166F14DDE7970F68,0</span><br><span class="line">13554756349,20211202081300,9F36407EAD0629FC166F14DDE7970F68,0</span><br><span class="line">13554756349,20211202175000,9F36407EAD0629FC166F14DDE7970F68,1</span><br><span class="line">13236723613,20211202182000,9F36407EAD0629FC166F14DDE7970F68,1</span><br><span class="line">13554756349,20211202220000,9F36407EAD0629FC166F14DDE7970F68,0</span><br><span class="line">13236723613,20211202230000,9F36407EAD0629FC166F14DDE7970F68,0</span><br><span class="line">13236723613,20211202081100,CC0710CC94ECC657A8561DE549D940E0,1</span><br><span class="line">13554756349,20211202081200,CC0710CC94ECC657A8561DE549D940E0,1</span><br><span class="line">13554756349,20211202081900,CC0710CC94ECC657A8561DE549D940E0,0</span><br><span class="line">13236723613,20211202082000,CC0710CC94ECC657A8561DE549D940E0,0</span><br><span class="line">13554756349,20211202171000,CC0710CC94ECC657A8561DE549D940E0,1</span><br><span class="line">13554756349,20211202171600,CC0710CC94ECC657A8561DE549D940E0,0</span><br><span class="line">13236723613,20211202180500,CC0710CC94ECC657A8561DE549D940E0,1</span><br><span class="line">13236723613,20211202181500,CC0710CC94ECC657A8561DE549D940E0,0</span><br></pre></td></tr></table></figure></li><li><p>case Class</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStation</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                        baseStationId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        longitude: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        latitude: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                        signalRadiationType: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="class">                      </span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRecord</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">                       phone: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                       time: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                       baseStationId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                       connectionStatus: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="class">                     </span>)</span></span><br></pre></td></tr></table></figure></li><li><p>main</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求一：要求使用Sparkcore对分析数据进行分割处理获取业务需求所使用到的数据，根据不同用户在基站停留的时长数据统计出用户与停留地点的关系。</span></span><br><span class="line"><span class="comment">（1）根据用户信息中&quot;手机号,基站ID&quot;做为唯一标识，和时间戳构成新的元组--&gt;((手机号, 站点), 时间戳)</span></span><br><span class="line"><span class="comment">（2）以（手机号，基站ID）作为key，通过reduceByKey算子进行聚合，计算出在基站的停留时间，构成新的数据结构，以便和坐标数据进行join，生成元组--&gt;(基站ID,(手机号,停留时间))</span></span><br><span class="line"><span class="comment">（3）将基站坐标数据信息进行拆分，通过map，构建成包含基站ID、经纬度的元组 --&gt;(基站ID,(经度,纬度))</span></span><br><span class="line"><span class="comment">（4）将2、3结果根据基站ID进行join操作，构成新的数据类型--&gt;(手机号,基站ID,停留时间,(经度,纬度))</span></span><br><span class="line"><span class="comment">（5）按手机号进行分组--&gt;(手机号,(手机号,基站ID,停留时间,(经度,纬度)))</span></span><br><span class="line"><span class="comment">（6）对时间进行排序取出停留时间最长的基站ID（top1），则可能是居住地点和工作地点。</span></span><br><span class="line"><span class="comment">（7）格式结果：(手机号,List(手机号,停留时间,基站ID,(经度,纬度)))</span></span><br><span class="line"><span class="comment">（8）注意：按照手机号进行分组时，运算结果按照顺序为part-00000,part-00001...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MobileLocation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span></span><br><span class="line">      .getLogger(<span class="string">&quot;org.apache.spark&quot;</span>)</span><br><span class="line">      .setLevel(<span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;MobileLocation&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(config = sparkConf)</span><br><span class="line">    <span class="keyword">val</span> infoFile = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/mobilebasestationloganalysis/info.txt&quot;</span></span><br><span class="line">    <span class="keyword">val</span> userFile = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/mobilebasestationloganalysis/user.txt&quot;</span></span><br><span class="line">    <span class="keyword">val</span> outputPath = <span class="string">&quot;/Volumes/KeQing/Documents/IntelliJ IDEA Ultimate/SparkTraning/src/main/resources/output/mobilebasestationloganalysis&quot;</span></span><br><span class="line">    <span class="keyword">val</span> rddUserRecord = sparkContext.textFile(userFile)</span><br><span class="line">      .filter(line =&gt; line != <span class="literal">null</span>)</span><br><span class="line">      .mapPartitions(it =&gt; &#123;</span><br><span class="line">        it.map(line =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          <span class="comment">// 注意字段格式</span></span><br><span class="line">          <span class="type">UserRecord</span>(</span><br><span class="line">            contents(<span class="number">0</span>),</span><br><span class="line">            contents(<span class="number">1</span>).toLong,</span><br><span class="line">            contents(<span class="number">2</span>),</span><br><span class="line">            contents(<span class="number">3</span>).toInt</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    rddUserRecord.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span>).count()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> basePhoneTime = rddUserRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(record =&gt; &#123;</span><br><span class="line">        ((record.phone, record.baseStationId, record.connectionStatus), record.time)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).reduceByKey(_ + _).sortBy(_._2, ascending = <span class="literal">false</span>)</span><br><span class="line">      .mapPartitions(line =&gt; &#123;</span><br><span class="line">        line.map(</span><br><span class="line">          line =&gt; &#123;</span><br><span class="line">            ((line._1._1, line._1._2), line._2)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;).reduceByKey(_ - _)</span><br><span class="line">      .mapPartitions(it =&gt; &#123;</span><br><span class="line">        it.map(line =&gt; &#123;</span><br><span class="line">          (line._1._2, (line._1._1, line._2))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;).sortBy(_._2._2, ascending = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rddInfoRecord = sparkContext.textFile(infoFile)</span><br><span class="line">      .filter(line =&gt; line != <span class="literal">null</span>)</span><br><span class="line">      .mapPartitions(it =&gt; &#123;</span><br><span class="line">        it.map(line =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> contents = line.trim.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          <span class="type">BaseStation</span>(</span><br><span class="line">            contents(<span class="number">0</span>),</span><br><span class="line">            contents(<span class="number">1</span>).toDouble,</span><br><span class="line">            contents(<span class="number">2</span>).toDouble,</span><br><span class="line">            contents(<span class="number">3</span>).toInt</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> baseLongLat = rddInfoRecord.mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(record =&gt; &#123;</span><br><span class="line">        (record.baseStationId, (record.longitude, record.latitude))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// (手机号,基站ID,停留时间,(经度,纬度))</span></span><br><span class="line">    <span class="keyword">val</span> basePhoneTimeLongLat = basePhoneTime.join(baseLongLat).mapPartitions(it =&gt; &#123;</span><br><span class="line">      it.map(line =&gt; &#123;</span><br><span class="line">        (line._2._1._1, line._1, line._2._1._2, (line._2._2._1, line._2._2._2))</span><br><span class="line">      &#125;)</span><br><span class="line">        <span class="comment">// (手机号,(手机号,基站ID,停留时间,(经度,纬度))</span></span><br><span class="line">        .map(line =&gt; &#123;</span><br><span class="line">          (line._1, (line._2, line._3, line._4))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).groupByKey()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设dataRDD是一个RDD，包含了键值对（手机号，数据记录迭代器）</span></span><br><span class="line">    <span class="comment">// (手机号,停留时间,基站ID,(经度,纬度)</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Long</span>, (<span class="type">Double</span>, <span class="type">Double</span>))])] = basePhoneTimeLongLat</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成指定格式的RDD，并按照停留时间进行排序</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">String</span>, (<span class="type">Double</span>, <span class="type">Double</span>))])] = dataRDD.map &#123; <span class="keyword">case</span> (phoneNumber, records) =&gt;</span><br><span class="line">      <span class="keyword">val</span> resultData = records.map(record =&gt; (phoneNumber, record._2, record._1, (record._3._1, record._3._2))).toList</span><br><span class="line">      <span class="keyword">val</span> sortedResultData = resultData.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Long</span>.reverse) <span class="comment">// 按照停留时间降序排序</span></span><br><span class="line">      (phoneNumber, sortedResultData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取每个手机号的top1基站ID</span></span><br><span class="line">    <span class="keyword">val</span> top1BaseStationRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = resultRDD.map &#123; <span class="keyword">case</span> (phoneNumber, sortedResultData) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (sortedResultData.nonEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> top1BaseStationID = sortedResultData.head._3</span><br><span class="line">        (phoneNumber, top1BaseStationID)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (phoneNumber, <span class="string">&quot;Unknown&quot;</span>) <span class="comment">// 若没有停留记录，则标记为Unknown</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    top1BaseStationRDD.foreach &#123; <span class="keyword">case</span> (phoneNumber, top1BaseStationID) =&gt;</span><br><span class="line">      println(<span class="string">s&quot;手机号 <span class="subst">$phoneNumber</span> 的停留时间最长的基站ID为 <span class="subst">$top1BaseStationID</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resultRDD.saveAsTextFile(outputPath)</span><br><span class="line">    sparkContext.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="学习目标评估"><a href="#学习目标评估" class="headerlink" title="学习目标评估"></a>学习目标评估</h2><p>在本次培训开始之前，我们明确了学习目标，并与参与人员共享，以便让他们了解培训的预期成果。我们希望通过本次培训，参与人员能够：</p><ol><li>理解 MapReduce 的基本概念和原理，掌握分布式计算的基本思想。</li><li>掌握 Hive 的使用，了解如何利用 Hive 进行数据仓库和数据分析。</li><li>熟悉 Spark 的核心概念和编程模型，能够使用 Spark 进行大规模数据处理和分析。</li></ol><h2 id="培训成果"><a href="#培训成果" class="headerlink" title="培训成果"></a>培训成果</h2><p>通过本次培训，参与人员在以下方面取得了显著的进步：</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul><li>参与人员深入理解了 MapReduce 的基本原理和分布式计算的概念。</li><li>他们学会了如何使用 Hadoop 生态系统来实现 MapReduce 任务，并在实际练习中体验了分布式计算的优势和挑战。</li></ul><h3 id="Hive-1"><a href="#Hive-1" class="headerlink" title="Hive"></a>Hive</h3><ul><li>参与人员掌握了 Hive 的基本使用方法，包括创建表、数据导入导出、查询数据等操作。</li><li>他们了解了 Hive 的数据仓库和数据分析能力，能够使用 Hive 进行复杂的数据查询和数据处理。</li></ul><h3 id="Spark-1"><a href="#Spark-1" class="headerlink" title="Spark"></a>Spark</h3><ul><li>参与人员熟悉了 Spark 的核心概念，包括 RDD、DataFrame 和 Spark SQL 等。</li><li>他们学会了使用 Spark 进行大规模数据处理和分析，并在实际实验中体验了 Spark 的高性能和灵活性。</li></ul><h3 id="专业成长"><a href="#专业成长" class="headerlink" title="专业成长"></a>专业成长</h3><ul><li>通过本次培训，参与人员在大数据处理和分析领域获得了实际动手经验，提升了相关技能。</li><li>培训中的案例和实践让他们对大数据处理技术有了更深入的理解，为未来在数据领域的工作提供了坚实的基础。</li></ul><p>总结：<br>本次 MapReduce、Hive 和 Spark 的培训为参与人员提供了一次高质量的学习机会。参与人员在专业技能和知识水平方面取得了显著进步，他们对大数据处理和分析有了更深入的了解。通过持续改进培训内容和反馈机制，我们将继续提高培训的质量，帮助更多的人在大数据领域取得成功。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> Spark </tag>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尺度不变特征变换SIFT</title>
      <link href="/2023/07/11/%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E5%8F%98%E6%8D%A2SIFT/"/>
      <url>/2023/07/11/%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E5%8F%98%E6%8D%A2SIFT/</url>
      
        <content type="html"><![CDATA[<h1 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h1><p>尺度不变特征变换（Scale-Invariant Feature Transform，SIFT）是一种用于计算机视觉和图像处理的算法。它是由David Lowe在1999年提出的，并成为一种广泛应用的特征提取和匹配方法。</p><p>SIFT算法的主要目标是从图像中提取出具有尺度不变性的特征点，并能够在不同尺度、旋转和亮度条件下进行匹配。它在计算机视觉领域被广泛用于图像识别、目标检测和图像拼接等任务。</p><p>SIFT算法的主要步骤包括：</p><ol><li><p>尺度空间极值检测：通过构建高斯金字塔，检测图像在不同尺度上的局部极值点，这些点往往对应于具有不同尺度的特征。</p></li><li><p>关键点定位：在尺度空间的极值点上，通过利用图像的梯度信息和曲率来选择稳定的关键点。这些关键点通常位于图像中的角点、边缘等显著的位置。</p></li><li><p>方向分配：为每个关键点分配一个主导方向，使得特征具有旋转不变性。这通常通过计算关键点周围区域的梯度方向直方图来实现。</p></li><li><p>特征描述：在关键点附近的局部区域内，构建描述子，用来表示关键点周围的图像特征。描述子通常基于局部图像梯度的方向和强度信息，具有尺度和旋转不变性。</p></li><li><p>特征匹配：通过比较不同图像的特征描述子，利用特征间的相似度进行匹配。常用的方法是计算特征向量之间的欧氏距离或相似性度量，选择最佳的匹配对。</p></li></ol><p>SIFT算法的关键在于其对尺度和旋转的不变性，使得它能够在不同视角和条件下进行可靠的特征匹配。这使得SIFT成为许多计算机视觉应用中的重要工具。</p><h2 id="尺度空间极值检测"><a href="#尺度空间极值检测" class="headerlink" title="尺度空间极值检测"></a>尺度空间极值检测</h2><p>尺度空间极值检测（Scale-space extrema detection）是一种在不同尺度上检测图像中的极值点的方法，用于寻找具有尺度不变性的特征点。该方法通常与尺度不变特征变换（SIFT）算法相关联。</p><p>尺度空间极值检测的基本思想是通过在图像的不同尺度上应用高斯滤波器，来寻找在不同尺度上的局部极值点。具体步骤如下：</p><ol><li><p>构建尺度空间金字塔：从原始图像开始，应用一系列的高斯滤波器，每个滤波器具有不同的尺度参数（标准差），生成一组具有不同模糊程度的图像。这些图像构成了尺度空间金字塔，其中较高层次的图像尺度比较小，具有更高的模糊程度。</p></li><li><p>在尺度空间的每一层上，比较每个像素的值与其邻域像素的值，找到局部极值点。极值点是指在一个局部邻域内，像素的值在该邻域中最大或最小。</p></li><li><p>对于找到的极值点，根据其响应值（如像素值或梯度大小）进行阈值处理和边界消除。通常，会设置一个阈值来筛选出具有较大响应值的极值点，同时通过非极大值抑制（non-maximum suppression）来消除邻域内的重复极值点。</p></li></ol><p>通过尺度空间极值检测，可以在不同尺度上发现具有尺度不变性的特征点，例如角点、边缘和斑点等。这些特征点可以在不同的尺度、旋转和光照条件下保持稳定，成为计算机视觉中许多任务（如目标检测、图像匹配和三维重建）的重要基础。</p><h3 id="构建尺度空间金字塔"><a href="#构建尺度空间金字塔" class="headerlink" title="构建尺度空间金字塔"></a>构建尺度空间金字塔</h3><p>构建尺度空间金字塔（Scale Space Pyramid）是指通过一系列图像处理操作，在不同尺度上构建一组具有不同模糊程度的图像集合，用于分析和处理图像。</p><p>构建尺度空间金字塔的一般步骤如下：</p><ol><li><p>初始层：将原始图像作为尺度空间金字塔的第一层。这是金字塔的最底层，也是原始图像的未经处理的版本。</p></li><li><p>下采样：对当前层次的图像进行下采样（如降采样），即减小图像的尺寸。下采样可以通过丢弃一些像素或使用插值等方法实现。这样可以生成一个比原始图像尺寸更小的图像。</p></li><li><p>高斯滤波：对下采样后的图像应用高斯滤波器。高斯滤波器通过在图像上进行卷积操作，对图像进行平滑处理。高斯滤波器的模糊程度由标准差参数决定。</p></li><li><p>重复步骤2和步骤3：依次对每个层次的图像进行下采样和高斯滤波的操作，直到达到所需的尺度或图像大小。</p></li></ol><p>通过重复执行下采样和高斯滤波操作，我们可以在不同尺度上构建一系列图像，形成尺度空间金字塔。每个层次的图像都对应于原始图像在不同尺度上的模糊版本。较高层次的图像具有更小的尺度和更高的模糊程度。</p><p>构建尺度空间金字塔的目的是为了在不同尺度上分析和处理图像，以提取尺度不变的特征，并在不同尺度上实现鲁棒的图像处理操作。尺度空间金字塔在计算机视觉领域的许多任务中都具有重要的应用，例如特征检测、目标识别和图像金字塔等。</p><details ><summary pointer> 示例 </summary>              <div class='content'>              <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_scale_space_pyramid</span>(<span class="params">image, num_octaves, num_scales</span>):</span><br><span class="line">    pyramid = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成图像金字塔的初始层</span></span><br><span class="line">    pyramid.append(image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置每个八度的尺度数量</span></span><br><span class="line">    scales_per_octave = num_scales - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> octave <span class="keyword">in</span> <span class="built_in">range</span>(num_octaves):</span><br><span class="line">        octave_images = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取当前八度的第一张图像</span></span><br><span class="line">        base_image = pyramid[octave * scales_per_octave]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成当前八度的尺度空间</span></span><br><span class="line">        <span class="keyword">for</span> scale <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_scales):</span><br><span class="line">            sigma = <span class="number">2</span> ** (octave + (scale / scales_per_octave))  <span class="comment"># 计算当前尺度的标准差</span></span><br><span class="line">            scaled_image = cv2.GaussianBlur(base_image, (<span class="number">0</span>, <span class="number">0</span>), sigmaX=sigma, sigmaY=sigma)</span><br><span class="line">            octave_images.append(scaled_image)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前八度的图像加入到金字塔中</span></span><br><span class="line">        pyramid.extend(octave_images)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 缩小基础图像作为下一个八度的起始图像</span></span><br><span class="line">        base_image = cv2.resize(base_image, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>)</span><br><span class="line">        pyramid.append(base_image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pyramid</span><br></pre></td></tr></table></figure><img src="https://s1.imagehub.cc/images/2023/07/11/2023-07-11-15.20.12.png" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/2023-07-11-15.20.12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="示例"><p>在尺度空间金字塔中，”octave”（八度）和 “scale”（尺度）是用来描述金字塔的层级结构和尺度级别的参数。</p><ul><li>八度（octave）：尺度空间金字塔按照一种对数尺度进行组织，每个八度对应着一个特定的尺度范围。每个八度中，金字塔的每一层图像都是在基础图像上进行下采样得到的。八度的数量决定了金字塔的层级结构和尺度的覆盖范围。</li><li>尺度（scale）：每个八度中，金字塔的每一层都对应着一个特定的尺度级别。尺度是通过应用不同程度的高斯滤波器来实现的，而高斯滤波器的标准差（sigma）用于控制图像的模糊程度。每个尺度级别的图像都是基于前一个尺度级别的图像进行高斯模糊得到的。</li></ul><p>在尺度空间金字塔中，八度和尺度共同确定了金字塔的层级结构和图像的模糊程度。不同的八度和尺度组合产生不同程度的图像模糊，并在尺度上覆盖了不同的细节和结构。</p><p>在代码示例中，<code>octave</code> 表示当前图像所在的八度，<code>scale</code> 表示当前图像所在的尺度。这些参数用于生成尺度空间金字塔，并在保存图像时作为命名的一部分，以方便识别图像所属的八度和尺度级别。</p><table><thead><tr><th>八度（Octave）</th><th>尺度（Scale）</th><th>图像文件名</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>octave_0_scale_0.jpg</td></tr><tr><td>0</td><td>1</td><td>octave_0_scale_1.jpg</td></tr><tr><td>0</td><td>2</td><td>octave_0_scale_2.jpg</td></tr><tr><td>0</td><td>3</td><td>octave_0_scale_3.jpg</td></tr><tr><td>1</td><td>0</td><td>octave_1_scale_0.jpg</td></tr><tr><td>1</td><td>1</td><td>octave_1_scale_1.jpg</td></tr><tr><td>1</td><td>2</td><td>octave_1_scale_2.jpg</td></tr><tr><td>1</td><td>3</td><td>octave_1_scale_3.jpg</td></tr><tr><td>2</td><td>0</td><td>octave_2_scale_0.jpg</td></tr><tr><td>2</td><td>1</td><td>octave_2_scale_1.jpg</td></tr><tr><td>2</td><td>2</td><td>octave_2_scale_2.jpg</td></tr><tr><td>2</td><td>3</td><td>octave_2_scale_3.jpg</td></tr><tr><td>3</td><td>0</td><td>octave_3_scale_0.jpg</td></tr><tr><td>3</td><td>1</td><td>octave_3_scale_1.jpg</td></tr><tr><td>3</td><td>2</td><td>octave_3_scale_2.jpg</td></tr><tr><td>3</td><td>3</td><td>octave_3_scale_3.jpg</td></tr><tr><td>4</td><td>0</td><td>octave_4_scale_0.jpg</td></tr><tr><td>4</td><td>1</td><td>octave_4_scale_1.jpg</td></tr><tr><td>4</td><td>2</td><td>octave_4_scale_2.jpg</td></tr><tr><td>4</td><td>3</td><td>octave_4_scale_3.jpg</td></tr><tr><td>5</td><td>0</td><td>octave_5_scale_0.jpg</td></tr></tbody></table>              </div>            </details><h4 id="图像尺度空间"><a href="#图像尺度空间" class="headerlink" title="图像尺度空间"></a>图像尺度空间</h4><p>图像尺度空间（Scale Space）是在不同尺度上对图像进行模糊处理，以便在不同尺度上分析和检测图像中的特征和结构。尺度空间理论在计算机视觉和图像处理中起着重要的作用，它允许我们在不同的尺度上对图像进行分析，并提取出尺度不变的特征。</p><p>在尺度空间中，通过应用一系列不同程度的高斯滤波器对图像进行模糊处理，从而得到一组具有不同模糊程度的图像。每个模糊图像表示了原始图像在不同尺度上的平滑版本。高斯滤波器的尺度参数决定了图像的模糊程度，较小的尺度对应于较细的细节，较大的尺度对应于较粗的结构。</p><p>图像尺度空间的构建可以通过以下步骤实现：</p><ol><li><p>选择一个初始尺度空间：在初始尺度上对图像应用高斯滤波器，得到第一层模糊图像。</p></li><li><p>生成尺度空间金字塔：对初始尺度图像进行下采样（如降采样），并在每个下采样层次上应用高斯滤波器，得到一组不同尺度的模糊图像。这形成了一个尺度空间金字塔，其中较高层次的图像尺度比较小，具有更高的模糊程度。</p></li><li><p>图像插值：由于下采样会导致图像信息的丢失，为了在不同尺度之间进行精确的插值，可以使用插值技术（如双线性插值）来恢复图像的分辨率。</p></li></ol><p>通过构建尺度空间，我们可以在不同尺度上检测和分析图像中的特征，例如边缘、角点和斑点等。这种尺度不变性对于许多计算机视觉任务（如目标检测、特征匹配和图像拼接）非常重要，因为它允许我们在不同的尺度上对图像进行鲁棒的处理和分析。</p><h4 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h4><p>高斯滤波器（Gaussian filter）是一种常用的线性平滑滤波器，用于对图像进行平滑处理和去除噪声。它基于高斯函数的数学模型，通过对图像进行卷积运算来实现。</p><p>高斯函数是一种钟形曲线，具有以下的形式：</p><p>$G(x, y) &#x3D; \frac{1}{2\pi\sigma^2} \cdot e^{-\frac{x^2 + y^2}{2\sigma^2}}$</p><p>其中，G(x, y)是高斯函数的值，x和y是平面上的坐标，σ是高斯函数的标准差。高斯函数的标准差决定了函数的形状和宽度，较大的标准差会导致更宽的函数曲线。</p><p>在图像处理中，高斯滤波器将高斯函数应用于图像的每个像素点，并以该像素点为中心计算一个加权平均值。这个加权平均值是通过对滤波器内的邻域像素进行加权平均来计算的，权重由高斯函数确定，距离中心像素越远的像素具有更小的权重。</p><p>通过对图像应用高斯滤波器，可以实现以下效果：</p><ol><li><p>平滑图像：高斯滤波器可以模糊图像，减少图像中的噪声和细节，从而得到一个平滑的版本。</p></li><li><p>去除噪声：由于高斯滤波器对噪声具有平滑作用，它可以在图像中降低噪声的影响，提高图像的质量。</p></li><li><p>缩小细节：较大的高斯滤波器会导致图像的细节被模糊，从而可以用于图像的降采样和特征提取。</p></li></ol><p>选择适当的高斯滤波器的标准差是很重要的，它决定了滤波器的模糊程度。较小的标准差对应于较细的模糊效果，较大的标准差对应于较强的模糊效果。通常根据应用的需求和图像的特点来选择合适的标准差。</p><details ><summary pointer> 示例 </summary>              <div class='content'>              <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_gaussian_blur</span>(<span class="params">image_path, kernel_size, sigma, output_path</span>):</span><br><span class="line">    <span class="comment"># 读取图像</span></span><br><span class="line">    image = cv2.imread(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将图像转换为灰度图</span></span><br><span class="line">    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用高斯滤波器</span></span><br><span class="line">    blurred_image = cv2.GaussianBlur(gray_image, kernel_size, sigma)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存滤波后的图像</span></span><br><span class="line">    cv2.imwrite(output_path, blurred_image)</span><br></pre></td></tr></table></figure><div class="gallery ">              <table><thead><tr><th></th><th>kernel_size</th><th>3</th><th>45</th></tr></thead><tbody><tr><td>sigma</td><td><img src="https://s1.imagehub.cc/images/2023/07/11/1_2023710.png" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/1_2023710.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原图" ></td><td></td><td></td></tr><tr><td>1.0</td><td></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=3&sigma=1.0" ></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=45&sigma=1.0" ></td></tr><tr><td>2.0</td><td></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3sigma2.0.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3sigma2.0.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=45&sigma=2.0" ></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45sigma2.0.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45sigma2.0.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=45&sigma=2.0" ></td></tr><tr><td>3.0</td><td></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3sigma3.0.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size3sigma3.0.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=45&sigma=3.0" ></td><td><img src="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45sigma3.0.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/11/blurred_image_kernel_size45sigma3.0.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="kernel_size=45&sigma=3.0" ></td></tr></tbody></table>            </div>              </div>            </details><blockquote><p>高斯函数（Gaussian function）是一种常见的数学函数，它以德国数学家卡尔·弗里德里希·高斯（Carl Friedrich Gauss）命名，具有以下的数学表达式：<br>$G(x) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \cdot e^{-\frac{x^2}{2\sigma^2}}$<br>其中，( G(x) ) 是高斯函数的值，( x ) 是自变量，( \sigma ) 是标准差（standard deviation）。<br>高斯函数的图像呈现出典型的钟形曲线形状，其峰值位于均值（mean）处，曲线两侧逐渐衰减。标准差决定了曲线的宽度，较大的标准差会使曲线更宽，较小的标准差会使曲线更尖锐。<br>高斯函数在许多领域中具有重要的应用，尤其在统计学和信号处理中。它具有许多优良的数学性质，例如：</p><ul><li>高斯函数是连续函数，定义域为负无穷到正无穷的实数集。</li><li>高斯函数在整个实轴上的积分为1，即满足归一性。</li><li>高斯函数是平移不变的，即对于任何常数 ( a )，当自变量 ( x ) 替换为 ( x-a ) 时，函数值保持不变。</li></ul><p>高斯函数在图像处理和模式识别中也经常被用作滤波器的基础，通过在空域或频域上应用高斯函数，可以实现图像平滑、噪声抑制和特征提取等操作。</p></blockquote><h3 id="找到局部极值点"><a href="#找到局部极值点" class="headerlink" title="找到局部极值点"></a>找到局部极值点</h3><h4 id="构建高斯差分金字塔"><a href="#构建高斯差分金字塔" class="headerlink" title="构建高斯差分金字塔"></a>构建高斯差分金字塔</h4><p>在尺度空间的每一层上，比较每个像素的值与其邻域像素的值，是一种常见的操作用于寻找局部极值点。极值点是指在一个局部邻域内，像素的值在该邻域中最大或最小。</p><p>具体步骤如下：</p><ol><li><p>对于尺度空间金字塔的每一层图像，遍历每个像素。</p></li><li><p>对于每个像素，将其与其相邻像素进行比较。通常采用3x3或5x5大小的邻域。</p></li><li><p>如果像素的值在邻域内是最大或最小的，那么它被认为是一个局部极值点。</p></li></ol><p>通过比较像素与其邻域像素的值，可以确定局部极值点，即在一个局部邻域内像素值最大或最小的点。这些极值点具有一定的稳定性和重要性，常用于计算机视觉中的特征提取和特征匹配任务。</p><p>在尺度不变特征变换（SIFT）算法中，这一步是尺度空间极值检测的关键步骤。通过在不同尺度上比较像素与邻域像素的值，可以找到具有尺度不变性的特征点，这些特征点对于图像匹配、目标识别等任务非常有用。</p><blockquote><p>DoG（Difference of Gaussians）是通过计算尺度空间金字塔中相邻层级之间的差分得到的一种图像增强技术。它可以用于边缘检测、纹理分析等计算机视觉任务。<br>DoG的定义公式为：<br>$$\text{DoG}(x, y, \sigma) &#x3D; G(x, y, k\sigma) - G(x, y, \sigma)$$<br>其中，$(x, y)$ 是图像中的像素坐标，$\sigma$ 是高斯滤波器的标准差，$k$ 是尺度因子（通常为较大的值，例如 $k &#x3D; 1.6$），$G(x, y, \sigma)$ 是高斯滤波器函数。<br>通过将不同尺度空间金字塔层级的高斯滤波结果相减，DoG可以突出图像中的边缘和纹理信息。边缘和纹理通常在不同尺度上具有不同的空间特征尺度，因此通过计算不同尺度层级之间的差分，可以增强这些特征并提取出来。<br>在实际应用中，DoG通常用于图像金字塔的构建和尺度空间极值点检测，是一种常用的特征提取方法之一。</p></blockquote><h4 id="精确定位极值点"><a href="#精确定位极值点" class="headerlink" title="精确定位极值点"></a>精确定位极值点</h4><p>使用泰勒级数展开的目的是为了精确定位尺度空间金字塔中的极值点，即找到极值点的精确位置和尺度。</p><p>在尺度空间金字塔中，极值点通常是通过比较每个像素的值与其邻域像素的值来找到的。然而，通过简单比较像素值可能只能得到粗略的位置估计，并不能精确定位极值点。</p><p>为了更精确地定位极值点，可以使用泰勒级数展开来近似极值点的位置和尺度。泰勒级数展开是一种将函数在某个点处进行多项式逼近的方法。</p><p>对于极值点的位置 $(x, y)$，我们可以使用二维泰勒级数展开来近似其精确位置：</p><p>$$f(x + \Delta x, y + \Delta y) \approx f(x, y) + \frac{\partial f}{\partial x}\Delta x + \frac{\partial f}{\partial y}\Delta y + \frac{1}{2}\left(\frac{\partial^2 f}{\partial x^2}\Delta x^2 + \frac{\partial^2 f}{\partial y^2}\Delta y^2\right)$$</p><p>其中，$\Delta x$ 和 $\Delta y$ 是相对于极值点位置 $(x, y)$ 的偏移量。通过对函数 $f(x, y)$ 进行一阶和二阶偏导数计算，我们可以获得这些导数值。通过求解泰勒级数展开的偏导数为零的方程组，可以解得 $\Delta x$ 和 $\Delta y$，从而得到更精确的极值点位置。</p><p>对于极值点的尺度，我们可以使用一维泰勒级数展开来近似其精确尺度：</p><p>$$f(x, y, \sigma + \Delta\sigma) \approx f(x, y, \sigma) + \frac{\partial f}{\partial \sigma}\Delta\sigma + \frac{1}{2}\frac{\partial^2 f}{\partial \sigma^2}\Delta\sigma^2$$</p><p>其中，$\Delta\sigma$ 是相对于极值点尺度 $\sigma$ 的偏移量。通过对函数 $f(x, y, \sigma)$ 进行一阶和二阶偏导数计算，我们可以获得这些导数值。通过求解泰勒级数展开的偏导数为零的方程，可以解得 $\Delta\sigma$，从而得到更精确的极值点尺度。</p><p>通过使用泰勒级数展开，我们可以对极值点的位置和尺度进行更精确的估计，从而实现对尺度空间金字塔中极值点的精确定位。</p><h3 id="阈值处理和边界消除"><a href="#阈值处理和边界消除" class="headerlink" title="阈值处理和边界消除"></a>阈值处理和边界消除</h3><p>阈值处理和边界消除是在找到尺度空间金字塔中的极值点后对这些极值点进行进一步处理的步骤。</p><p>阈值处理是通过设置一个阈值来筛选具有较大响应值的极值点。阈值可以根据任务需求进行设定，通常选择一个合适的响应值阈值，以保留具有足够显著特征的极值点，而剔除那些响应值较低的不太重要的极值点。</p><p>边界消除是为了消除在邻域内出现的重复极值点。在尺度空间金字塔中，由于不同尺度层级之间的重叠区域，可能存在邻域内的极值点重复出现的情况。为了保留唯一的极值点，需要应用边界消除技术，通常使用非极大值抑制（non-maximum suppression）来实现。</p><p>非极大值抑制是一种常用的边界消除方法，用于消除邻域内的重复极值点。对于每个局部极值点，非极大值抑制会比较其响应值与邻域内的其他点的响应值，并保留具有最大响应值的极值点，而抑制其他点。这样可以确保在同一局部区域内只保留一个最显著的极值点。</p><p>阈值处理和边界消除是在极值点检测后对极值点进行筛选和优化的重要步骤。它们可以帮助我们提取出具有足够显著特征的稳定极值点，用于后续的计算机视觉任务，如特征提取、特征匹配等。</p><h4 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h4><p>阈值处理是一种简单的图像处理操作，用于将图像中的像素值与设定的阈值进行比较，并根据比较结果对像素进行分类或处理。</p><p>以下是一种基本的阈值处理方法：</p><ol><li><p>确定阈值：首先需要确定阈值的数值，可以根据具体应用场景和需求进行设定。阈值可以是一个固定值，也可以根据图像的特性和统计信息进行自适应调整。</p></li><li><p>进行比较：将图像中的每个像素与阈值进行比较。通常，如果像素值大于阈值，则被归类为一类（例如，被认为是前景像素）；如果像素值小于阈值，则被归类为另一类（例如，被认为是背景像素）。</p></li><li><p>分类或处理：根据比较的结果，对图像像素进行分类或处理。可以根据实际需求将像素分为不同的类别，如二值图像（只有两个像素值，通常是0和255）、灰度图像（多个像素值，表示不同的灰度级别）或进行其他特定的处理操作，如目标检测、边缘提取等。</p></li></ol><p>在具体实现阈值处理时，可以使用图像处理库或工具来简化操作。例如，在Python中，可以使用OpenCV库的函数cv2.threshold()来实现阈值处理。该函数接受输入图像和设定的阈值，并返回处理后的图像。</p><p>阈值处理是图像处理中的基础操作，常用于图像分割、二值化、目标检测等应用中。根据具体的应用需求，可以根据不同的阈值处理方法和策略来实现所需的图像处理效果。</p><h4 id="消除边界响应"><a href="#消除边界响应" class="headerlink" title="消除边界响应"></a>消除边界响应</h4><p><strong>Hessian矩阵</strong></p><p>Hessian矩阵是一个二阶偏导数矩阵，用于描述多元函数的局部曲率和形状信息。它由函数的所有二阶偏导数构成的方阵。</p><p>对于一个具有多个自变量的函数，Hessian矩阵的元素表示该函数在不同自变量方向上的曲率。具体而言，Hessian矩阵的第 $(i, j)$ 元素表示函数关于第 $i$ 个自变量和第 $j$ 个自变量的二阶偏导数。</p><p>Hessian矩阵可以用来分析函数的驻点（即梯度为零的点）和极值点。根据Hessian矩阵的特征值和特征向量，可以判断一个驻点的类型，例如判断其是否为极大值、极小值或鞍点。具体而言，如果Hessian矩阵的所有特征值均为正，则该点为极小值；如果所有特征值均为负，则为极大值；如果特征值既有正又有负，则为鞍点。</p><p>在计算机视觉和图像处理领域，Hessian矩阵常用于特征检测和图像处理算法中。例如，在尺度不变特征变换（SIFT）算法中，通过计算图像中的Hessian矩阵的特征值和特征向量，可以检测出具有稳定尺度和方向的关键点。Hessian矩阵的分析可以帮助提取图像中的关键特征，并用于特征匹配和目标识别等任务。</p><p>$$<br>\text{Hessian}(f) &#x3D;<br>\begin{bmatrix}<br>\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp; \ldots &amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \<br>\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp; \ldots &amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp; \ldots &amp; \frac{\partial^2 f}{\partial x_n^2}<br>\end{bmatrix}<br>$$</p><p>其中，$\frac{\partial^2 f}{\partial x_i \partial x_j}$ 表示函数 $f$ 对第 $i$ 个自变量和第 $j$ 个自变量的二阶偏导数。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的树</title>
      <link href="/2023/07/10/%E6%88%91%E7%9A%84%E6%A0%91/"/>
      <url>/2023/07/10/%E6%88%91%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="我的树"><a href="#我的树" class="headerlink" title="我的树"></a>我的树</h1><p>在一个春日的清晨，我亲手种下了一颗八重樱树。这三个月的时光里，我目睹着山泉逐渐成长，一片片嫩绿的叶子在枝条上舒展开来。山泉以山泉的生命力和美丽，为这个季节注入了一份新的生机。</p><p>在那个春天的时刻，当我将那颗娇小的八重樱树插入土壤中时，我心中充满了期待和希望。随着春风的吹拂，山泉开始展示出山泉的成长之美。渐渐地，新叶在山泉的枝条上长出，迎接着温暖的阳光。这些嫩绿的叶子如同小小的温暖拥抱，为整个树冠增添了一抹生机。</p><p>这三个月的时光里，我注视着山泉的每一个细微的变化。每一片新叶的展开都仿佛是一次小小的奇迹，为这颗小树注入了更多的活力和魅力。我看着山泉的叶子渐渐成熟，变得更加浓绿，仿佛是大自然对我忍耐和耐心的回报。</p><p>这棵八重樱树在春天的怀抱中成长，山泉以山泉那婀娜多姿的枝条和嫩绿的叶子，向着阳光伸展着。山泉告诉我，生命的力量是如此的顽强和美好。即使在最初的时刻，山泉可能只是一颗小树，但山泉所散发出的生机和成长的韵律，已经在这片土地上留下了独特的足迹。</p><p>每一次我静静地站在山泉的旁边，感受着春风拂面，看着山泉的成长，我都感受到了希望和生命的力量。这颗八重樱树，山泉不仅仅是一棵树，更是一份美好和勇气的象征。</p><div class="timeline"><div class="timenode"><div class="meta"><p><p>2023-03-10</p></p></div><div class="body"><p>它叫做山泉。</p><img src="https://s1.imagehub.cc/images/2023/07/10/79cc2969d2443f727ca4edd8cc007d.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/79cc2969d2443f727ca4edd8cc007d.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-04-29</p></p></div><div class="body"><p>我盼着山泉能快快长大。</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8004.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8004.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-05-09</p></p></div><div class="body"><p>经过漫长的等待，终于看到了新叶。</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8085.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8085.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-05-14</p></p></div><div class="body"><p>经常在回宿舍的时候去看山泉。</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8122.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8122.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-05-23</p></p></div><div class="body"><p>经常在山泉旁边喝酒、聚餐</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8222.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8222.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-06-30</p></p></div><div class="body"><p>端午节回来之后，第一场雨。</p><p>我把我的红绳，挂在了山泉的身上</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8556.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8556.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-07-10</p></p></div><div class="body"><p>快放假了。</p><img src="https://s1.imagehub.cc/images/2023/07/10/IMG_8596.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/10/IMG_8596.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-09-01</p></p></div><div class="body"><p>它受伤了，我很着急</p><img src="https://s1.imagehub.cc/images/2023/09/01/IMG_9026.jpeg" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/09/01/IMG_9026.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="" width="300px"></div></div><div class="timenode"><div class="meta"><p><p>2023-??-??</p></p></div><div class="body"></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Pointless small talk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPT API使用教程</title>
      <link href="/2023/07/09/GPT-API%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2023/07/09/GPT-API%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GPT"><a href="#什么是GPT" class="headerlink" title="什么是GPT"></a>什么是GPT</h1><p>ChatGPT是OpenAI开发的一种基于语言模型的聊天代理工具。它建立在强大的GPT（Generative Pre-trained<br>Transformer）模型的基础上，可以对自然语言进行理解和生成。</p><p>GPT是一种基于Transformer架构的语言模型，通过大规模的预训练来学习语言的潜在模式和结构。在预训练阶段，模型使用了大量的公开可用的互联网文本数据，从而获得了丰富的语言知识。在预训练之后，通过微调和特定任务的训练，模型可以用于各种自然语言处理任务，包括对话生成。</p><p>ChatGPT是GPT模型在对话生成任务上的应用。它经过训练，使得模型能够理解和生成连贯的对话。您可以向ChatGPT提供一个对话历史或问题，并从模型中获得相应的回复。ChatGPT可以用于构建智能聊天机器人、客服代理、语言翻译等应用。</p><p>OpenAI通过对大规模数据集进行训练，使ChatGPT能够生成流畅、有逻辑的回复，并且具备一定的上下文理解能力。然而，它也可能存在生成不准确、含有偏见或不恰当回答的情况，因此在使用ChatGPT时需要注意对输出进行筛选和审查，以确保生成的回复符合期望和要求。</p><h2 id="GPT-3-5与GPT-4的区别"><a href="#GPT-3-5与GPT-4的区别" class="headerlink" title="GPT-3.5与GPT-4的区别"></a>GPT-3.5与GPT-4的区别</h2><p>我并没有实际的比较过GPT-3.5与GPT-4，但可以看到的是GPT-4新增了插件支持，支持联网，也就是GPT-4可以进行半自主学习，我在前一段时间就看到了GPT-4的一个插件，声称可以快速的帮你读论文，甚至你可以不给出论文，而是根据GPT-4联网的论文库中查找，你只需要给出名字即可。</p><p>网页版GPT-3.5是免费的，而GPT-4是收费的，月费率为$20。</p><p>另外，在API价格方面也有一定差别。这个可以看我前段时间发的tokens。</p><div class="tagLink"><a class="link-card" title="About-GPT-Token" href="/2023/07/07/About-GPT-Token/"><span class="link-card-backdrop" style="background-image: url(https://s1.imagehub.cc/images/2023/07/08/2023-07-08-20.32.05.png)"></span><div class="left"><img src="https://s1.imagehub.cc/images/2023/07/08/2023-07-08-20.32.05.png" class="lazyload placeholder" data-srcset="https://s1.imagehub.cc/images/2023/07/08/2023-07-08-20.32.05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">About-GPT-Token</p><p class="url">/2023/07/07/About-GPT-Token/</p></div></a></div><h2 id="模型使用方法与主观评价"><a href="#模型使用方法与主观评价" class="headerlink" title="模型使用方法与主观评价"></a>模型使用方法与主观评价</h2><p>OpenAI即今为止发布了非常多的模型，今天早些的时候我每个都去使用了一下，接下来就说一说我的主观感受与使用方法和体验。</p><p>详细的使用教程在OpenAI官网有讲。</p><div class="tagLink"><a class="link-card" title="API REFERENCE" href="https://platform.openai.com/docs/api-reference/introduction"><span class="link-card-backdrop" style="background-image: url(https://yt3.googleusercontent.com/UqT_vCkJIn1P2fH1pchr6lbe3xeEekY61h4bUpJkVuityqKOEtUYcNy3pLiJ5OKdj4uKA81FWE8=s176-c-k-c0x00ffffff-no-rj)"></span><div class="left"><img src="https://yt3.googleusercontent.com/UqT_vCkJIn1P2fH1pchr6lbe3xeEekY61h4bUpJkVuityqKOEtUYcNy3pLiJ5OKdj4uKA81FWE8=s176-c-k-c0x00ffffff-no-rj" class="lazyload placeholder" data-srcset="https://yt3.googleusercontent.com/UqT_vCkJIn1P2fH1pchr6lbe3xeEekY61h4bUpJkVuityqKOEtUYcNy3pLiJ5OKdj4uKA81FWE8=s176-c-k-c0x00ffffff-no-rj" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">API REFERENCE</p><p class="url">https://platform.openai.com/docs/api-reference/introduction</p></div></a></div><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>GPT是OpenAI发布的最为广为人知的模型，也是我个人认为最强大的模型。根据OpenAI官方网站的介绍，如果要使用GPT的API，最佳选择是使用Node.js和Python。我曾尝试过使用Node.js、Python、Java和Curl这几种方式，总的来说它们之间差别不大。</p><p>我通常最常使用的是<code>gpt-3.5-turbo</code>模型，不过听说这个模型将在年底下架，并被新一代的3.5模型所取代。对于这个消息，我并没有深入了解。</p><p>起初，我并不擅长进行多轮对话，感觉自己很可笑。但今天我学了一下，发现其实非常简单。</p><p>首先，让我们了解一下发送请求的组成部分（以Curl为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/chat/completions \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -d &#x27;&#123;</span><br><span class="line">     &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">     &quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Say this is a test!&quot;&#125;],</span><br><span class="line">     &quot;temperature&quot;: 0.7</span><br><span class="line">   &#125;&#x27;</span><br></pre></td></tr></table></figure><p>API接口为：<a href="https://api.openai.com/v1/chat/completions">https://api.openai.com/v1/chat/completions</a></p><p><code>-H</code>部分包含了两个头信息参数，分别是<code>Content-Type</code>和<code>Authorization</code>，用于指定请求体的类型和授权令牌。需要在官网申请获取OPENAI_API_KEY，并将其替换为实际的密钥。</p><p><code>-d</code>部分是请求体，根据前文中<code>Content-Type</code>为<code>application/json</code>，所以这部分需要符合JSON格式。</p><p>其中，<code>model</code>指定了要使用的模型，<code>messages</code>是对话内容，每个消息包含一个<code>role</code>角色和<code>content</code>内容，用户默认角色为<code>user</code><br>。这两个参数是必需的。</p><p>响应示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatcmpl-abc123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chat.completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1677858242</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-3.5-turbo-0301&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\n\nThis is a test!&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最重要的部分是<code>choices</code>中的<code>message</code>内容，其中<code>role</code>为assistant，表示这是AI助手的回复，<code>content</code>则是AI助手的回复内容。</p><p>以上是基本的请求和响应内容。实现多轮对话也非常简单，只需将前面的对话内容全部传回即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/chat/completions \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -d &#x27;&#123;</span><br><span class="line">      &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">      &quot;messages&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;system&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;You are a helpful assistant.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;What is 1+1?&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;1+1 equals 2.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;And if we add 3?&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;1 + 1 + 3 = 5. So, 1+1 plus 3 equals 5.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;What if we multiply it by 5?&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;&#x27;</span><br></pre></td></tr></table></figure><p>可以看到，这里出现了多个<code>assistant</code>和<code>user</code>，还有一个<code>system</code>角色。个人而言，我将<code>user</code>视为自己，而其他角色都是AI助手。这段对话可以看作是多轮对话的示例。</p><p>通过以上方法，我们已经学会了最基本的多轮对话请求方式。</p><h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><p>GPT-3.5模型是OpenAI发布的一款强大的自然语言处理模型，它具有以下几个方面的优点：</p><ol><li><p><strong>语言生成能力强大</strong>：GPT-3.5模型在语言生成任务上表现出色，能够生成流畅、准确、连贯的文本。它能够根据上下文理解用户的意图并生成相关回复，具备一定的语义理解和逻辑推理能力。</p></li><li><p><strong>多领域适用</strong>：GPT-3.5模型在多个领域都有应用潜力，可以用于编写文章、回答问题、提供建议、创作故事等。无论是技术领域、商业应用还是创意创作，该模型都可以提供有用的信息和帮助。</p></li><li><p><strong>灵活的对话交互</strong>：GPT-3.5模型支持多轮对话，可以进行复杂的对话交互。它能够记住先前的对话历史并根据上下文进行回复，使得对话更加连贯和一致。</p></li><li><p><strong>可定制性强</strong>：GPT-3.5模型允许用户根据实际需求进行定制，可以通过指定不同的角色、添加系统级指示等方式来控制模型的行为。这种灵活性使得模型可以根据特定的应用场景进行定制化的使用。</p></li></ol><p>尽管GPT-3.5模型具有许多优点，但也存在一些考虑因素：</p><ol><li><p><strong>模型训练成本高</strong>：由于GPT-3.5模型的复杂性，其训练和部署成本相对较高，可能对某些个人开发者或小型团队而言不太可承受。</p></li><li><p><strong>对大量数据的依赖</strong>：GPT-3.5模型的性能与其所训练的大规模数据集密切相关。在某些领域或特定任务上，模型可能需要更多的领域专业知识或数据来取得最佳效果。</p></li><li><p><strong>缺乏常识和实际知识</strong>：尽管GPT-3.5模型在生成文本方面表现出色，但它并没有实际的常识和背景知识。在处理需要具备实际知识或复杂推理的任务时，模型可能会出现一些不准确或不合理的回复。</p></li></ol><blockquote><p>当然这是ChatGPT自己对自己的评价。</p></blockquote><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>OpenAI推出的Image模型还是满垃圾的，也不知道是我自己的问题还是什么。</p><blockquote><p>这个Image图像生成模型并不是DALL·E模型</p></blockquote><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/images/generations \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -d &#x27;&#123;</span><br><span class="line">    &quot;prompt&quot;: &quot;A cute baby sea otter&quot;,</span><br><span class="line">    &quot;n&quot;: 2,</span><br><span class="line">    &quot;size&quot;: &quot;1024x1024&quot;</span><br><span class="line">  &#125;&#x27;</span><br></pre></td></tr></table></figure><p><code>prompt</code>是提示词，使用过<a href="https://www.midjourney.com/">midjourney</a>或者其他的图像生成模型应该满熟悉了，如何使用我不多说了</p><p><code>n</code>生成图像的数量</p><p><code>size</code>生成图像的大小，现在可选为<code>256x256</code>, <code>512x512</code>, <code>1024x1024</code></p><h4 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h4><p>并不推荐使用，这里推荐midjourney、DALL·E、Diffusion Model这三个应该是主流的了</p><p>以至于后来的图像编辑、图像变化的api我都不想多说了，这里就给出使用方法示例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/images/edits \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -F image=&quot;@otter.png&quot; \</span><br><span class="line">  -F mask=&quot;@mask.png&quot; \</span><br><span class="line">  -F prompt=&quot;A cute baby sea otter wearing a beret&quot; \</span><br><span class="line">  -F n=2 \</span><br><span class="line">  -F size=&quot;1024x1024&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/images/variations \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -F image=&quot;@otter.png&quot; \</span><br><span class="line">  -F n=2 \</span><br><span class="line">  -F size=&quot;1024x1024&quot;</span><br></pre></td></tr></table></figure><p>使用方法在官方文档中有详细参数</p><h3 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h3><p>语音转文字这个模型我觉得还是蛮使用的</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/audio/transcriptions \</span><br><span class="line">  -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \</span><br><span class="line">  -H &quot;Content-Type: multipart/form-data&quot; \</span><br><span class="line">  -F file=&quot;@/path/to/file/audio.mp3&quot; \</span><br><span class="line">  -F model=&quot;whisper-1&quot;</span><br></pre></td></tr></table></figure><p><code>-F</code>代表使用form-data，这就对应了上文中<code>Content-Type: multipart/form-data</code></p><p><code>file</code>需要上传的音频文件，支持的格式有<code>mp3</code>, <code>mp4</code>, <code>mpeg</code>, <code>mpga</code>, <code>m4a</code>, <code>wav</code>, <code>webm</code></p><p><code>model</code>使用的模型，目前，用于音频的模型仅有<code>whisper-1</code></p><h4 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h4><p>个人使用的次数不多，但总体感受是，蛮好用的。</p><h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><p>关于OpenAI的论文，官网已经发表了连接<a href="https://openai.com/research">在这里</a></p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>目前我还并没有去研究微调模型，不过在今后说不定会感兴趣。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末复习-习近平思想和中国特色社会主义理论体系概论</title>
      <link href="/2023/07/08/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA/"/>
      <url>/2023/07/08/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="习近平思想和中国特色社会主义理论体系概论"><a href="#习近平思想和中国特色社会主义理论体系概论" class="headerlink" title="习近平思想和中国特色社会主义理论体系概论"></a>习近平思想和中国特色社会主义理论体系概论</h1><h2 id="单项选择"><a href="#单项选择" class="headerlink" title="单项选择"></a>单项选择</h2><ol><li>经过长期努力，中国特色社会主义进入新时代，这是我国发展新的<code>历史方位</code></li><li><code>人民至上</code>是贯彻习近平新时代中国特色社会主义思想的一根红线。</li><li>坚持和发展中国特色社会主义，总任务是<code>实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国</code>。</li><li>中国特色社会主义的战略布局是<code>“四个全面”</code>。</li><li>世界未有之大变局正在加速演变。<code>和平与发展</code>仍然是时代主题，但是不稳定不确定性更加突出。</li><li>实现中国梦必须凝聚中国力量，这就是<code>各族人民大团结的力量</code>。</li><li>实现中国梦必须弘扬中国精神，这就是<code>以爱国主义为核心的民族精神和以改革创新为核心的时代精神</code>。</li><li>实现中国梦必须走中国道路。中国道路是指<code>中国特色社会主义道路</code>。</li><li>全面建设社会主义现代化国家进程中的第一个阶段，从2020年到2035年，<code>基本实现社会主义现代化</code>。</li><li>中国特色社会主义的总体布局是<code>“五位一体”</code>。</li><li><code>中国特色社会主义文化</code>是中华民族的根和魂，是中国特色社会主义植根的文化沃土。</li><li>党的十八大以来，我们党的全部理论和实践探索都是围绕<code>坚持和发展中国特色社会主义</code>这个主题来展开、深化和拓展的。</li><li>进入新时代，我国社会主要矛盾已经转化为<code>人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</code>。</li><li>中国特色社会主义最本质的特征是<code>中国共产党领导</code>。</li><li>中国梦归根到底是<code>人民的梦</code>，必须紧紧依靠人民来实现，必须不断为人民造福。</li><li>改革开放之后，我们党提出的“三步走”战略的第三步，即基本实现现代化，将提前<code>15年</code>完成。</li><li>中国共产党的性质决定了党的宗旨是<code>全心全意为人民服务</code>。</li><li>中国共产党作为马克思主义政党，其最大的政治优势是<code>密切联系群众</code>。</li><li><code>实现中华民族伟大复兴</code>是党百年奋斗的主题。</li><li>中国梦的本质是<code>国家富强、民族振兴、人民幸福</code>。</li><li><code>群众路线</code>始终是党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝。</li><li>马克思主义政党站在人民立场上，始终将最广大人民群众的根本利益作为自己的<code>最高利益</code>。</li><li>党自成立之日起，就把“人民”二字铭刻在心，把坚持<code>人民利益</code>高于一切鲜明地写在自己的旗帜上。</li><li><code>人的全面发展</code>是中国特色社会主义的价值目标。</li><li><code>共同富裕</code>是社会主义的本质要求，是中国式现代化的重要特征。</li><li>党的十九届六中全会进一步明确，必须坚持<code>以人民为中心</code>的发展思想，发展全过程人民民主，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展。</li><li>我们乘势而上开启全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军，这标志着我国进入了一个<code>新发展阶段</code>。</li><li>我国经济已由高速增长阶段转向<code>高质量发展阶段</code>，正处在转变发展方式、优化经济结构、转换增长动力的攻关期。</li><li>经济进入新常态后，伴随着经济增长速度的下降，推动<code>供给侧改革</code>成为经济生活中的主旋律。</li><li><code>新发展格局</code>是根据我国发展阶段、环境、条件变化提出来的，是重塑我国国际合作和竞争新优势的战略抉择，是把握未来发展主动权的战略性布局和先手棋。</li><li>经济改革的方向是要让<code>市场</code>在资源配置中发挥决定性作用。</li><li>国有企业是中国特色社会主义的重要物质基础和政治基础，关系<code>公有制主体</code>地位的巩固，关系我们党的执政地位和执政能力，关系我国社会主义制度。</li><li>建设充分发挥<code>市场作用</code>，更好发挥政府作用的经济体制。</li><li>党的十九大提出，到<code>2035年</code>“各方面制度更加完善，国家治理体系和治理能力现代化基本实现”。</li><li>中国特色社会主义制度和国家治理体系是以<code>马克思主义</code>为指导、植根中国大地、具有深厚中华文化根基、深得人民拥护的制度和治理体系。</li><li>坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，不仅要建立完善的制度体系，还要在不断<code>提高制度执行力和治理能力</code>上狠下功夫。</li><li><code>党的十八届三中全会</code>作出了全面深化改革的决定。</li><li>党的十九届四中全会，对坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化作出总体擘画。以下表述不正确的是<code>本世纪中叶，全面建成符合社会主义现代化发展的国家治理体系</code>。</li><li>推进改革的目的是要不断推进我国社会主义制度<code>自我完善和发展</code>，赋予社会主义新的生机活力。</li><li><code>引进来和走出去</code>是“一带一路”国际合作的重要内容，如同车之两轮、鸟之两翼。国家富强、民族振兴、人民幸福。</li><li><code>自力更生</code>是中华民族自立于世界民族之林的奋斗基点，自主创新是我们攀登世界科技高峰的必由之路。</li><li><code>中国共产党领导</code>是中国特色科技创新事业不断前进的根本政治保证。</li><li>办好人民满意的教育必须深化教育领域综合改革、必须促进教育公平、必须<code>建设高质量教育体系</code>、必须加强教师队伍建设。</li><li>党的十八大以来，在以习近平同志为核心的党中央的坚强领导下，我国把<code>科技自立自强</code>作为国家发展的战略支撑，持续深入实施创新驱动发展战略，大力建设创新型国家和科技强国，我国已成功进入创新型国家行列。</li><li>全球科技革命发展的主要特征是从<code>科学</code>到<code>技术</code>转化，基本要求是重大基础研究成果产业化。</li><li>必须坚持科技是第一生产力、<code>人才</code>是第一资源、创新是第一动力，深入实施科教兴国战略、人才强国战略、创新驱动发展战略，开辟发展新领域新赛道，不断塑造发展新动能新优势。</li><li><code>人民民主</code>是社会主义的生命，没有民主就没有社会主义，就没有社会主义的现代化，就没有中华民族伟大复兴。</li><li><code>中国共产党的领导</code>是中国发展全过程人民民主的根本保证。</li><li>全过程人民民主首次提出是在<code>2019年11月</code>。</li><li>社会主义民主的实质是<code>人民当家作主</code>。</li><li><code>民主</code>是统治阶级用来实现其阶级利益的政治形式和手段。</li><li>中华民族要实现伟大复兴中国梦，不仅要创造高度的物质文明、精神文明、社会文明、生态文明，而且要建设高度的<code>政治文明</code>。</li><li>国家治理高效在于，始终把<code>中国人民</code>利益放在第一位。</li><li><code>程序民主</code>是指民主的制度安排，实质民主是指民主始终追求的价值目标，二者有机结合。</li><li>完善行政组织和行政程序法律制度，推进<code>机构、职能、权限、程序、责任</code>法定化。</li><li>办好法学教育，必须坚持走中国特色社会主义法治道路，坚持以<code>马克思主义</code>法学思想和中国特色社会主义法治理论为指导。</li><li><code>中国特色社会主义法治体系</code>是推进全面依法治国的总抓手。</li><li><code>宪法</code>是国家根本法，是党和人民意志的集中体现，是国家各种制度和法律法规的总依据。</li><li>我们讲坚持依宪治国、依宪执政，就包括坚持宪法确定的<code>中国共产党领导</code>地位不动摇。</li><li><code>党内法规</code>既是全面从严治党的重要依据，也是全面依法治国的有力保障。</li><li><code>文化自信</code>是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中最基本、最深沉、最持久的力量。</li><li>以下不是反映中华优秀传统文化中蕴含着丰富的国家安全战略思想的是<code>“美人之美，美美与共”</code>。</li><li>每年<code>4月15日</code>被确定为全民国家安全教育日。</li><li>基层治理是国家治理的基石，统筹推进乡镇（街道）和城乡社区治理，是实现<code>国家治理体系和治理能力现代化</code>的基础工程。</li><li>要树立尊重自然、顺应自然、保护自然的生态文明理念，增强<code>绿水青山就是金山银山</code>的意识。</li><li><code>生态系统</code>是一个系统整体，山水林田湖草沙构成相依共存、有机关联的生命共同体。这个生命共同体的生生循环、绵延不息葆有着人类生存发展的物质根基。</li><li><code>政治安全</code>攸关党和国家生死存亡，是国家安全的根本。</li><li><code>就业</code>是最大的民生工程、民心工程、根基工程，是社会稳定的重要保障。</li><li>习近平“两山论”的突出贡献是<code>马克思主义生产力观的新成果</code>。</li><li>关于繁荣发展文化事业和文化产业，以下说法错误的是<code>坚持以市场效益为核心的创作导向，推出更多受市场欢迎的优秀作品</code>。</li><li>从意识形态领域看，<code>互联网</code>已经成为舆论斗争的主战场，直接关系我国意识形态安全和政权安全。</li><li>党的二十大报告强调，坚持以<code>人民</code>为中心的创作导向，推出更多增强人民精神力量的优秀作品，培育造就大批德艺双馨的文学艺术家和规模宏大的文化文艺人才队伍。</li><li><code>民生在勤，勤则不匮</code>是民生概念在中国历史上的最早表述。</li><li>如期实现建军一百年奋斗目标，加快把人民军队建成世界一流军队，必须贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持政治建军、改革强军、<code>科技强军</code>、人才强军、依法治军。</li><li>推动形成<code>绿色生产方式和生活方式</code>是贯彻新发展理念的必然要求，必须把生态文明建设摆在全局工作的突出地位。</li><li>人因自然而生，人与自然是一种<code>共生关系</code>。生态环境没有替代品，用之不觉，失之难存。如果竭泽而渔，最后必然是什么鱼也没有了。</li><li>党的二十大报告中强调，坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、<code>租购并举</code>的住房制度。</li><li>我们经过接续奋斗，实现了小康这个中华民族的千年梦想，打赢了人类历史上规模最大的脱贫攻坚战，全国832个贫困县全部摘帽，近<code>一亿</code>农村贫困人口实现脱贫，960多万贫困人口实现易地搬迁。</li><li>一个政权的瓦解往往是从<code>思想</code>领域开始的，这一防线被攻破了，其他防线就很难守住。</li><li>发展和安全，是一个国家、一个民族生存与进步必须处理好的首要问题。发展解决的是<code>动力问题</code>，是推动国家和民族赓续绵延的根本支撑，安全解决的是<code>保障问题</code>，是确保国家和民族行稳致远的坚强柱石，发展和安全是一体之两翼、驱动之双轮。</li><li>党对军队的<code>绝对领导</code>是中国特色社会主义的本质特征，是党和国家的重要政治优势，是人民军队的建军之本、强军之魂。</li><li>强国必须强军，军强才能国安。在全面建设社会主义现代化国家、实现第二个百年奋斗目标的历史进程中，必须把<code>国防和军队建设</code>摆在更加重要的位置。</li><li>适应国家发展战略和安全战略新要求，与时俱进创新军事战略指导，调整优化军事战略布局，完善新时代军事战略体系，不断赋予<code>积极防御</code>战略思想新的内涵。</li><li>新时代全军必须夯实<code>依法治军</code>、从严治军这个强军之基，持之以恒推进作风建设和反腐败斗争，自觉践行人民军队根本宗旨，保持人民军队长期形成的良好形象。</li><li>军队是要打仗的，要牢固树立<code>战斗力</code>这个唯一的根本的标准，坚持把这个标准贯彻到全军各项建设和工作之中。</li><li>“一国两制”构想最早是针对<code>台湾</code>问题提出来的。</li><li>2022年7月1日，习近平总书记在庆祝香港回归祖国25周年大会暨香港特别行政区第六届政府就职典礼上的重要讲话中指出：”‘一国两制’是前无古人的伟大创举。’一国两制’的根本宗旨是<code>维护国家主权、安全、发展利益，保持香港、澳门长期繁荣稳定</code>。”</li><li>中国始终坚持<code>维护世界和平、促进共同发展</code>的外交政策宗旨，致力于推动构建人类命运共同体。</li><li>经过持续努力，中国特色大国外交全面推进，<code>构建人类命运共同体</code>成为引领时代潮流和人类前进方向的鲜明旗帜。</li><li>中国坚定奉行<code>独立自主</code>的和平外交政策，始终根据事情本身的是非曲直决定自己的立场和政策。</li><li>中国坚持对外开放的基本国策，坚定奉行<code>互利共赢</code>的开放战略，不断以中国新发展为世界提供新机遇，推动建设开放型世界经济，更好惠及各国人民。</li><li>中国坚持在<code>和平共处五项原则</code>基础上同各国发展友好合作，推动构建新型国际关系，深化拓展平等、开放、合作的全球伙伴关系，致力于扩大同各国利益的汇合点。</li><li>十年来，我们提出<code>新时代解决台湾问题的总体方略</code>，促进两岸交流合作，坚决反对”台独”分裂行径，坚决反对外部势力干涉，牢牢把握两岸关系主导权和主动权。</li><li>党的二十大报告指出，经过不懈努力，党找到了<code>自我革命</code>这一跳出治乱兴衰历史周期率的第二个答案。</li><li>习近平总书记在中国共产党第十九次全国代表大会上的报告中强调，坚持和<code>加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设</code>为主线。</li><li>把<code>政治建设</code>摆在首位，抓住了全面从严治党的根本性问题。</li><li>用党的创新理论武装全党是党的<code>思想建设</code>根本任务。</li><li>党的<code>作风</code>就是党的形象，关系人心向背，关系党的生死存亡。</li><li>我们要践行<code>共商共建共享</code>全球治理观，弘扬全人类共同价值，倡导不同文明交流互鉴。</li></ol><h2 id="多项选择"><a href="#多项选择" class="headerlink" title="多项选择"></a>多项选择</h2><p>实现“两个结合”是我们推进马克思主义中国化时代化的根本途径，具体是指____。<br>坚持马克思主义基本原理同中国具体实际相结合<br>坚持马克思主义基本原理同中华优秀传统文化相结合</p><p>习近平新时代中国特色社会主义思想回答的重大时代课题包括____。<br>新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义<br>建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国<br>建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党</p><p>以下属于习近平新时代中国特色社会主义思想的世界观和方法论的是____。<br>坚持人民至上<br>坚持自信自立<br>坚持守正创新</p><p>实现中华民族伟大复兴进入了不可逆转的历史进程，我国发展的战略性有利条件包括<br>____。<br>中国共产党的坚强领导<br>中国特色社会主义制度的显著优势<br>持续快速发展积累的坚实基础<br>长期稳定的社会环境和自信自强的精神力量</p><p>中国式现代化是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。中国式现代化是____。<br>人口规模巨大的现代化<br>全体人民共同富裕的现代化<br>走和平发展道路姿和的现代化</p><p>“五个必由之路”是多年来我国党和人民在历史实践历程中得到的宝贵答案，揭示了新时代坚持和发展中国特色社会主义的规律性认识，具体包括____。<br>坚持党的全面领导和中国特色社会主义<br>贯彻新发展理念<br>坚持全面从严治党。</p><p>党的十八届六中全会正式确立习近平总书记党中央的核心、全党的核心地位，要求全党必须牢固树立“四个意识”。“四个意识”是指____。<br>政治意识<br>大局意识<br>核心意识<br>看齐意识</p><p>中国共产党是中国特色社会主义事业的开创者、推动者、引领者，团结带领人民____。<br>开辟了中国特色社会主义道路<br>创立了中国特色社会主义理论<br>创建了中国特色社会主义制度<br>发展了中国特色社会主义文化</p><p>中国梦的本质是____。<br>国家富强<br>民族振兴<br>人民幸福</p><p>坚定中国特色社会主义“四个自信”，具体包括____。<br>道路自信<br>理论自信<br>制度自信<br>文化自信</p><p>以人民为中心的发展思想，不是高高在上的宣传口号，绝对不能只停留在口头上，要全方位贯穿于经济社会发展的各个环节，体现在人民群众____的扎实提升上。<br>获得感<br>幸福感<br>安全感</p><p>不忘初心、牢记使命，说到底是为什么人、靠什么人的问题。以百姓心为心，与人民____，是党的初心，也是党的恒心。<br>同呼吸<br>共命运<br>心连心</p><p>____与____相统一，既是马克思主义的价值追求，也是社会主义的本质要求，更是中国共产党人的奋斗目标。<br>促进人的全面发展<br>促进共同富裕</p><p>我国经济发展处于____阶段，我国发展进入新常态。<br>增长速度换挡期<br>结构调整阵痛期<br>前期刺激政策消化期</p><p>要推进供给侧结构性改革作为经济发展的主线，坚持____方针<br>巩固<br>增强<br>提升<br>畅通</p><p>进入____、贯彻____、构建____，是由我国经济社会发展的理论逻辑、历史逻辑、现实逻辑决定的，三者紧密关联。<br>新发展阶段<br>新发展理念<br>新发展格局</p><p>治理能力是运用国家制度管理国家各方面事务的能力，它包括____等各个方面各个领域的治理能力。<br>改革发展稳定<br>内政外交国防<br>治党治国治军</p><p>全面深化改革必须坚持和完善____。<br>中国特色社会主义制度<br>国家治理体系</p><p>五四运动以来，我国发生的三大历史性事件____，是近代以来实现中华民族伟大复兴的三大里程碑。<br>建立中国共产党<br>成立中华人民共和国<br>推进改革开放和中国特色社会主义事业</p><p>全面深化改革的总目标是____。<br>完善和发展中国特色社会主义制度<br>推进国家治理体系和治理能力现代化</p><p>我们必须站在战略高度上看问题，真正把教育摆在先行官的位置，努力实现____相互支持、相互促进的良性循环。<br>教育<br>科技<br>经济</p><p>教育强国、科技强国和人才强国是新时代科教兴国战略的总体部署，目的是____<br>办好人民满意的教育<br>完善科技创新体系<br>创新驱动发展<br>优化高素质人才培养</p><p>要把重要领域的科技创新摆在更加突出的地位，以____为突破口，加强对关系根本和全局的科学问题的研究部署，在战略必争领域打破重大关键核心技术受制于人的局面，加快构筑支撑高端引领的先发优势。坚持人民至上<br>关键共性技术<br>前沿引领技术<br>现代工程技术<br>颠覆性技术创新</p><p>人民既是民主的____，也是民主的____，智慧力量充分激发，既为自己也为国家、民族拼搏奋斗。<br>参与者<br>受益者</p><p>在人民民主的共同旗帜下，中国共产党与各民主党派____。<br>长期共存<br>互相监督<br>肝胆相照<br>荣辱与共</p><p>要坚持和完善人民当家作主制度体系，不断推进社会主义民主政治____，更好把制度优势转化为治理效能。<br>制度化<br>规范化<br>程序化</p><p>走中国特色社会主义政治发展道路，必须坚持____有机统一。<br>党的领导<br>人民当家作主，依法治国</p><p>准确把握全面推进依法治国重点任务，着力推进____。<br>科学立法<br>严格执法<br>公正司法<br>全民守法</p><p>坚持以宪法为最高法律规范，完善以宪法为核心的中国特色社会主义法律体系，加强____立法，把国家各项事业和各项工作纳入法制轨道。<br>重点领域<br>新兴领域<br>涉外领域</p><p>全面推进依法治国，必须大力提高法治工作队伍思想政治素质、业务工作能力、职业道德水准，着力建设一支____的社会主义法治工作队伍。<br>忠于党<br>忠于国家<br>忠于人民<br>忠于法律</p><p>伟大抗疫精神包括____。<br>生命至上<br>举国同心<br>舍生忘死<br>尊重科学<br>命运与共</p><p>加强和创新社会治理，改进社会治理方式，要坚持____。<br>系统治理<br>综合治理<br>依法治理<br>源头治理</p><p>中国特色社会主义文化的根本所在、深厚基础、不竭源泉分别是____。<br>马克思主义指导下形成的革命文化和社会主义先进文化<br>中华优秀传统文化<br>中国特色社会主义伟大实践</p><p>社会主义核心价值观涉及国家、社会、公民三个层面的价值要求，具体表达为____<br>富强、民主、文明、和谐<br>爱国、敬业、诚信、友善<br>自由、平等、公正、法治</p><p>共同富裕是全体人民共同富裕，是人民群众____都富裕。<br>物质生活<br>精神生活</p><p>做好意识形态工作事关____，任何时候任何情况下，我们都不能忽视思想的力量、忽视意识形态的作用。<br>党的前途命运<br>国家长治久安<br>民族凝聚力和向心力</p><p>讲好中国故事，要着重讲好____，展示文明大国、东方大国、负责任大国、社会主义大国形象，让当代中国形象在世界上不断树立和闪亮起来。<br>中国的故事<br>中国共产党的故事<br>中国特色社会主义的故事<br>中国人民的故事</p><p>新时代维护国家安全的实践要求____。<br>加强国家安全体系和能力建设<br>提高防范化解重大风险能力</p><p>增强意识形态领域主导权和话语权，就要坚定广大干部群众的____。<br>道路自信<br>理论自信<br>制度自信<br>文化自信</p><p>推动经济社会发展绿色化、低碳化是实现高质量发展的关键环节。为此，我们要积极推动____的绿色转型，打造国家重大战略绿色发展高地。<br>产业结构<br>能源结构<br>交通运输结构<br>消费方式</p><p>推动构建新型国际关系，就是要秉持____，摒弃传统的以强凌弱的丛林法则，走出一条对话而不对抗、结伴而不结盟的国与国交往新路。<br>合作共赢<br>相互尊重<br>公平正义</p><p>近年来，保护主义、单边主义抬头，逆全球化思潮发酵，发展空间不平衡成为全球治理面临的突出问题，世界正面临着____几大赤字。<br>发展<br>信任<br>和平<br>治理</p><p>____是全人类的共同价值，也是联合国的崇高目标。目标远未完成，我们仍须努力。<br>公平、正义<br>和平、发展<br>民主、自由</p><p>当今世界正经历百年未有之大变局，这样的大变局不是一时一事、一域一国之变，是____。<br>世界之变<br>历史之变<br>时代之变</p><p>积极发展全球伙伴关系，扩大同各国的利益汇合点，不断完善我国____的外交布局，打造覆盖全球的”朋友圈”。<br>多层次<br>全方位<br>立体化</p><p>构建人类命运共同体思想的内涵是：建设持久和平、____的世界。<br>普遍安全<br>开放包容<br>共同繁荣<br>清洁美丽</p><p>一个国家的安全不能建立在别国的动荡之上，各方应该树立____的安全观，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。<br>共同<br>可持续<br>合作<br>综合</p><p>全军必须坚决落实党中央、中央军委和习近平主席决策部署，强化____，做到全部精力向打仗聚焦，全部工作向打仗用劲，完成党和人民赋予的新时代使命任务。<br>危机意识<br>忧患意识<br>打仗意识</p><p>着力抓好军队党的政治建设，严肃政治纪律和政治规矩，确保部队____，确保枪杆子永远听党指挥。<br>绝对纯洁<br>绝对可靠<br>绝对忠诚</p><p>《中共中央关于党的百年奋斗重大成就和历史经验的决议》中明确党在新时代的强军目标是建设一支____的人民军队，把人民军队建设成为世界一流军队。<br>能打胜仗<br>听党指挥<br>作风优良</p><p>在重塑人民军队组织形态方面，按照”____”原则，强化军委集中统一领导和战略指挥、战略管理功能，打破长期实行的总部体制、大军区体制、大陆军体制，构建新的军队领导管理和作战指挥体制。<br>战区主战<br>军种主建<br>军委管总</p><p>党提出新时代人民军队使命任务，创新军事战略指导，调整优化军事战略布局，强化人民军队____的战略功能。<br>遏制战争<br>打赢战争<br>塑造态势<br>管控危机</p><p>全面加强练兵备战，提高人民军队打赢能力，要深入推进实战化军事训练，深化____。<br>科技练兵<br>对抗训练<br>联合训练</p><p>两岸同胞血脉相连，是血浓于水的一家人。我们始终尊重、关爱、造福台湾同胞，继续致力于____。<br>促进两岸经济文化交流合作，<br>深化两岸各领域融合发展，<br>完善增进台湾同胞福祉的制度和政策，<br>推动两岸共同弘扬中华文化，促进两岸同胞心灵契合。</p><p>支持香港、澳门发展经济、改善民生、破解经济社会发展中的深层次矛盾和问题。发挥香港、澳门优势和特点，<br>巩固提升香港、澳门在国际金融、贸易、航运航空、创新科技、文化旅游等领域的地位<br>深化香港、澳门同各国各地区更加开放、更加密切的交往合作<br>推进粤港澳大湾区建设<br>支持香港、澳门更好融入国家发展大局，为实现中华民族伟大复兴更好发挥作用</p><p>在确保国家____的前提下，和平统一后，台湾同胞的社会制度和生活方式等将得到充分尊重，台湾同胞的私人财产、宗教信仰、合法权益将得到充分保障。<br>发展利益<br>主权<br>安全</p><p>百年来，中国共产党____从最初50多名党员发展到今天拥有9600多万名党员的世界上最大的马克思主义执政党，历经千锤百炼而朝气蓬勃，正带领中国人民以不可阻挡的步伐迈向伟大复兴。<br>坚持性质宗旨<br>坚持理想信念<br>坚守初心使命<br>勇于自我革命</p><p>全面加强党的思想建设，坚持用习近平新时代中国特色社会主义思想____，组织实施党的创新理论学习教育计划，建设马克思主义学习型政党。<br>统一思想<br>统一意志<br>统一行动</p><p>新时代党的组织路线,全面贯彻新时代中国特色社会主义思想，____为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。<br>以组织体系建设为重点<br>着力培养忠诚干净担当的高素质干部<br>着力集聚爱国奉献的各方面优秀人才<br>坚持德才兼备、以德为先、任人唯贤</p><p>突出工作重点，抓紧建立和完善主干性、支撑性党内法规制度，健全相关配套法规制度，统筹推进立改废释工作，形成____的党内法规制度体系。以改革创新精神解决突出问题、补齐法规制度短板，提高党内法规制度质量。<br>内容科学<br>程序严密<br>配套完备<br>运行有效</p><h2 id="主观题"><a href="#主观题" class="headerlink" title="主观题"></a>主观题</h2><h3 id="人类命运共同体的内涵？"><a href="#人类命运共同体的内涵？" class="headerlink" title="人类命运共同体的内涵？"></a>人类命运共同体的内涵？</h3><ol><li>坚持对话协商，推动建设一个持久和平的世界;</li><li>坚持共建共享，推动建设一个普遍安全的世界;</li><li>坚持合作共赢，推动建设一个共同繁荣的世界;</li><li>坚持交流互鉴，推动建设一个开放包容的世界;</li><li>坚特绿色低碳，推动建设一个清洁美丽的世界。</li></ol><h3 id="中国特色社会主义进入新时代的历史意义是什么？"><a href="#中国特色社会主义进入新时代的历史意义是什么？" class="headerlink" title="中国特色社会主义进入新时代的历史意义是什么？"></a>中国特色社会主义进入新时代的历史意义是什么？</h3><ol><li>意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景;</li><li>意味着科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界上高高类起了中国特色社会主义伟大旗帜;</li><li>意味着中国特色社会主义道路、理论、制度。文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。</li></ol><h3 id="习近平新时代中国特色社会主义思想回答了什么重大时代课题？"><a href="#习近平新时代中国特色社会主义思想回答了什么重大时代课题？" class="headerlink" title="习近平新时代中国特色社会主义思想回答了什么重大时代课题？"></a>习近平新时代中国特色社会主义思想回答了什么重大时代课题？</h3><ol><li>新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义</li><li>建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国</li><li>建设什么样的长期执政的马克思主义政党，怎样建设长期执政的马克思主义政党</li></ol><h3 id="如何理解习近平新时代中国特色社会主义思想的历史地位？"><a href="#如何理解习近平新时代中国特色社会主义思想的历史地位？" class="headerlink" title="如何理解习近平新时代中国特色社会主义思想的历史地位？"></a>如何理解习近平新时代中国特色社会主义思想的历史地位？</h3><ol><li>当代中国马克思主义。三十一世纪马克思主义。</li><li>中华文化和中国精神的时代精华。</li><li>马克思主义中国化时代化新的飞跃。</li></ol><h3 id="如何奋力实现中国梦？"><a href="#如何奋力实现中国梦？" class="headerlink" title="如何奋力实现中国梦？"></a>如何奋力实现中国梦？</h3><ol><li>实现中国梦必领走中国道路，这就是中国特色社会主义道路;</li><li>实现中国梦必须弘扬中国精神——以爱国主义为核心的民族精神和以改革创新为核心的时代精神；</li><li>实现中国梦必须凝聚中国力量——中国各族人民大园结的力量。</li></ol><h3 id="实现全体人民共同富裕的实践举措有哪些？关注乡村振兴"><a href="#实现全体人民共同富裕的实践举措有哪些？关注乡村振兴" class="headerlink" title="实现全体人民共同富裕的实践举措有哪些？关注乡村振兴"></a>实现全体人民共同富裕的实践举措有哪些？关注乡村振兴</h3><ol><li>提高发展的平衡性、协调性、包容性。</li><li>着力扩大中等收入群体规模。</li><li>促进基本公共服务均等化。</li><li>加强对高收入的规范和调节。</li><li>促进人民精神生活共同富裕。</li><li>促进农民农村共同富裕。</li></ol><h3 id="如何构建对外开放新格局？"><a href="#如何构建对外开放新格局？" class="headerlink" title="如何构建对外开放新格局？"></a>如何构建对外开放新格局？</h3><ol><li>实行更加积极主动的开放战咯。<br>开放是当代中国的鲜明标识，觉的十八大以来，我国采取了更加积极主动的开放战略，我国对外开放水平持续提升，我们要推动更加包容的全球发展。人类文明己经进入21世纪，冷战思维早己过时。我们应该携手努力，开辟合作共赢的新境界。</li><li>构建互利共赢、多元平衡、 安全高效的开放型经济体系。<br>扩内需和增外需相互动，“引进来”和“走出去” 并举，促开放和护安全统筹，稳步扩大规则、规制、管理、标准等制度型开放。</li><li>推动共建“一带一路”高质量发展。经济发展、民生改善、文明进步。</li></ol><h3 id="我国现代化经济体系的内容是什么？"><a href="#我国现代化经济体系的内容是什么？" class="headerlink" title="我国现代化经济体系的内容是什么？"></a>我国现代化经济体系的内容是什么？</h3><ol><li>创新引领。协同发展的产业体系。统一开放、竞争有序的市场体系。</li><li>体现效率、促进公平的收入分配体系。彰显优势、协调联动的城乡区域发展体系。</li><li>资源节约。环境友好的绿色发展体系。多元平街、安全高效的全面开放体系。</li><li>充分发挥市场作用、重好发挥政府作用的经济体制。</li></ol><h3 id="供给侧结构性改革的必要性是什么？"><a href="#供给侧结构性改革的必要性是什么？" class="headerlink" title="供给侧结构性改革的必要性是什么？"></a>供给侧结构性改革的必要性是什么？</h3><ol><li>适应把握引领经济发展新常态的重大创新;</li><li>适应国际金融危机发生后综合国力竞争新形势的主动选择;</li><li>推动我国经济实现高质量发展的必然要求。</li></ol><h3 id="如何办好人民满意的教育？"><a href="#如何办好人民满意的教育？" class="headerlink" title="如何办好人民满意的教育？"></a>如何办好人民满意的教育？</h3><ol><li>必须深化教育领域線合改革。</li><li>必须促进教育公平，必须建设高质量教育体系。</li><li>必须加强教师队伍建设。</li></ol><h3 id="怎样加快建设科技强国？"><a href="#怎样加快建设科技强国？" class="headerlink" title="怎样加快建设科技强国？"></a>怎样加快建设科技强国？</h3><ol><li>发挥新型举国体制优势。<br>健全新型举国体制，强化国家战路科技力量，优化配置创新资源，使我国在重要科技领域成为全球领跑者，在前沿交叉领域成为开拓者，力争尽早成为世界主要科学中心和创新高地。发挥新型举国体制优势，要坚特党对科技事业的集中统一领导。发挥新型举国体制优势，要全面推进科技体制改革。</li><li>打豪关键接心技术攻坚战。<br>只有把关键核心技术掌握在自己手中，才能从根本上保障国家经济安全，国防安全和其他安全。只有把关健核心技术掌握在自己手中，才能真正掌握竞争和发展的主动权。打赢关健按心技术攻坚战，首要任务是加快实现“卡脖子〞 关健核心技术突破。</li><li>增强自主创新能力。<br>增强自主创新能力，要者力推进基础研究。增强自主创新能力，要着力推动应用研究。增强自主创新能力，要著力推动前沿研究。中国特色社会主义新时代是决胜全面建成小康社会，进而全面建设社会主义现代化强国的时代。</li></ol><h3 id="全过程人民民主好在哪里？"><a href="#全过程人民民主好在哪里？" class="headerlink" title="全过程人民民主好在哪里？"></a>全过程人民民主好在哪里？</h3><ol><li>人民民主参与不断扩大。</li><li>国家治理高效，社会和谐稳定。</li><li>权力运用得到有效制约和监督。</li></ol><h3 id="中国特色社会主义法治道路的核心要义是什么？"><a href="#中国特色社会主义法治道路的核心要义是什么？" class="headerlink" title="中国特色社会主义法治道路的核心要义是什么？"></a>中国特色社会主义法治道路的核心要义是什么？</h3><ol><li>坚持党的领导。</li><li>坚持中国特色社会主义制度。</li><li>贯彻中国特色社会主义法治理论。</li></ol><h3 id="为什么要建设中国特色社会主义文化？"><a href="#为什么要建设中国特色社会主义文化？" class="headerlink" title="为什么要建设中国特色社会主义文化？"></a>为什么要建设中国特色社会主义文化？</h3><ol><li>文化是一个国家、一个民族的灵魂，</li><li>没有文化繁荣兴盛就没有中华民族伟大复兴;</li><li>更好满足人民日益增长的精神文化需要。</li></ol><h3 id="“脱贫攻坚精神”的内涵？"><a href="#“脱贫攻坚精神”的内涵？" class="headerlink" title="“脱贫攻坚精神”的内涵？"></a>“脱贫攻坚精神”的内涵？</h3><ol><li>上下同心、尽说出战；</li><li>精准务实、开拓创新；</li><li>攻坚克难、不负人民;</li></ol><h3 id="怎样推进社会治理现代化？"><a href="#怎样推进社会治理现代化？" class="headerlink" title="怎样推进社会治理现代化？"></a>怎样推进社会治理现代化？</h3><ol><li>坚持系统治理、综合治理、依法治理、源头治理。</li><li>健全党组织领导的自治、 法治、德洽相结合的城乡基层治理体系。</li><li>加强社会治安综合治理。</li></ol><h3 id="社会主义生态文明观的主要内容？"><a href="#社会主义生态文明观的主要内容？" class="headerlink" title="社会主义生态文明观的主要内容？"></a>社会主义生态文明观的主要内容？</h3><ol><li>坚持人与自然和谐共生。</li><li>绿水青山就是金山银山。</li><li>良好生态环境是最普惠的民生福社。</li><li>统筹山水林田湖草沙系统治理。</li><li>用最严格制度最严密法治保护生态环境。</li><li>共谋全球生态文明建设。</li></ol><h3 id="国家安全"><a href="#国家安全" class="headerlink" title="国家安全"></a>国家安全</h3><p>国家安全是指国家政权、主权、统一和领士完整、人民福祉、经济社会可持续发展，和国家其他重大利益相对处于没有危险和不受内外威助的状态，以及保障持续安全状态的能力。</p><h3 id="怎样坚持和完善，—国两制〞制度体系？"><a href="#怎样坚持和完善，—国两制〞制度体系？" class="headerlink" title="怎样坚持和完善，—国两制〞制度体系？"></a>怎样坚持和完善，—国两制〞制度体系？</h3><ol><li>必须依法治港治澳，维护宪法和基本法确定的宪制秩序;</li><li>坚守“—国”原则，尊重“两制”差异;</li><li>完善特别行政区同宪法和基本法实施相关的制度和机制;健全中央依照宪法和基本法对特别行政区行使全面管治权制度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Final Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Politics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末复习-hadoop</title>
      <link href="/2023/07/07/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-hadoop/"/>
      <url>/2023/07/07/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-hadoop/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="Hadoop基本概念"><a href="#Hadoop基本概念" class="headerlink" title="Hadoop基本概念"></a>Hadoop基本概念</h2><ol><li>奠定大数据技术的理论基石的Google公司的三篇论文包括：GFS、MapReduce、BigTable，被称为Google公司的“三驾马车”。分别对应了Hadoop的HDFS、MapReduce、Hbase。</li><li>Hadoop的运行模式包括：单机（本地）模式，伪分布式模式，完全分布式模式</li><li>Hadoop能够使用户轻松开发和运行处理大数据的应用程序，它的优点是：处理能力强，实现了高效性和高可靠性；在集群间分配数据，高扩展性；能够保存多个数据副本，高容错性。</li><li>机架感知机制：同时兼顾节点之间的通信速度和提高数据的容错能力。</li><li>虚拟机是一种虚拟化技术，它能够在现有的操作系统上运行一个或多个操作系统。</li><li>Hadoop的安装方式包括：单机模式，伪分布式模式和完全分布式模式三种。</li><li>集群是指一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。</li><li>分布式系统是指将多台服务器集中在一起， 每台服务器都实现总体中的不同业务，做不同的事情。</li></ol><p>在linux的命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令，能够启动所有Hadoop相关的服务进程。</span></span><br><span class="line">stop-all.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令，能够单独启动HDFS服务。</span></span><br><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看在当前系统中启动了几个java进程的信息的</span></span><br><span class="line">jps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实现显示本机IP</span> </span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h2 id="HDFS功能"><a href="#HDFS功能" class="headerlink" title="HDFS功能"></a>HDFS功能</h2><ol><li>HDFS是基于流数据模式访问和处理超大文件的需求而开发的，具有高容错、高可靠性、高可扩展性、高吞吐率等特征，适合的读写任务是一次写入，多次读。</li><li>在HDFS中通过分块来实现数据的分布式存储功能，一个数据块会在多个此类节点中进行冗余备份。</li><li>NameNode是HDFS的管理节点，负责管理和维护HDFS的命名空间和管理DataNode上的数据块，它可以接受客户端的文件操作请求。所管理命名空间的信息文件有两个：fsimage和edits。</li><li>SecondaryNameNode，其主要职责是定期把NameNode上的fsimage和edits下载并合并生成新的fsimage。</li><li>在Hadoop2.2以上版本中，HDFS默认Block Size的大小是128m。</li><li>HDFS的缺点是：不适合处理低延迟的数据访问，不适合多用户写入及任意修改文件，不适合处理大量的小文件。</li><li>高可用性：是指通过在同一集群中运行两个NameNode的方式来防止由于单个NameNode故障引起的整个HDFS集群无法使用。</li><li>配额：是指可以设置HDFS在某个目录下文件数量与目录数量之和最大值。</li><li>联邦：是指在HDFS中有多个NameNode或NameSpace是联合的，相互独立，各自分工，管理自己的区域。</li><li>在core-site.xml修改fs.trash.interval选项来设置已删除文件在回收站中的保留时间。</li></ol><p>HDFS Shell命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录（文件夹）</span></span><br><span class="line">hdfs dfs -mkdir</span><br></pre></td></tr></table></figure><p>HDFS API</p><ul><li>getBlockSize：获得指定文件的数据块大小</li><li>getLength：实现返回文件长度</li></ul><h2 id="YARN的功能"><a href="#YARN的功能" class="headerlink" title="YARN的功能"></a>YARN的功能</h2><ol><li>Hadoop2.0相比较Hadoop1.0增加了YARN模块以实现对上层应用提供统一的资源管理和调度功能。</li><li>Container是YARN中的资源抽象，它封装了某个节点上的内存、CPU、磁盘、网络等多维度资源。</li><li>YARN提供先入先出调度器，容器调度器，公平调度器三种调度机制。</li></ol><h2 id="MapReduce的功能"><a href="#MapReduce的功能" class="headerlink" title="MapReduce的功能"></a>MapReduce的功能</h2><ol><li>MapReduce的特点：易于编程，分布式程序可以在大量廉价的PC上运行；良好的扩展性，可以通过增加集群中计算机数来提高计算能力；高容错性，当一台主机出故障计算任务可以转移到其他节点上。</li><li>MapReduce在对大数据的计算过程至少分为Map和Reduce两个部分。</li><li>MapReduce在Map步骤后对数据进行分区，排序，溢写，合并的步骤可以统称为 Shuffle 过程。Shuffle功能根据其功能和在MapReduce过程中的步骤，可以分为Map<br>Shuffle和Reduce Shuffle。</li><li>Hadoop的内置类型IntWritable用来定义整形数据，与Java的int类型对应。</li><li>Hadoop的内置类型 LongWritable 用来定义长整型型数据，与Java的long类型对应。</li><li>序列化是一种将内存中的Java对象转化为其他可存储文件或可跨计算机传输数据流的技术。</li><li>Hadoop序列化实现了org.apche.hadoop.io.Writable接口，其中包含write()和readFields()两个方法。</li><li>LineRecordReader 类实现了MapReduce从文本文件中逐行读取文本内容，生成&lt;Key,Value&gt;格式数据。</li><li>MapReduce通过分片对数据进行逻辑划分，在进行Map计算时所划分的处理数据对MapTask一一对应。所保存的HDFS的数据块（Block）与MapReduce所处理的数据切片（split）大小关系是相等、整数倍、几分之一的关系。</li><li>在Map阶段的分区步骤实现了根据Key值对数据进行划分，使其分配给对应ReduceTask。</li></ol><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ol><li>简述大数据理念的四个特征：<br/><br>数据体量大：大数据的数据量从 TB级别跃升到PB级别。<br/><br>数据类型多：大数据的数据类型包括前文提到的网络日志、视频、图片、地理位置信息等。<br/><br>处理速度快：1秒定律。这是大数据技术与传统数据挖掘技术的本质区别。<br/><br>价值密度低：以视频为例，在连续不间断的视频监控过程中，可能有用的数据仅仅有一两秒。</li><li>简述Hadoop对 Google公司三篇论文思想的实现的功能：<br/><br>HDFS是分布式文件系统，实现了分布式计算中数据存储管理功能，它是对GFS论文思想的实现。<br/><br>MapReduce是用于大规模数据集（大于1TB）的并行运算编程模型，它是对MapReduce论文思想的实现。<br/><br>HBase是一个分布式的、面向列的开源数据库。它是在Hadoop之上提供了类似于 BigTable的能力，是对BigTable论文思想的实现。</li><li>简述对HDFS进行访问和操作的三种方式：<br/><br>通过Web界面进行HDFS操作，使用浏览器访问HDFS对应IP端口为50070的页面对HDFS进行访问和操作。<br/><br>HDFS命令是由一系列类使用Linux<br>Shell的命令组成的，命令分为操作命令，管理命令和其他命令。可以通过Linux或远程控制段的命令行输入Shell名称来对HDFS进行访问和操作。<br/><br>Hadoop提供了多种HDFS的访问接口，Hadoop Java API位于“org.apache.hadoop.fs”包中，能够实现通过Java语言对HDFS进行文件操作和文件系统管理的访问功能。</li><li>简述HDFS的三个优点：<br/><br>处理超大文件：HDFS能够处理TB级甚至PB级的数据。<br/><br>支持流式数据访问：HDFS<br>设计建立在“一次写入，多次读取”的基础上，意味着一个数据集一旦生成，就会被复制分发到不同的存储节点，然后响应各种数据分析任务请求。<br/><br>低成本运行：HDFS可运行在低廉的商用硬件集群上。</li><li>简述MapReduce的四个特点：<br/><br>易于编程：用它的一些简单接口，就可以完成一个分布式程序，<br/><br>良好的扩展性：当计算资源不能得到满足的时候，可以通过简单地增加计算机来扩展它的计算能力。<br/><br>高容错性：一台主机出问题了，它可以把上面的计算任务转移到另外一个节点上运行，不至于使这个任务运行失败，而且这个过程不需要人工干预，完全由MapReduce在内部完成。<br/><br>能对PB级以上海量数据进行离线处理：MapReduce适合离线处理而不适合实时处理比如毫秒级别地返回一个结果，MapReduce很难做到。</li><li>简述Hadoop的三种安装模式：<br/><br>单机模式：指Hadoop运行在一台主机上，按默认配置以非分布式模式运行一个独的Java进程。单机模式是Hadoop的默认模式。<br/><br>伪分布式模式：指Hadoop运行在一台主机上，使用多个Java进程，模仿完全分布式的各类节点。伪分布式模式具备完全分布式的所有功能，常用调试程序。<br/><br>完全分布式模式：也叫集群模式，是将 Hadoop运行在多台主机中，各个主机按照相关配置运行相立的Hadoop守护进程。完全分布式模式是真正的分布式环境，可用于实际的生产环境。</li></ol><h2 id="易错概念"><a href="#易错概念" class="headerlink" title="易错概念"></a>易错概念</h2><ol><li>Hadoop是Java开发的，所以 MapReduce只支持Java语言编写。</li><li>Mapreduce的input split就是一个block。</li><li>客户端上传的数据首先发送给NameNode，根据NameNode所管理的DataNode的分工再逐个发送给DataNode。</li><li>为了实现环形缓冲区功能，Hadoop需要配置特殊结构的环形内存芯片。</li><li>MapReduce是Java语言开发的，因此其数据类型也沿用了Java的数据类型。</li><li>如果NameNode意外终止，SecondaryNameNode会接替它使集群继续工作。</li><li>为了保证数据的稳定性，数据切片（Split）的大小必须是数据块（block）的一样大。</li><li>高可用性HA通过在一个集群中同时处于Active状态的两个NameNode来保证HDFS能够正常运行。</li><li>数据块的大小（BlockSize）是不可以修改的。</li><li>在MapReduce计算中为了提高数据计算速度，当单个MapTask完成后数据会直接被拉取到Reduce阶段进行后续计算。</li><li>由于会出现相同的Key在不同的ReduceTask进行统计的情况，因此在Reduce阶段最后需要对所有节点所生成所有文件进行合并。</li></ol><h2 id="HDFS-Shell命令操作"><a href="#HDFS-Shell命令操作" class="headerlink" title="HDFS Shell命令操作"></a>HDFS Shell命令操作</h2><ol><li>在HDFS的根目录中上创建一个目录结构，为<code>new/folder</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /new/folder</span><br></pre></td></tr></table></figure></li><li>在HDFS根目录的<code>new</code>目录中创建文件<code>1.txt</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -touchz /new/1.txt</span><br></pre></td></tr></table></figure></li><li>将用户目录下的<code>context.txt</code>内容追加到HDFS文件<code>/new/1.txt</code>中<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -appendToFile context.txt /new/1.txt</span><br></pre></td></tr></table></figure></li><li>查看HDFS文件<code>/new/1.txt</code>的文件内容<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -cat /new/1.txt</span><br></pre></td></tr></table></figure></li><li>查看HDFS文件目录<code>/new</code>所占的磁盘空间大小<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -du /new</span><br></pre></td></tr></table></figure></li><li>删除HDFS文件目录<code>/new</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm /new</span><br></pre></td></tr></table></figure></li><li>在HDFS的根目录中上创建一个目录结构，为<code>dir1/dir2/dir3</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /dirl/dir2/dir3</span><br></pre></td></tr></table></figure></li><li>将Linux用户根目录中的文件<code>localFile.txt</code>复制到HDFS根目录中保存为<code>hdfsFile.txt</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -copyFromLocal localFile.txt /hdfsFile.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put localFile.txt /hdfsFile.txt</span><br></pre></td></tr></table></figure></li><li>显示HDFS中级联列出根目录下的所有目录和文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls -R /</span><br></pre></td></tr></table></figure></li><li>在HDFS根目录<code>dir1</code>目录中创建文件<code>1.txt</code>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -touchz /dir1/1.txt</span><br></pre></td></tr></table></figure></li><li>将用户目录下的<code>code2.txt</code>内容追加到HDFS文件<code>/dir1/1.txt</code>中   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -appendToFile code2.txt /dir1/1.txt</span><br></pre></td></tr></table></figure></li><li>将dir1目录中创建文件<code>1.txt</code>下载到Linux的本地根目录中，保存为文件<code>downloadFile.txt</code>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -copyToLocal / dir1/1.txt downloadFile.txt</span><br></pre></td></tr></table></figure>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -get /dir1/1.txt downloadFile.txt</span><br></pre></td></tr></table></figure></li></ol><h3 id="HDFS-API编程"><a href="#HDFS-API编程" class="headerlink" title="HDFS API编程"></a>HDFS API编程</h3><ol><li><p>已知HDFS的IP地址为<code>192.168.44.128</code>，访问端口为<code>9000</code>，用户名为<code>admin</code>。编程实现调用<code>FileSystem</code><br>类自带的<code>copyFromLocalFile</code>方法上传Linux系统中本地文件<code>/home/admin/upload.txt</code>到HDFS文件夹<code>/user/admin/</code><br>中保存为文件<code>1.txt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;hdfs://192.168.44.128:9000&quot;</span>);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(uri, conf, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/home/admin/upload.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/user/admin/1.txt&quot;</span>);</span><br><span class="line">        fs.copyFromLocalFile(src, dst);</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>已知HDFS的IP地址为<code>192.168.44.128</code>，访问端口为<code>9000</code>，用户名为<code>admin</code>。编程实现调用<code>FileSystem</code>类自带的<code>copyToLocalFile</code><br>方法下载HDFS文件夹<code>/user/admin/</code>中文件<code>1.txt</code>到Linux系统中本地目录<code>/home/admin/</code>保存为<code>download.txt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;hdfs://192.168.44.128:9000&quot;</span>);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(uri, conf, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/user/admin/1.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/home/admin/download.txt&quot;</span>);</span><br><span class="line">        fs.copyToLocalFile(src, dst);</span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MapReduce程序设计题"><a href="#MapReduce程序设计题" class="headerlink" title="MapReduce程序设计题"></a>MapReduce程序设计题</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>在某企业管理系统的数据库中所保存员工信息表EMP的结构如下所示：</p><table><thead><tr><th>EMPNO</th><th>ENAME</th><th>JOB</th><th>MGR</th><th>HIREDATE</th><th>SAL</th><th>COMM</th><th>DEPTNO</th></tr></thead><tbody><tr><td>3641</td><td>石金泉</td><td>管理</td><td>0001</td><td>2009&#x2F;3&#x2F;4</td><td>20000</td><td>50000</td><td>1</td></tr><tr><td>6984</td><td>高丽</td><td>行政</td><td>5684</td><td>2009&#x2F;3&#x2F;7</td><td>3500</td><td>4000</td><td>1</td></tr><tr><td>7397</td><td>门亮</td><td>开发</td><td>7396</td><td>2009&#x2F;5&#x2F;11</td><td>10000</td><td>25000</td><td>2</td></tr><tr><td>7398</td><td>李贺</td><td>开发</td><td>7396</td><td>2009&#x2F;9&#x2F;22</td><td>10000</td><td>25000</td><td>2</td></tr><tr><td>8049</td><td>李加里</td><td>销售</td><td>3641</td><td>2009&#x2F;3&#x2F;21</td><td>8000</td><td>50000</td><td>3</td></tr><tr><td>8331</td><td>孙立宪</td><td>销售</td><td>8049</td><td>2009&#x2F;4&#x2F;29</td><td>6000</td><td>40000</td><td>3</td></tr><tr><td>9486</td><td>李明礼</td><td>生产</td><td>3641</td><td>2009&#x2F;3&#x2F;25</td><td>7000</td><td>9000</td><td>4</td></tr><tr><td>9696</td><td>张顺涛</td><td>生产</td><td>9486</td><td>2009&#x2F;4&#x2F;20</td><td>4000</td><td>5000</td><td>4</td></tr></tbody></table><p>其中表中各字段代表的含义：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>EMPNO</td><td>员工号</td></tr><tr><td>ENAME</td><td>员工姓名</td></tr><tr><td>JOB</td><td>岗位</td></tr><tr><td>MGR</td><td>直属领导</td></tr><tr><td>HIREDATE</td><td>雇佣时间</td></tr><tr><td>SAL</td><td>月薪</td></tr><tr><td>COMM</td><td>奖金</td></tr><tr><td>DEPTNO</td><td>部门号</td></tr></tbody></table><p>将数据从数据库中导出，保存为文件emp.csv以作为统计每个部门员工月薪总额的基础数据，文件其内容为：</p><blockquote><p>3641,石金泉,管理,0001,2009&#x2F;3&#x2F;4,20000,50000,1</p><p>6984,高丽,行政,5684,2009&#x2F;3&#x2F;7,3500,4000,1</p><p>7397,门亮,开发,7396,2009&#x2F;5&#x2F;11,10000,25000,2</p><p>7398,李贺,开发,7396,2009&#x2F;9&#x2F;22,10000,25000,2</p><p>8049,李加里,销售,3641,2009&#x2F;3&#x2F;21,8000,50000,3</p><p>8331,孙立宪,销售,8049,2009&#x2F;4&#x2F;29,6000,40000,3</p><p>9486,李明礼,生产,3641,2009&#x2F;3&#x2F;25,7000,9000,4</p><p>9696,张顺涛,生产,9486,2009&#x2F;4&#x2F;20,4000,5000,4</p></blockquote><p>将<code>emp.csv</code>上传到HDFS目录<code>hdfs://192.168.44.128:9000/user/input/</code></p><p>以MapReduce方式实现根据<code>emp.csv</code>中所包含的员工信息统计部门月薪总额的功能，以文字的方式分析求每个部门月工资总额数据的Map和Reduce步骤各完成的功能以及输入，输出数据类型。<br>根据注释描述分别填写Main类，Map类和Reduce类对应java代码。要求将计算的结果保存在HDFS目录<code>hdfs://192.168.44.128:9000/user/output/</code><br>中</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>Map阶段输入类型为<code>Key LongWritable : Value Text</code>分别表示文本偏移量，当前行员工的信息</p><p>Map所实现的功能是根据逗号从当前行文本内容中提取出当前员工的部门编号和月薪</p><p>输出<code>key IntWritable : Value IntWritable</code>分别表示部门编号，当前行员工的月薪</p><p>Reduce阶段输入类型<code>Key IntWritable : Value IntWritable</code>分别表示部门编号，当前部门的员工月薪集合</p><p>Reduce所实现的功能是将当前部门的所有员工月薪进行累加得到整个部门的月薪总额</p><p>输出<code>Key IntWritable : Value IntWritable</code>分别表示部门编号，当前部门的月薪总额</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><ol><li><p>ExamMapper Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, IntWritable, IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key1, Text value1, Context context)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 读取的一行文本内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> value1.toString();</span><br><span class="line">        <span class="comment">// 将字符串以逗号为标记点进行分割</span></span><br><span class="line">        String[] words = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出&lt; key,Value &gt;</span></span><br><span class="line">        context.write(<span class="keyword">new</span> <span class="title class_">IntWritable</span>(Integer.parseInt(words[<span class="number">7</span>])), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(Integer.parseInt(words[<span class="number">5</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExamReducer Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;IntWritable, IntWritable, IntWritable, IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(IntWritable key3, Iterable&lt;IntWritable&gt; value3, Context context)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : value3) &#123;</span><br><span class="line">            total += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key3, <span class="keyword">new</span> <span class="title class_">IntWritable</span>(total));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExamMain Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">        <span class="comment">// 设置Client的类</span></span><br><span class="line">        job.setJarByClass(ExamMain.class);</span><br><span class="line">        <span class="comment">// 设置Map的类和输入类型</span></span><br><span class="line">        job.setMapperClass(ExamMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(IntWritable.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">// 设置reduce的类和输入类型</span></span><br><span class="line">        job.setReducerClass(ExamReducer.class);</span><br><span class="line">        job.setOutputKeyClass(IntWritable.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://192.168.44.128:9000/user/input/Employee/EMP.csv&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://192.168.44.128:9000/user/output/SalaryTotal&quot;</span>));</span><br><span class="line">        job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1"></a>练习1</h3><p>在某图书馆图书管理系统的数据库中所保存图书信息表BookInfo的结构如下所示：</p><table><thead><tr><th>BOOKID</th><th>BNAME</th><th>ROOM</th><th>TYPE</th><th>DATE</th><th>PRICE</th></tr></thead><tbody><tr><td>0001</td><td>老人与海</td><td>1</td><td>文学</td><td>2009&#x2F;3&#x2F;4</td><td>35</td></tr><tr><td>0002</td><td>时尚杂志</td><td>2</td><td>期刊杂志</td><td>2009&#x2F;3&#x2F;7</td><td>20</td></tr><tr><td>0003</td><td>C语言</td><td>3</td><td>计算机</td><td>2009&#x2F;5&#x2F;11</td><td>32</td></tr><tr><td>0004</td><td>红楼梦</td><td>1</td><td>文学</td><td>2009&#x2F;9&#x2F;22</td><td>50</td></tr><tr><td>0005</td><td>JAVA开发</td><td>3</td><td>计算机</td><td>2009&#x2F;3&#x2F;21</td><td>24</td></tr><tr><td>0006</td><td>计算机基础</td><td>3</td><td>计算机</td><td>2009&#x2F;4&#x2F;29</td><td>25</td></tr><tr><td>0007</td><td>西游记</td><td>1</td><td>文学</td><td>2009&#x2F;3&#x2F;25</td><td>40</td></tr><tr><td>0008</td><td>读者文摘</td><td>2</td><td>期刊杂志</td><td>2009&#x2F;4&#x2F;20</td><td>8</td></tr></tbody></table><p>其中表中各字段代表的含义：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>BOOKID</td><td>图书编号</td></tr><tr><td>BNAME</td><td>书名</td></tr><tr><td>ROOM</td><td>所在房间</td></tr><tr><td>TYPE</td><td>图书类型</td></tr><tr><td>DATE</td><td>购入时间</td></tr><tr><td>PRICE</td><td>价格</td></tr></tbody></table><p>将数据从数据库中导出，保存为文件book.csv以作为统计每类图书总价格的基础数据，文件其内容为：</p><blockquote><p>0001,老人与海,1,文学,2009&#x2F;3&#x2F;4,35</p><p>0002,时尚杂志,2,期刊杂志,2009&#x2F;3&#x2F;7,20</p><p>0003,C语言,3 计算机,2009&#x2F;5&#x2F;11,32</p><p>0004,红楼梦,1,文学,2009&#x2F;9&#x2F;22,50</p><p>0005,JAVA开发,3,计算机,2009&#x2F;3&#x2F;21,24</p><p>0006,计算机基础,3,计算机,2009&#x2F;4&#x2F;29,25</p><p>0007,西游记,1,文学,2009&#x2F;3&#x2F;25,40</p><p>0008,读者文摘,2,期刊杂志,2009&#x2F;4&#x2F;20,8</p></blockquote><p>将<code>book.csv</code>上传到HDFS目录<code>hdfs://192.168.44.128:9000/user/input/</code><br>以MapReduce方式实现根据book.csv中所包含的图书信息统计每类图书的总价格的功能，以文字的方式分析求每大类图书价格的Map和Reduce步骤各完成的功能以及输入，输出数据类型。根据注释描述分别填写Main类，Map类和Reduce类对应java代码。要求将计算的结果保存在HDFS目录<code>hdfs://192.168.44.128:9000/user/output/</code><br>中。</p><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>Map阶段输入类型为<code>Key LongWritable : Value Text</code>分别表示文本偏移量，当前行图书的信息</p><p>Map所实现的功能是根据逗号从当前行文本内容中提取出当前图书的类型和价格</p><p>输出<code>key Text : Value IntWritable</code>分别表示当前行图书的类型和价格</p><p>Reduce阶段输入类型为<code>key Text : Value IntWritable</code>分别表示当前行图书的类型，当前类所有图书的价格集合</p><p>Reduce所实现的功能是将当前类型的所有图书价格进行累加得的价格总额</p><p>输出<code>key Text : Value IntWritable</code>分别表示图书类型，当前类型图书的价格总额</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><ol><li>ExamMapper Class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key1, Text value1, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> value1.toString();</span><br><span class="line">        <span class="comment">// 将字符串以逗号为标记点进行分割，保存如字符串数组中</span></span><br><span class="line">        String[] words = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(words[<span class="number">3</span>]), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(Integer.parseInt(words[<span class="number">5</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ExamReducer Class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key3, Iterable&lt;IntWritable&gt; value3, Context context)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : value3) &#123;</span><br><span class="line">            total += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key3, <span class="keyword">new</span> <span class="title class_">IntWritable</span>(total));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ExamMain Class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MapReduceExam2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个job作业实例</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">        <span class="comment">// 设置作业的启动类</span></span><br><span class="line">        job.setJarByClass(ExamMain.class);</span><br><span class="line">        <span class="comment">// 设置Map的类和输入类型</span></span><br><span class="line">        job.setMapperClass(ExamMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">// 设置reduce的类和输入类型</span></span><br><span class="line">        job.setReducerClass(ExamReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://192.168.44.128:9000/ExamData/book.csv&quot;</span>));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://192.168.44.128:9000/ExamOutput/&quot;</span>));</span><br><span class="line">        job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Final Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ChatGPT的tokens收费标准</title>
      <link href="/2023/07/07/About-GPT-Token/"/>
      <url>/2023/07/07/About-GPT-Token/</url>
      
        <content type="html"><![CDATA[<h1 id="关于ChatGPT的tokens收费标准"><a href="#关于ChatGPT的tokens收费标准" class="headerlink" title="关于ChatGPT的tokens收费标准"></a>关于ChatGPT的tokens收费标准</h1><p>根据OpenAI官网给出的<a href="https://openai.com/pricing">计费标准</a></p><p>总结了以下表格：</p><table><thead><tr><th>模型</th><th>最大长度</th><th>输入（&#x2F;1k tokens）</th><th>输出（1k tokens）</th><th>使用价格</th><th>类型</th></tr></thead><tbody><tr><td>GPT-4</td><td>8K</td><td>$0.03</td><td>$0.06</td><td></td><td>语言模型</td></tr><tr><td>GPT-4</td><td>32K</td><td>$0.06</td><td>$0.12</td><td></td><td>语言模型</td></tr><tr><td>GPT-3.5 Turbo</td><td>4K</td><td>$0.0015</td><td>$0.002</td><td></td><td>语言模型</td></tr><tr><td>GPT-3.5 Turbo</td><td>16K</td><td>$0.003</td><td>$0.004</td><td></td><td>语言模型</td></tr><tr><td>Ada</td><td></td><td>$0.0004</td><td>$0.0016</td><td></td><td>微调模型</td></tr><tr><td>Babbage</td><td></td><td>$0.0006</td><td>$0.0024</td><td></td><td>微调模型</td></tr><tr><td>Curie</td><td></td><td>$0.0030</td><td>$0.012</td><td></td><td>微调模型</td></tr><tr><td>Davinci</td><td></td><td>$0.0300</td><td>$0.12</td><td></td><td>微调模型</td></tr><tr><td>Ada v2</td><td>Ada v2</td><td></td><td></td><td>$0.0001&#x2F;1K tokens</td><td>嵌入模型</td></tr><tr><td>Image models</td><td>1024×1024</td><td></td><td></td><td>$0.020&#x2F;image</td><td>图像模型</td></tr><tr><td>Image models</td><td>512×512</td><td></td><td></td><td>$0.018&#x2F;image</td><td>图像模型</td></tr><tr><td>Image models</td><td>256×256</td><td></td><td></td><td>$0.016&#x2F;image</td><td>图像模型</td></tr><tr><td>Whisper</td><td></td><td></td><td></td><td>$0.006&#x2F;min</td><td>音频模型</td></tr></tbody></table><blockquote><p>事实上，OpenAI推出的模型不只这些，通过api可以得到最完整的模型列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/models \</span><br><span class="line">-H &quot;Authorization: Bearer $OPENAI_API_KEY&quot;</span><br></pre></td></tr></table></figure><p>如果没有key或者不想发送请求可以直接获取下面的json数据都是一样的</p><p>截止2023年7月7日全部模型的json数据：</p><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="openai_models.json" href="/citation/openai_models.json"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">openai_models.json</p><p class="url">/citation/openai_models.json</p></div></a></div></div></blockquote><h2 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h2><p>上述内容中多次提到了tokens的概念，什么是tokens？</p><blockquote><p>您可以将标记视为用于自然语言处理的单词片段。对于英文文本，1 个标记大约为 4 个字符或 0.75 个单词。作为参考，莎士比亚的作品集大约有<br>90 万字或 120 万个符号。</p><p><code>1000</code>tokens约等于<code>750</code>个单词</p><p>要了解有关代币如何工作并估计您的使用情况的更多信息……</p><ul><li>使用我们的交互式 <a href="https://platform.openai.com/tokenizer">分词器工具</a>进行实验。</li><li>登录您的帐户并在 Playground 中输入文本。页脚中的计数器将显示文本中有多少个标记。</li></ul></blockquote><p>根据OpenAI官方给出的回答还是无法有一个具体的掌握。</p><p>转换为中文，tokens的大小为多少？</p><p>使用gpt-3.5-turbo-0301为例：</p><table><thead><tr><th>Request content</th><th>Response content</th><th>input tokens</th><th>output tokens</th><th>total</th></tr></thead><tbody><tr><td>Say this is a test!</td><td>This is a test!</td><td>13</td><td>5</td><td>18</td></tr><tr><td>请形容一下小猫</td><td>小猫是一种可爱的小动物，通常体型娇小，毛发柔软。它们的眼睛大而明亮，透露出一种天真无邪的神采。小猫的耳朵尖尖，灵敏而警觉，时刻捕捉着周围的声音。它们的小鼻子粉嫩可爱，鼻尖微微动着，好奇地探索着周围的世界。小猫的爪子尖锐而灵活，能够轻松攀爬和抓捕猎物。它们的尾巴修长而灵动，时而垂下，时而竖起，表达出各种情绪。小猫的身体柔软而灵活，它们经常会摆出各种可爱的姿势，让人看了心情愉悦。总之，小猫是一种令人陶醉的可爱生物，它们的存在让人感到温暖和幸福。</td><td>16</td><td>319</td><td>335</td></tr><tr><td>请翻译：This technical report presents GPT-4, a large multimodal model capable of processing image and text inputs and producing text outputs. Such models are an important area of study as they have the potential to be used in a wide range of applications, such as dialogue systems, text summarization, and machine translation. As such, they have been the subject of substantial interest and progress in recent years.</td><td>这份技术报告介绍了GPT-4，一个能够处理图像和文本输入并生成文本输出的大型多模态模型。这样的模型是研究的重要领域，因为它们有潜力在各种应用中使用，如对话系统、文本摘要和机器翻译。因此，近年来它们受到了广泛关注和进展的研究对象。</td><td>93</td><td>127</td><td>220</td></tr></tbody></table><p>经过计算得出，1字约等于1token，英文状态4个字符约等于1token。</p><blockquote><p>假设：我现在有一篇论文要写，需求（input content）输入了100字，需要生成一篇5000字的论文（output<br>content），算上中间的润色和修改（约等于重复3遍），那么可以计算写一篇论文大约会消耗tokens &#x3D; ((100 + 5000) * 5) &#x3D; 25500</p><p>使用GPT-3.5，费用为 0.03825美元 约等于 0.277人民币，<br>如果内容总长度超过4096k，那么价格会翻一倍，费用为 0.0765美元 约等于 0.5534人民币（汇率为1美元兑7.2337人民币）</p><p>使用GPT-4，费用为 0.765美元 约等于 5.534人民币</p><p>当然这只是猜测。</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用gpt-3.5-turbo-16k与gpt-3.5-turbo-4k（并未写完一篇论文）：：</p><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="gpt-3.5-turbo-16k.html" href="/citation/gpt-3.5-turbo-16k.html"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">gpt-3.5-turbo-16k.html</p><p class="url">/citation/gpt-3.5-turbo-16k.html</p></div></a></div><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="gpt-3.5-turbo-4k.html" href="/citation/gpt-3.5-turbo-4k.html"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">gpt-3.5-turbo-4k.html</p><p class="url">/citation/gpt-3.5-turbo-4k.html</p></div></a></div></div><p>整理好的论文（字数：7479）：</p><div class="link-group"><div class="tagLink"><a class="link-card" no-pjax target="_blank" title="习近平新时代.pdf" href="/citation/习近平新时代.pdf"><span class="link-card-backdrop" style="background-image: url(https://cdn.pixabay.com/photo/2018/12/05/13/41/panda-3857754__340.jpg)"></span><div class="left"><img src="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" class="lazyload placeholder" data-srcset="https://img.51miz.com/Element/00/37/79/59/10df0417_E377959_b7bb9dfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">习近平新时代.pdf</p><p class="url">/citation/习近平新时代.pdf</p></div></a></div></div><p>根据最后的返回<code>Total tokens spent: 52087</code>可以得出本次论文一共花费了<code>52087/1000*0.003*7.2337=1.1303451957¥</code>花费1.13人民币。</p><h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>为什么会与预测的花费不一致？</p><ol><li>示例中生成的文章为7000+</li><li>采用的是gpt对话的形式，也就是说每一次对话都需要把本次对话中的上文全部当作前置传入，这样就增加了tokens的消耗</li><li>输入与输出的tokens的价格并不相等，输出的tokens更贵一些</li></ol>]]></content>
      
      
      <categories>
          
          <category> Pointless small talk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末复习-数据库原理</title>
      <link href="/2023/07/06/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/06/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>具体考些什么我也不太记得，有关系代数、sql语言、E-R图，其余的不太清楚了。</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>关系代数是一种数学工具和查询语言，用于处理和操作关系型数据库中的关系数据。它提供了一组操作符，用于对关系进行操作和组合，以获取所需的数据结果。</p><p>关系代数的基本操作符包括：</p><ol><li>选择（Selection）：根据指定的条件从关系中选择满足条件的元组。</li><li>投影（Projection）：从关系中选择指定的属性列，生成一个新的关系。</li><li>连接（Join）：将两个关系根据共享的属性列合并成一个新的关系。</li><li>交（Intersection）：获取两个关系的交集，即共有的元组。</li><li>并（Union）：获取两个关系的并集，即合并两个关系的元组，去除重复项。</li><li>差（Difference）：获取一个关系中有而另一个关系中没有的元组。</li><li>除（Division）：根据指定条件从一个关系中选择满足条件的元组，然后从另一个关系中选择与前一步结果关系中的所有元组匹配的元组。</li></ol><p>通过组合和嵌套这些基本操作符，可以进行更复杂的查询和操作，从而实现对关系数据库中的数据的有效管理和检索。关系代数是关系数据库理论的基础之一，它提供了一种形式化的方式来描述和操作关系数据库中的数据。</p><p>以下是关系代数基本操作的常用符号表示：</p><ol><li><p>选择（Selection）：用σ（sigma）符号表示。例如，σ&lt;条件&gt;(关系) 表示选择满足指定条件的元组。</p></li><li><p>投影（Projection）：用π（pi）符号表示。例如，π&lt;属性列表&gt;(关系) 表示从关系中选择指定的属性列。</p></li><li><p>连接（Join）：用⨝（join）符号表示。例如，关系1 ⨝ 关系2 表示根据共享的属性列将两个关系进行连接。</p></li><li><p>交（Intersection）：用∩（intersection）符号表示。例如，关系1 ∩ 关系2 表示获取两个关系的交集，即共有的元组。</p></li><li><p>并（Union）：用∪（union）符号表示。例如，关系1 ∪ 关系2 表示获取两个关系的并集，即合并两个关系的元组，去除重复项。</p></li><li><p>差（Difference）：用-（minus）符号表示。例如，关系1 - 关系2 表示获取一个关系中有而另一个关系中没有的元组。</p></li><li><p>除（Division）：用÷（division）符号表示。例如，关系1 ÷ 关系2 表示根据指定条件从一个关系中选择满足条件的元组，然后从另一个关系中选择与前一步结果关系中的所有元组匹配的元组。</p></li></ol><p>这些符号表示了关系代数中的基本操作，可以根据需要进行组合和嵌套，以实现更复杂的查询和操作。</p><h3 id="训练场"><a href="#训练场" class="headerlink" title="训练场"></a>训练场</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Emp(E#,Ename,Age,Salary,D#);</span><br><span class="line">Depa(D#,Dname,Mgr#);</span><br></pre></td></tr></table></figure><ol><li><p>检索每个部门经理的工资（显示部门编号，部门名称，经理编号，经理姓名，经理工资）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π D#, Dname, Mgr#, Ename, Salary (σ Emp.E# = Depa.Mgr# ∧ Emp.D# = Depa.D# (Emp ∞ Depa))</span><br></pre></td></tr></table></figure></li><li><p>检索部门名称为“销售科”的职工工号，姓名，工资：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π E#, Ename, Salary (σ Dname = &quot;销售科&quot; (Emp ∞ Depa))</span><br></pre></td></tr></table></figure></li><li><p>已知一关系数据库的模式如下：<br>供应商关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(Sno,Sname,City);</span><br></pre></td></tr></table></figure><p>零件关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(Pno,Pname,Color,Weight);</span><br></pre></td></tr></table></figure><p>工程关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J(Jno,Jname,City);</span><br></pre></td></tr></table></figure><p>供货关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPJ(Sno,Pno,Jno,Qty);</span><br></pre></td></tr></table></figure><p>用关系代数完成下列查询：</p><ol><li><p>查询为工程’J1’供货的供应商名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> Sno</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> Jno <span class="operator">=</span> <span class="string">&#x27;J1&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询供应’螺母’零件的供应商名和所在城市：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, City</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> Sno</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> Pno <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> Pno</span><br><span class="line">        <span class="keyword">FROM</span> P</span><br><span class="line">        <span class="keyword">WHERE</span> Pname <span class="operator">=</span> <span class="string">&#x27;螺母&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询工程’J2’不使用的零件名和颜色：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Pname, Color</span><br><span class="line"><span class="keyword">FROM</span> P</span><br><span class="line"><span class="keyword">WHERE</span> Pno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> Pno</span><br><span class="line">    <span class="keyword">FROM</span> SPJ</span><br><span class="line">    <span class="keyword">WHERE</span> Jno <span class="operator">=</span> <span class="string">&#x27;J2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>SQL（Structured Query Language）是一种用于管理关系型数据库系统的编程语言。它是一个标准化的语言，用于存储、检索、操作和管理数据库中的数据。</p><p>SQL提供了一组用于执行各种操作的命令和语句，包括以下主要方面：</p><ol><li><p>数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库对象（例如表、视图、索引等）的语句。DDL语句包括CREATE、ALTER和DROP等。</p></li><li><p>数据操作语言（Data Manipulation Language，DML）：用于操作和处理数据库中的数据的语句。DML语句包括SELECT、INSERT、UPDATE和DELETE等。</p></li><li><p>数据控制语言（Data Control Language，DCL）：用于控制数据库的安全性和访问权限的语句。DCL语句包括GRANT和REVOKE等。</p></li><li><p>数据查询语言（Data Query Language，DQL）：用于从数据库中检索数据的语句。DQL语句主要是SELECT语句，用于查询满足指定条件的数据。</p></li></ol><p>SQL语言的特点包括：</p><ul><li>面向集合：SQL处理数据的基本单位是集合，即表中的行。</li><li>声明式语言：SQL是一种声明式语言，用户只需描述所需的结果，而不需要指定具体的操作步骤。</li><li>高度可扩展：SQL支持在单个查询中使用多个表进行联接，执行复杂的数据操作和聚合运算。</li><li>广泛应用：SQL是关系型数据库系统的标准查询语言，几乎所有主流的关系型数据库管理系统（如MySQL、Oracle、SQL Server等）都支持SQL语言。</li></ul><p>通过SQL语言，用户可以方便地管理和操作数据库中的数据，执行各种查询、更新和管理任务。</p><h3 id="训练场-1"><a href="#训练场-1" class="headerlink" title="训练场"></a>训练场</h3><p>这里存在数据库，结构为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="keyword">No</span>,name,sex,age,class);</span><br><span class="line">Course(Cno,cname,Tno);</span><br><span class="line">Teacher(Tno,name,sex,prof,dept);</span><br><span class="line">Score(<span class="keyword">No</span>,Cno,Grade);</span><br></pre></td></tr></table></figure><ol><li><p>查询选修课程<code>3-105</code>且成绩在60到80之间的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> Grade <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询成绩为85,86或88的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IN</span> (<span class="number">85</span>, <span class="number">86</span>, <span class="number">88</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询<code>95031</code>班的学生人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询至少有5名同学选修的并以3开头的课程的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="keyword">LIKE</span> <span class="string">&#x27;3%&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询最低分大于70，最高分小于90的<code>NO</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">No</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(Grade) <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="built_in">MAX</span>(Grade) <span class="operator">&lt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询<code>95033</code>班学生所选课程的平均分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> Score, Student</span><br><span class="line"><span class="keyword">WHERE</span> Score.No <span class="operator">=</span> Student.No <span class="keyword">AND</span> Class <span class="operator">=</span> <span class="string">&#x27;95033&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">No</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询选修<code>3-105</code>课程的成绩高于<code>109</code>号同学成绩的所有同学的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> Grade <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> Grade <span class="keyword">FROM</span> Score <span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> <span class="keyword">No</span> <span class="operator">=</span> <span class="string">&#x27;109&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询与学号为<code>108</code>的同学同岁的所有学生的<code>NO</code>, <code>Name</code>, <code>Age</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Name, Age</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Age <span class="operator">=</span> (<span class="keyword">SELECT</span> Age <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> <span class="keyword">No</span> <span class="operator">=</span> <span class="string">&#x27;108&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询<code>张旭</code>教师任课的课程号及选修其课程的学生的学号和成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> Tno <span class="operator">=</span> (<span class="keyword">SELECT</span> Tno <span class="keyword">FROM</span> Teacher <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;张旭&#x27;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score, Teacher, Course</span><br><span class="line"><span class="keyword">WHERE</span> Teacher.Tno <span class="operator">=</span> Course.Tno <span class="keyword">AND</span> Course.Cno <span class="operator">=</span> Score.Cno <span class="keyword">AND</span> Teacher.name <span class="operator">=</span> <span class="string">&#x27;张旭&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询选修某课程的学生人数多于30人的教师姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name</span><br><span class="line"><span class="keyword">FROM</span> Teahcer</span><br><span class="line"><span class="keyword">WHERE</span> Tno <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Tno</span><br><span class="line">   <span class="keyword">FROM</span> Course</span><br><span class="line">   <span class="keyword">WHERE</span> Cno <span class="keyword">IN</span> (</span><br><span class="line">       <span class="keyword">SELECT</span> Cno</span><br><span class="line">       <span class="keyword">FROM</span> Score</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno</span><br><span class="line">       <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="keyword">No</span>) <span class="operator">&gt;</span> <span class="number">30</span></span><br><span class="line">   )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name</span><br><span class="line"><span class="keyword">FROM</span> Techaer, Score, Course</span><br><span class="line"><span class="keyword">WHERE</span> Techaer.Tno <span class="operator">=</span> Course.Tno</span><br><span class="line">   <span class="keyword">AND</span> Course.Cno <span class="operator">=</span> Score.Cno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询<code>计算机系</code>与<code>电子工程系</code>不同职称的教师姓名和职称：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, prof</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> Dept <span class="operator">=</span> <span class="string">&#x27;电子工程系&#x27;</span> <span class="keyword">AND</span> Prof <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Prof</span><br><span class="line">   <span class="keyword">FROM</span> Teacher</span><br><span class="line">   <span class="keyword">WHERE</span> Dept <span class="operator">=</span> <span class="string">&#x27;计算机系&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查询选修编号为<code>3-105</code>课程且成绩至少高于选修编号为<code>3-234</code>课程的同学的课号、学号、成绩，并按成绩降序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, grade</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> Grade <span class="operator">&gt;</span> <span class="keyword">ANY</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> grade</span><br><span class="line">   <span class="keyword">FROM</span> Score</span><br><span class="line">   <span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-234&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询选修编号为<code>3-105</code>课程且成绩高于选修编号为<code>3-234</code>课程的同学的课号、学号、成绩，并按成绩降序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, grade</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> Grade <span class="operator">&gt;</span> <span class="keyword">ALL</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> grade</span><br><span class="line">   <span class="keyword">FROM</span> Score</span><br><span class="line">   <span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;3-234&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>列出所有老师和同学的姓名、性别和年龄：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name, Sex, Age</span><br><span class="line"><span class="keyword">FROM</span> teacher</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Name, Sex, Age</span><br><span class="line"><span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure></li><li><p>查询成绩比该课平均成绩低的学生的成绩表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line">   <span class="keyword">FROM</span> Score <span class="keyword">AS</span> y</span><br><span class="line">   <span class="keyword">WHERE</span> Score.Cno <span class="operator">=</span> y.Cno</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>列出所有任课教师的Name和Dept：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name, Dept</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> Tno <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Tno</span><br><span class="line">   <span class="keyword">FROM</span> Course</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name, Dept</span><br><span class="line"><span class="keyword">FROM</span> Teahcer <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">FROM</span> Course <span class="keyword">AS</span> B</span><br><span class="line">   <span class="keyword">WHERE</span> A.Tno <span class="operator">=</span> B.Tno</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>列出所有未讲课教师的Name和Dept：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name, Dept</span><br><span class="line"><span class="keyword">FROM</span> Teacher</span><br><span class="line"><span class="keyword">WHERE</span> Tno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Tno</span><br><span class="line">   <span class="keyword">FROM</span> Course</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name, Dept</span><br><span class="line"><span class="keyword">FROM</span> Teahcer <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">FROM</span> Course <span class="keyword">AS</span> B</span><br><span class="line">   <span class="keyword">WHERE</span> A.Tno <span class="operator">=</span> B.Tno</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>列出至少有2名男生的班级编号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Class</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询不姓<code>王</code>的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> Name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询每门课最高分的同学的No, Cno, Grade：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score A</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">=</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Grade)</span><br><span class="line">   <span class="keyword">FROM</span> Score B</span><br><span class="line">   <span class="keyword">WHERE</span> A.Cno <span class="operator">=</span> B.Cno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score A</span><br><span class="line"><span class="keyword">WHERE</span> A.Cno <span class="operator">=</span> B.Cno <span class="keyword">AND</span> Grade <span class="operator">=</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Grade)</span><br><span class="line">   <span class="keyword">FROM</span> Score B</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查询与“李军”同性别并同班的同学姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Class <span class="operator">=</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Class</span><br><span class="line">   <span class="keyword">FROM</span> Student</span><br><span class="line">   <span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;李军&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> sex <span class="operator">=</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> sex</span><br><span class="line">   <span class="keyword">FROM</span> Student</span><br><span class="line">   <span class="keyword">WHERE</span> Name <span class="operator">=</span> <span class="string">&#x27;李军&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查询<code>男</code>教师及其所任的课程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.Name, B.Cname</span><br><span class="line"><span class="keyword">FROM</span> Teacher A, Course B</span><br><span class="line"><span class="keyword">WHERE</span> A.Tno <span class="operator">=</span> B.Tno <span class="keyword">AND</span> A.sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询选修<code>计算机导论</code>课程的<code>男</code>同学的成绩表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> Cno</span><br><span class="line">   <span class="keyword">FROM</span> Course</span><br><span class="line">   <span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;计算机导论&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">No</span> <span class="keyword">IN</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">No</span></span><br><span class="line">   <span class="keyword">FROM</span> Student</span><br><span class="line">   <span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">No</span>, Cno, Grade</span><br><span class="line"><span class="keyword">FROM</span> Score A, Student B, Course C</span><br><span class="line"><span class="keyword">WHERE</span> A.No <span class="operator">=</span> B.No</span><br><span class="line"><span class="keyword">AND</span> A.Cno <span class="operator">=</span> C.Cno</span><br><span class="line"><span class="keyword">AND</span> C.Cname <span class="operator">=</span> <span class="string">&#x27;计算机导论&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> B.Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>在数据库中要求每个经理的工资大于2000元。试在Depa表的定义时，加一个Check子句，以满足上述要求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Depa ADD CHECK (Mgr# IN (SELECT E# FROM Emp WHERE Salary &gt; 2000))</span><br></pre></td></tr></table></figure></li><li><p>更新Depa表，将经理编号（Mgr#）设置为null，满足条件：Depa表中的Mgr#等于Emp表中的E#，并且Emp表中的Age大于50。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Depa SET Mgr# = NULL WHERE Mgr# IN (SELECT E# FROM Emp WHERE Age &gt; 50)</span><br></pre></td></tr></table></figure></li><li><p>创建一个年龄大于50岁的职工视图（D#, Dname, E#, Ename, Age, Salary）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW wyy AS</span><br><span class="line">SELECT D#, Dname, E#, Ename, Age, Salary</span><br><span class="line">FROM Emp, Depa</span><br><span class="line">WHERE Emp.E# = Depa.Mgr# AND Emp.Age &gt; 50;</span><br></pre></td></tr></table></figure></li><li><p>用Create table 命令定义Depa表（需要定义主键和外键）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Depa (</span><br><span class="line">    D# <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    Dname <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">    Mgr# <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">    <span class="keyword">Foreign</span> key (Mgr#) <span class="keyword">references</span> Emp(E#)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门的职工人数和平均工资，要求显示（部门号，部门名称，职工人数，平均工资）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D#, Dname, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> 职工人数, <span class="built_in">AVG</span>(Salary) <span class="keyword">as</span> 平均工资</span><br><span class="line"><span class="keyword">FROM</span> Depa, Emp</span><br><span class="line"><span class="keyword">WHERE</span> Depa.D# <span class="operator">=</span> Emp.D#</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> D#</span><br></pre></td></tr></table></figure></li><li><p>在Depa表中删除人数少于10人的部门元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Depa</span><br><span class="line"><span class="keyword">WHERE</span> D# <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> D#</span><br><span class="line">    <span class="keyword">FROM</span> Emp</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> D#</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><div class="note warning"><p>对于上述关系代数与SQL的示例可能存在不合理的部分，请跟据实际情况修改，毕竟，只有生产环境才是有真正明确需求的与真实的环境。</p></div><h3 id="万用模版"><a href="#万用模版" class="headerlink" title="万用模版"></a>万用模版</h3><ul><li><p>查询模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名]</span><br><span class="line"><span class="keyword">FROM</span> [表名]</span><br><span class="line">[<span class="keyword">JOIN</span> 子句]</span><br><span class="line"><span class="keyword">WHERE</span> [条件]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> [列名]</span><br><span class="line"><span class="keyword">HAVING</span> [条件]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> [列名] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br><span class="line">LIMIT [数量];</span><br></pre></td></tr></table></figure></li><li><p>插入模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [表名] ([列<span class="number">1</span>], [列<span class="number">2</span>], ...)</span><br><span class="line"><span class="keyword">VALUES</span> ([值<span class="number">1</span>], [值<span class="number">2</span>], ...);</span><br></pre></td></tr></table></figure></li><li><p>修改模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [表名]</span><br><span class="line"><span class="keyword">SET</span> [列<span class="number">1</span>] <span class="operator">=</span> [新值<span class="number">1</span>], [列<span class="number">2</span>] <span class="operator">=</span> [新值<span class="number">2</span>], ...</span><br><span class="line"><span class="keyword">WHERE</span> [条件];</span><br></pre></td></tr></table></figure></li><li><p>删除模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [表名]</span><br><span class="line"><span class="keyword">WHERE</span> [条件];</span><br></pre></td></tr></table></figure></li><li><p>定义视图模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> [视图名] <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> [列<span class="number">1</span>], [列<span class="number">2</span>], ...</span><br><span class="line"><span class="keyword">FROM</span> [表名]</span><br><span class="line"><span class="keyword">WHERE</span> [条件];</span><br></pre></td></tr></table></figure><ul><li><p>解释说明：</p><ul><li><code>[视图名]</code>：指定要创建的视图的名称。</li><li><code>[列1], [列2], ...</code>：指定要包含在视图中的列名。</li><li><code>[表名]</code>：指定要从中提取数据的表名。</li><li><code>[条件]</code>：可选项，用于筛选特定的数据行。</li></ul></li><li><p>注意事项：</p><ul><li>方括号 <code>[ ]</code> 中的内容是需要替换为具体的值或表达式。</li><li>视图是从一个或多个基本表派生出来的虚拟表，其内容是基于查询的结果集。因此，在定义视图时，需要使用合适的 SELECT<br>语句来指定视图的内容。</li></ul></li></ul></li><li><p>建表模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [表名] (</span><br><span class="line">    [列<span class="number">1</span>] [数据类型] [约束],</span><br><span class="line">    [列<span class="number">2</span>] [数据类型] [约束],</span><br><span class="line">    ...</span><br><span class="line">    [列N] [数据类型] [约束]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>解释说明：</p><ul><li><code>[表名]</code>：指定要创建的表的名称。</li><li><code>[列1], [列2], ..., [列N]</code>：指定要创建的列名。</li><li><code>[数据类型]</code>：指定每个列的数据类型，如 INT、VARCHAR、DATE 等。</li><li><code>[约束]</code>：可选项，用于指定列级别的约束条件，如 PRIMARY KEY、NOT NULL、UNIQUE 等。</li></ul></li><li><p>注意事项：</p><ul><li>方括号 <code>[ ]</code> 中的内容是需要替换为具体的值或表达式。</li><li>每个列定义需要包含列名和数据类型。</li><li>可以在每个列定义后面添加约束来进一步定义列的行为和限制。</li><li>可以根据需要在表定义的末尾添加其他选项，如存储引擎、字符集等。</li></ul></li></ul></li><li><p>创建角色模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>解释说明：</p><ul><li><code>&#39;角色名&#39;</code>：指定要创建的角色名称，角色名称用单引号括起来。</li></ul></li><li><p>注意事项：</p><ul><li>角色名称应遵循 MySQL 的命名规则，如不能包含特殊字符、空格等。</li><li>创建角色需要具有适当的权限，通常是 <code>CREATE ROLE</code> 权限。</li></ul></li></ul></li><li><p>角色赋权模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">TO</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>解释说明：</p><ul><li><code>权限列表</code>：指定要授予给角色的权限，可以是单个权限或多个权限，多个权限之间使用逗号分隔。</li><li><code>&#39;角色名&#39;</code>：指定要授予权限的角色名称，角色名称用单引号括起来。</li></ul></li><li><p>注意事项：</p><ul><li>角色和权限都应存在于数据库中。</li><li>授予权限需要具有适当的权限，通常是 <code>GRANT</code> 权限。</li></ul></li><li><p>使用上述模板，你可以为角色赋予指定的权限。将 <code>&#39;角色名&#39;</code> 替换为实际的角色名称，将 <code>权限列表</code><br>替换为要授予的具体权限即可。如果需要授予多个权限，可以在 <code>权限列表</code> 中使用逗号分隔不同的权限项。</p><blockquote><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> database.table <span class="keyword">TO</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述示例将 SELECT、INSERT 和 UPDATE 权限授予给名为 <code>&#39;角色名&#39;</code> 的角色。你可以根据实际情况调整权限列表和角色名称。</p></blockquote></li></ul></li><li><p>授权模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> [权限列表] <span class="keyword">ON</span> [数据库].[表] <span class="keyword">TO</span> <span class="string">&#x27;[用户名]&#x27;</span>@<span class="string">&#x27;[主机]&#x27;</span> [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure><ul><li><p>解释说明：</p><ul><li><code>[权限列表]</code>：指定要授予的权限，可以是多个权限，用逗号分隔，如 SELECT, INSERT, UPDATE。</li><li><code>[数据库]</code>：指定要授予权限的数据库名称。如果要授予全局权限，可以使用通配符 <code>*</code>。</li><li><code>[表]</code>：可选项，指定要授予权限的表名。如果要授予数据库级别的权限，可以省略该部分。</li><li><code>&#39;[用户名]&#39;@&#39;[主机]&#39;</code><br>：指定要授予权限的用户和对应的主机。用户名和主机分别用单引号括起来。如果要授予全局权限，可以使用通配符 <code>%</code>。</li><li><code>WITH GRANT OPTION</code>：可选项，允许被授权的用户进一步授予该权限给其他用户。</li></ul></li><li><p>注意事项：</p><ul><li>方括号 <code>[ ]</code> 中的内容是需要替换为具体的值或表达式。</li><li>权限可以是诸如 SELECT、INSERT、UPDATE、DELETE 等数据库操作的关键字。</li><li>可以根据需要指定具体的数据库和表，或者使用通配符 <code>*</code> 表示所有数据库或表。</li><li>授权操作需要具有适当的权限，通常是 <code>GRANT OPTION</code> 权限。</li></ul></li></ul></li></ul><h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>E-R图（实体-关系图）是一种用于数据建模的图形工具，用于描述现实世界中的实体、实体之间的关系以及实体属性的结构化图形化表示。它基于实体-关系模型，是一种高层次、抽象的表示方式，用于在数据库设计和开发过程中描述实体、关系和属性之间的概念和关联。</p><p>E-R图由实体、关系和属性组成，其中：</p><ul><li>实体（Entity）代表现实世界中具有独立存在和可识别的事物，如人、物、地点或概念。每个实体都有一个唯一的标识符（主键），并具有属性描述实体的特征。</li><li>关系（Relationship）表示实体之间的联系或关联。关系可以是一对一、一对多或多对多的关系，用于描述实体之间的交互和依赖。</li><li>属性（Attribute）是实体的特征或描述，用于存储实体的具体数据。属性可以是简单属性（如姓名、年龄）或复合属性（如地址，由街道、城市和邮编组成）。</li></ul><p>通过使用符号和连接线，E-R图提供了一种直观的方式来可视化和表示实体、关系和属性之间的结构和相互作用。它是数据库设计和规划的重要工具，有助于理解和沟通数据模型的概念，以便更好地设计和管理数据库系统。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>Student(<u>id</u>, name, gender)</p><p>Class(<u>cid</u>, name)</p><p>Teacher(<u>tid</u>, gender, name)</p><p><strong>我们使用<code>_</code>来表述一张数据表中的主键字段。</strong></p><p><strong>图中连接表与表的线条，应该是干净的，不应该有类似于分支的部分，应该与连接表与字段的线条一致。</strong></p><img no-lazy class="inline" src="/picture/E-R图.png" style="height:500px;"/>]]></content>
      
      
      <categories>
          
          <category> Final Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog post</title>
      <link href="/2023/07/05/my-first-blog-post/"/>
      <url>/2023/07/05/my-first-blog-post/</url>
      
        <content type="html"><![CDATA[<h1 id="如何搭建一个属于自己的博客网站？"><a href="#如何搭建一个属于自己的博客网站？" class="headerlink" title="如何搭建一个属于自己的博客网站？"></a>如何搭建一个属于自己的博客网站？</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p><code>今天早些的时候我在看Nginx的教程，那位youtuber就使用了Hexo搭建的博客进行反向代理测试，于是我就很感兴趣，便去了解了一下</code></p><div class="link-group"><div class="tagLink"><a class="link-card" title="30分钟Nginx入门教程 - YouTube" href="https://youtu.be/sCJcusORiE8"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">30分钟Nginx入门教程 - YouTube</p><p class="url">https://youtu.be/sCJcusORiE8</p></div></a></div></div><p>访问<a href="https://hexo.io/">Hexo</a>以了解更多内容。</p><p>我选择了一个自己蛮喜欢的主题。</p><p>我也修改了很多配置项，不过总的说还是非常容易理解的。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>这过程中最最最离谱的问题（对我来说）是：关于git push的问题，经常push不上去，所以我就排查了问题原因，试过了修改<code>/etc/hosts</code>的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c &#x27;echo &quot;&lt;IP&gt; &lt;hostname&gt;&quot; &gt;&gt; /etc/hosts&#x27;</span><br></pre></td></tr></table></figure><p>也尝试了修改<code>http.version</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure><p>发现没有用，最后，我发现是代理的问题，因为在浏览器中打开GitHub没问题，但使用git的时候就<code>could&#39;t connect</code>，原因在于git默认不使用代理端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:[port]</span><br><span class="line">git config --global https.proxy 127.0.0.1:[port]</span><br></pre></td></tr></table></figure><p><code>port</code>为代理端口号</p><p>这个问题就如此解决了。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>说实话，太累了写这东西。</p>]]></content>
      
      
      <categories>
          
          <category> Pointless small talk </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
